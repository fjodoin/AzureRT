import { EventEmitter } from "events";
import { Coordinates } from "sigma/types";
/**
 * Useful types:
 * *************
 */
export type TextureCursor = Coordinates & {
    rowHeight: number;
    maxRowWidth: number;
};
export type ImageLoading = {
    status: "loading";
};
export type ImageError = {
    status: "error";
};
export type ImageReady = {
    status: "ready";
    image: HTMLImageElement;
    sourceX: number;
    sourceY: number;
    sourceSize: number;
    destinationSize: number;
    textureIndex?: number;
};
export type ImageType = ImageLoading | ImageError | ImageReady;
export type Atlas = Record<string, Coordinates & {
    size: number;
    textureIndex?: number;
}>;
export type TextureManagerOptions = {
    size: {
        mode: "auto";
    } | {
        mode: "max";
        value: number;
    } | {
        mode: "force";
        value: number;
    };
    objectFit: "contain" | "cover" | "fill";
    correctCentering: boolean;
    maxTextureSize: number;
    debounceTimeout: number | null;
    crossOrigin: CrossOrigin | null;
};
type CrossOrigin = "anonymous" | "use-credentials";
export declare const DEFAULT_TEXTURE_MANAGER_OPTIONS: TextureManagerOptions;
export declare const MARGIN_IN_TEXTURE = 1;
/**
 * Helpers:
 * ********
 */
/**
 * This helper loads an image at a given URL, and returns an HTMLImageElement
 * with it displayed once it's properly loaded, within a promise.
 */
export declare function loadRasterImage(imageSource: string, { crossOrigin }?: {
    crossOrigin?: CrossOrigin;
}): Promise<HTMLImageElement>;
/**
 * This helper loads an SVG image at a given URL, adjusts its size to a given
 * size, and returns an HTMLImageElement with it displayed once it's properly
 * loaded, within a promise.
 */
export declare function loadSVGImage(imageSource: string, { size, crossOrigin }?: {
    size?: number;
    crossOrigin?: CrossOrigin;
}): Promise<HTMLImageElement>;
/**
 * This helper loads an image using the proper function.
 */
export declare function loadImage(imageSource: string, { size, crossOrigin }?: {
    size?: number;
    crossOrigin?: CrossOrigin;
}): Promise<HTMLImageElement>;
/**
 * This helper computes exact coordinates to draw an image onto a texture.
 */
export declare function refineImage(image: HTMLImageElement, corrector: PictogramCenteringCorrector, { objectFit, size, correctCentering }: TextureManagerOptions): Omit<ImageReady, "status" | "image" | "textureIndex">;
/**
 * This helper takes an array of ready-to-draw images, and draws as much as possible in a single texture.
 * It then returns the atlas of the draw images, as well as the texture itself.
 */
export declare function drawTexture(images: (Omit<ImageReady, "status"> & {
    key: string;
})[], ctx: CanvasRenderingContext2D, cursor: TextureCursor): {
    atlas: Atlas;
    texture: ImageData;
    cursor: TextureCursor;
};
/**
 * This helper takes a collection of image states and a context, draw all the
 * images in the context, and returns an atlas to get where each image is drawn
 * on the texture.
 */
export declare function drawTextures({ atlas: prevAtlas, textures: prevTextures, cursor: prevCursor, }: {
    atlas: Atlas;
    textures: ImageData[];
    cursor: TextureCursor;
}, images: Record<string, ImageType>, ctx: CanvasRenderingContext2D): {
    atlas: Atlas;
    textures: ImageData[];
    cursor: TextureCursor;
};
/**
 * This class helps to "correct" the centering of an SVG pictogram by finding
 * the "true" visually correct center through the barycenter of the pictogram's
 * alpha layer in x and y dimension.
 */
export declare class PictogramCenteringCorrector {
    canvas: HTMLCanvasElement;
    context: CanvasRenderingContext2D;
    constructor();
    getCorrectionOffset(image: HTMLImageElement, size: number): Coordinates;
}
export declare class TextureManager extends EventEmitter {
    static NEW_TEXTURE_EVENT: string;
    private options;
    private canvas;
    private ctx;
    private frameId?;
    private corrector;
    private imageStates;
    private textures;
    private lastTextureCursor;
    private atlas;
    constructor(options?: Partial<TextureManagerOptions>);
    private scheduleGenerateTexture;
    private generateTextures;
    registerImage(source: string): Promise<void>;
    getAtlas(): Atlas;
    getTextures(): ImageData[];
}
export {};

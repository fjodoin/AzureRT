{"ast":null,"code":"/* eslint no-constant-condition: 0 */\n/**\n * Graphology ForceAtlas2 Iteration\n * =================================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0;\nvar NODE_Y = 1;\nvar NODE_DX = 2;\nvar NODE_DY = 3;\nvar NODE_OLD_DX = 4;\nvar NODE_OLD_DY = 5;\nvar NODE_MASS = 6;\nvar NODE_CONVERGENCE = 7;\nvar NODE_SIZE = 8;\nvar NODE_FIXED = 9;\nvar EDGE_SOURCE = 0;\nvar EDGE_TARGET = 1;\nvar EDGE_WEIGHT = 2;\nvar REGION_NODE = 0;\nvar REGION_CENTER_X = 1;\nvar REGION_CENTER_Y = 2;\nvar REGION_SIZE = 3;\nvar REGION_NEXT_SIBLING = 4;\nvar REGION_FIRST_CHILD = 5;\nvar REGION_MASS = 6;\nvar REGION_MASS_CENTER_X = 7;\nvar REGION_MASS_CENTER_Y = 8;\nvar SUBDIVISION_ATTEMPTS = 3;\n\n/**\n * Constants.\n */\nvar PPN = 10;\nvar PPE = 3;\nvar PPR = 9;\nvar MAX_FORCE = 10;\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @param  {Float32Array} EdgeMatrix - Edge data.\n * @return {object}                  - Some metadata.\n */\nmodule.exports = function iterate(options, NodeMatrix, EdgeMatrix) {\n  // Initializing variables\n  var l, r, n, n1, n2, rn, e, w, g, s;\n  var order = NodeMatrix.length,\n    size = EdgeMatrix.length;\n  var adjustSizes = options.adjustSizes;\n  var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;\n  var outboundAttCompensation, coefficient, xDist, yDist, ewc, distance, factor;\n  var RegionMatrix = [];\n\n  // 1) Initializing layout data\n  //-----------------------------\n\n  // Resetting positions & computing max values\n  for (n = 0; n < order; n += PPN) {\n    NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];\n    NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];\n    NodeMatrix[n + NODE_DX] = 0;\n    NodeMatrix[n + NODE_DY] = 0;\n  }\n\n  // If outbound attraction distribution, compensate\n  if (options.outboundAttractionDistribution) {\n    outboundAttCompensation = 0;\n    for (n = 0; n < order; n += PPN) {\n      outboundAttCompensation += NodeMatrix[n + NODE_MASS];\n    }\n    outboundAttCompensation /= order / PPN;\n  }\n\n  // 1.bis) Barnes-Hut computation\n  //------------------------------\n\n  if (options.barnesHutOptimize) {\n    // Setting up\n    var minX = Infinity,\n      maxX = -Infinity,\n      minY = Infinity,\n      maxY = -Infinity,\n      q,\n      q2,\n      subdivisionAttempts;\n\n    // Computing min and max values\n    for (n = 0; n < order; n += PPN) {\n      minX = Math.min(minX, NodeMatrix[n + NODE_X]);\n      maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);\n      minY = Math.min(minY, NodeMatrix[n + NODE_Y]);\n      maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);\n    }\n\n    // squarify bounds, it's a quadtree\n    var dx = maxX - minX,\n      dy = maxY - minY;\n    if (dx > dy) {\n      minY -= (dx - dy) / 2;\n      maxY = minY + dx;\n    } else {\n      minX -= (dy - dx) / 2;\n      maxX = minX + dy;\n    }\n\n    // Build the Barnes Hut root region\n    RegionMatrix[0 + REGION_NODE] = -1;\n    RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;\n    RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;\n    RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);\n    RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;\n    RegionMatrix[0 + REGION_FIRST_CHILD] = -1;\n    RegionMatrix[0 + REGION_MASS] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;\n\n    // Add each node in the tree\n    l = 1;\n    for (n = 0; n < order; n += PPN) {\n      // Current region, starting with root\n      r = 0;\n      subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n      while (true) {\n        // Are there sub-regions?\n\n        // We look at first child index\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // There are sub-regions\n\n          // We just iterate to find a \"leaf\" of the tree\n          // that is an empty region or a region with a single node\n          // (see next case)\n\n          // Find the quadrant of n\n          if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD];\n            } else {\n              // Bottom Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n            }\n          } else {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n            } else {\n              // Bottom Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n            }\n          }\n\n          // Update center of mass and mass (we only do it for non-leave regions)\n          RegionMatrix[r + REGION_MASS_CENTER_X] = (RegionMatrix[r + REGION_MASS_CENTER_X] * RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) / (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n          RegionMatrix[r + REGION_MASS_CENTER_Y] = (RegionMatrix[r + REGION_MASS_CENTER_Y] * RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) / (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n          RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];\n\n          // Iterate on the right quadrant\n          r = q;\n          continue;\n        } else {\n          // There are no sub-regions: we are in a \"leaf\"\n\n          // Is there a node in this leave?\n          if (RegionMatrix[r + REGION_NODE] < 0) {\n            // There is no node in region:\n            // we record node n and go on\n            RegionMatrix[r + REGION_NODE] = n;\n            break;\n          } else {\n            // There is a node in this region\n\n            // We will need to create sub-regions, stick the two\n            // nodes (the old one r[0] and the new one n) in two\n            // subregions. If they fall in the same quadrant,\n            // we will iterate.\n\n            // Create sub-regions\n            RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;\n            w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)\n\n            // NOTE: we use screen coordinates\n            // from Top Left to Bottom Right\n\n            // Top Left sub-region\n            g = RegionMatrix[r + REGION_FIRST_CHILD];\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Left sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Top Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] = RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] = RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = RegionMatrix[r + REGION_NEXT_SIBLING];\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n            l += 4;\n\n            // Now the goal is to find two different sub-regions\n            // for the two nodes: the one previously recorded (r[0])\n            // and the one we want to add (n)\n\n            // Find the quadrant of the old node\n            if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            // We remove r[0] from the region r, add its mass to r and record it in q\n            RegionMatrix[r + REGION_MASS] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];\n            RegionMatrix[r + REGION_MASS_CENTER_X] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];\n            RegionMatrix[r + REGION_MASS_CENTER_Y] = NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];\n            RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];\n            RegionMatrix[r + REGION_NODE] = -1;\n\n            // Find the quadrant of n\n            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n            if (q === q2) {\n              // If both nodes are in the same quadrant,\n              // we have to try it again on this quadrant\n              if (subdivisionAttempts--) {\n                r = q;\n                continue; // while\n              } else {\n                // we are out of precision here, and we cannot subdivide anymore\n                // but we have to break the loop anyway\n                subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n                break; // while\n              }\n            }\n\n            // If both quadrants are different, we record n\n            // in its quadrant\n            RegionMatrix[q2 + REGION_NODE] = n;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // 2) Repulsion\n  //--------------\n  // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient\n\n  if (options.barnesHutOptimize) {\n    coefficient = options.scalingRatio;\n\n    // Applying repulsion through regions\n    for (n = 0; n < order; n += PPN) {\n      // Computing leaf quad nodes iteration\n\n      r = 0; // Starting with root region\n      while (true) {\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // The region has sub-regions\n\n          // We run the Barnes Hut test to see if we are at the right distance\n          distance = Math.pow(NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X], 2) + Math.pow(NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y], 2);\n          s = RegionMatrix[r + REGION_SIZE];\n          if (4 * s * s / distance < thetaSquared) {\n            // We treat the region as a single body, and we repulse\n\n            xDist = NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];\n            yDist = NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] * RegionMatrix[r + REGION_MASS] / distance;\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor = -coefficient * NodeMatrix[n + NODE_MASS] * RegionMatrix[r + REGION_MASS] / Math.sqrt(distance);\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] * RegionMatrix[r + REGION_MASS] / distance;\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n            // When this is done, we iterate. We have to look at the next sibling.\n            r = RegionMatrix[r + REGION_NEXT_SIBLING];\n            if (r < 0) break; // No next sibling: we have finished the tree\n\n            continue;\n          } else {\n            // The region is too close and we have to look at sub-regions\n            r = RegionMatrix[r + REGION_FIRST_CHILD];\n            continue;\n          }\n        } else {\n          // The region has no sub-region\n          // If there is a node r[0] and it is not n, then repulse\n          rn = RegionMatrix[r + REGION_NODE];\n          if (rn >= 0 && rn !== n) {\n            xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];\n            yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];\n            distance = xDist * xDist + yDist * yDist;\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] * NodeMatrix[rn + NODE_MASS] / distance;\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor = -coefficient * NodeMatrix[n + NODE_MASS] * NodeMatrix[rn + NODE_MASS] / Math.sqrt(distance);\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor = coefficient * NodeMatrix[n + NODE_MASS] * NodeMatrix[rn + NODE_MASS] / distance;\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n          }\n\n          // When this is done, we iterate. We have to look at the next sibling.\n          r = RegionMatrix[r + REGION_NEXT_SIBLING];\n          if (r < 0) break; // No next sibling: we have finished the tree\n\n          continue;\n        }\n      }\n    }\n  } else {\n    coefficient = options.scalingRatio;\n\n    // Square iteration\n    for (n1 = 0; n1 < order; n1 += PPN) {\n      for (n2 = 0; n2 < n1; n2 += PPN) {\n        // Common to both methods\n        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n        if (adjustSizes === true) {\n          //-- Anticollision Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist) - NodeMatrix[n1 + NODE_SIZE] - NodeMatrix[n2 + NODE_SIZE];\n          if (distance > 0) {\n            factor = coefficient * NodeMatrix[n1 + NODE_MASS] * NodeMatrix[n2 + NODE_MASS] / distance / distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          } else if (distance < 0) {\n            factor = 100 * coefficient * NodeMatrix[n1 + NODE_MASS] * NodeMatrix[n2 + NODE_MASS];\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        } else {\n          //-- Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist);\n          if (distance > 0) {\n            factor = coefficient * NodeMatrix[n1 + NODE_MASS] * NodeMatrix[n2 + NODE_MASS] / distance / distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n      }\n    }\n  }\n\n  // 3) Gravity\n  //------------\n  g = options.gravity / options.scalingRatio;\n  coefficient = options.scalingRatio;\n  for (n = 0; n < order; n += PPN) {\n    factor = 0;\n\n    // Common to both methods\n    xDist = NodeMatrix[n + NODE_X];\n    yDist = NodeMatrix[n + NODE_Y];\n    distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n    if (options.strongGravityMode) {\n      //-- Strong gravity\n      if (distance > 0) factor = coefficient * NodeMatrix[n + NODE_MASS] * g;\n    } else {\n      //-- Linear Anti-collision Repulsion n\n      if (distance > 0) factor = coefficient * NodeMatrix[n + NODE_MASS] * g / distance;\n    }\n\n    // Updating node's dx and dy\n    NodeMatrix[n + NODE_DX] -= xDist * factor;\n    NodeMatrix[n + NODE_DY] -= yDist * factor;\n  }\n\n  // 4) Attraction\n  //---------------\n  coefficient = 1 * (options.outboundAttractionDistribution ? outboundAttCompensation : 1);\n\n  // TODO: simplify distance\n  // TODO: coefficient is always used as -c --> optimize?\n  for (e = 0; e < size; e += PPE) {\n    n1 = EdgeMatrix[e + EDGE_SOURCE];\n    n2 = EdgeMatrix[e + EDGE_TARGET];\n    w = EdgeMatrix[e + EDGE_WEIGHT];\n\n    // Edge weight influence\n    ewc = Math.pow(w, options.edgeWeightInfluence);\n\n    // Common measures\n    xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n    yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n    // Applying attraction to nodes\n    if (adjustSizes === true) {\n      distance = Math.sqrt(xDist * xDist + yDist * yDist) - NodeMatrix[n1 + NODE_SIZE] - NodeMatrix[n2 + NODE_SIZE];\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc * Math.log(1 + distance) / distance / NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc * Math.log(1 + distance) / distance;\n          }\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- Linear Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc;\n          }\n        }\n      }\n    } else {\n      distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc * Math.log(1 + distance) / distance / NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Attraction\n          if (distance > 0) factor = -coefficient * ewc * Math.log(1 + distance) / distance;\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Attraction Mass Distributed\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc / NodeMatrix[n1 + NODE_MASS];\n        } else {\n          //-- Linear Attraction\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc;\n        }\n      }\n    }\n\n    // Updating nodes' dx and dy\n    // TODO: if condition or factor = 1?\n    if (distance > 0) {\n      // Updating nodes' dx and dy\n      NodeMatrix[n1 + NODE_DX] += xDist * factor;\n      NodeMatrix[n1 + NODE_DY] += yDist * factor;\n      NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n      NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n    }\n  }\n\n  // 5) Apply Forces\n  //-----------------\n  var force, swinging, traction, nodespeed, newX, newY;\n\n  // MATH: sqrt and square distances\n  if (adjustSizes === true) {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        force = Math.sqrt(Math.pow(NodeMatrix[n + NODE_DX], 2) + Math.pow(NodeMatrix[n + NODE_DY], 2));\n        if (force > MAX_FORCE) {\n          NodeMatrix[n + NODE_DX] = NodeMatrix[n + NODE_DX] * MAX_FORCE / force;\n          NodeMatrix[n + NODE_DY] = NodeMatrix[n + NODE_DY] * MAX_FORCE / force;\n        }\n        swinging = NodeMatrix[n + NODE_MASS] * Math.sqrt((NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) * (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) + (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) * (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]));\n        traction = Math.sqrt((NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) * (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) + (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) * (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])) / 2;\n        nodespeed = 0.1 * Math.log(1 + traction) / (1 + Math.sqrt(swinging));\n\n        // Updating node's positon\n        newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n        newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  } else {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        swinging = NodeMatrix[n + NODE_MASS] * Math.sqrt((NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) * (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) + (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) * (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]));\n        traction = Math.sqrt((NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) * (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) + (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) * (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])) / 2;\n        nodespeed = NodeMatrix[n + NODE_CONVERGENCE] * Math.log(1 + traction) / (1 + Math.sqrt(swinging));\n\n        // Updating node convergence\n        NodeMatrix[n + NODE_CONVERGENCE] = Math.min(1, Math.sqrt(nodespeed * (Math.pow(NodeMatrix[n + NODE_DX], 2) + Math.pow(NodeMatrix[n + NODE_DY], 2)) / (1 + Math.sqrt(swinging))));\n\n        // Updating node's positon\n        newX = NodeMatrix[n + NODE_X] + NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n        newY = NodeMatrix[n + NODE_Y] + NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n\n  // We return the information about the layout (no need to return the matrices)\n  return {};\n};","map":{"version":3,"names":["NODE_X","NODE_Y","NODE_DX","NODE_DY","NODE_OLD_DX","NODE_OLD_DY","NODE_MASS","NODE_CONVERGENCE","NODE_SIZE","NODE_FIXED","EDGE_SOURCE","EDGE_TARGET","EDGE_WEIGHT","REGION_NODE","REGION_CENTER_X","REGION_CENTER_Y","REGION_SIZE","REGION_NEXT_SIBLING","REGION_FIRST_CHILD","REGION_MASS","REGION_MASS_CENTER_X","REGION_MASS_CENTER_Y","SUBDIVISION_ATTEMPTS","PPN","PPE","PPR","MAX_FORCE","module","exports","iterate","options","NodeMatrix","EdgeMatrix","l","r","n","n1","n2","rn","e","w","g","s","order","length","size","adjustSizes","thetaSquared","barnesHutTheta","outboundAttCompensation","coefficient","xDist","yDist","ewc","distance","factor","RegionMatrix","outboundAttractionDistribution","barnesHutOptimize","minX","Infinity","maxX","minY","maxY","q","q2","subdivisionAttempts","Math","min","max","dx","dy","scalingRatio","pow","sqrt","gravity","strongGravityMode","edgeWeightInfluence","linLogMode","log","force","swinging","traction","nodespeed","newX","newY","slowDown"],"sources":["/Users/fjodoin/Desktop/Research/AzureRT/azure_resource_graph/training/graphing/sigma-graph/node_modules/graphology-layout-forceatlas2/iterate.js"],"sourcesContent":["/* eslint no-constant-condition: 0 */\n/**\n * Graphology ForceAtlas2 Iteration\n * =================================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0;\nvar NODE_Y = 1;\nvar NODE_DX = 2;\nvar NODE_DY = 3;\nvar NODE_OLD_DX = 4;\nvar NODE_OLD_DY = 5;\nvar NODE_MASS = 6;\nvar NODE_CONVERGENCE = 7;\nvar NODE_SIZE = 8;\nvar NODE_FIXED = 9;\n\nvar EDGE_SOURCE = 0;\nvar EDGE_TARGET = 1;\nvar EDGE_WEIGHT = 2;\n\nvar REGION_NODE = 0;\nvar REGION_CENTER_X = 1;\nvar REGION_CENTER_Y = 2;\nvar REGION_SIZE = 3;\nvar REGION_NEXT_SIBLING = 4;\nvar REGION_FIRST_CHILD = 5;\nvar REGION_MASS = 6;\nvar REGION_MASS_CENTER_X = 7;\nvar REGION_MASS_CENTER_Y = 8;\n\nvar SUBDIVISION_ATTEMPTS = 3;\n\n/**\n * Constants.\n */\nvar PPN = 10;\nvar PPE = 3;\nvar PPR = 9;\n\nvar MAX_FORCE = 10;\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @param  {Float32Array} EdgeMatrix - Edge data.\n * @return {object}                  - Some metadata.\n */\nmodule.exports = function iterate(options, NodeMatrix, EdgeMatrix) {\n  // Initializing variables\n  var l, r, n, n1, n2, rn, e, w, g, s;\n\n  var order = NodeMatrix.length,\n    size = EdgeMatrix.length;\n\n  var adjustSizes = options.adjustSizes;\n\n  var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;\n\n  var outboundAttCompensation, coefficient, xDist, yDist, ewc, distance, factor;\n\n  var RegionMatrix = [];\n\n  // 1) Initializing layout data\n  //-----------------------------\n\n  // Resetting positions & computing max values\n  for (n = 0; n < order; n += PPN) {\n    NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];\n    NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];\n    NodeMatrix[n + NODE_DX] = 0;\n    NodeMatrix[n + NODE_DY] = 0;\n  }\n\n  // If outbound attraction distribution, compensate\n  if (options.outboundAttractionDistribution) {\n    outboundAttCompensation = 0;\n    for (n = 0; n < order; n += PPN) {\n      outboundAttCompensation += NodeMatrix[n + NODE_MASS];\n    }\n\n    outboundAttCompensation /= order / PPN;\n  }\n\n  // 1.bis) Barnes-Hut computation\n  //------------------------------\n\n  if (options.barnesHutOptimize) {\n    // Setting up\n    var minX = Infinity,\n      maxX = -Infinity,\n      minY = Infinity,\n      maxY = -Infinity,\n      q,\n      q2,\n      subdivisionAttempts;\n\n    // Computing min and max values\n    for (n = 0; n < order; n += PPN) {\n      minX = Math.min(minX, NodeMatrix[n + NODE_X]);\n      maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);\n      minY = Math.min(minY, NodeMatrix[n + NODE_Y]);\n      maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);\n    }\n\n    // squarify bounds, it's a quadtree\n    var dx = maxX - minX,\n      dy = maxY - minY;\n    if (dx > dy) {\n      minY -= (dx - dy) / 2;\n      maxY = minY + dx;\n    } else {\n      minX -= (dy - dx) / 2;\n      maxX = minX + dy;\n    }\n\n    // Build the Barnes Hut root region\n    RegionMatrix[0 + REGION_NODE] = -1;\n    RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;\n    RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;\n    RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);\n    RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;\n    RegionMatrix[0 + REGION_FIRST_CHILD] = -1;\n    RegionMatrix[0 + REGION_MASS] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;\n\n    // Add each node in the tree\n    l = 1;\n    for (n = 0; n < order; n += PPN) {\n      // Current region, starting with root\n      r = 0;\n      subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n\n      while (true) {\n        // Are there sub-regions?\n\n        // We look at first child index\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // There are sub-regions\n\n          // We just iterate to find a \"leaf\" of the tree\n          // that is an empty region or a region with a single node\n          // (see next case)\n\n          // Find the quadrant of n\n          if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD];\n            } else {\n              // Bottom Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n            }\n          } else {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n            } else {\n              // Bottom Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n            }\n          }\n\n          // Update center of mass and mass (we only do it for non-leave regions)\n          RegionMatrix[r + REGION_MASS_CENTER_X] =\n            (RegionMatrix[r + REGION_MASS_CENTER_X] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS_CENTER_Y] =\n            (RegionMatrix[r + REGION_MASS_CENTER_Y] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];\n\n          // Iterate on the right quadrant\n          r = q;\n          continue;\n        } else {\n          // There are no sub-regions: we are in a \"leaf\"\n\n          // Is there a node in this leave?\n          if (RegionMatrix[r + REGION_NODE] < 0) {\n            // There is no node in region:\n            // we record node n and go on\n            RegionMatrix[r + REGION_NODE] = n;\n            break;\n          } else {\n            // There is a node in this region\n\n            // We will need to create sub-regions, stick the two\n            // nodes (the old one r[0] and the new one n) in two\n            // subregions. If they fall in the same quadrant,\n            // we will iterate.\n\n            // Create sub-regions\n            RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;\n            w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)\n\n            // NOTE: we use screen coordinates\n            // from Top Left to Bottom Right\n\n            // Top Left sub-region\n            g = RegionMatrix[r + REGION_FIRST_CHILD];\n\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Left sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Top Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] =\n              RegionMatrix[r + REGION_NEXT_SIBLING];\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            l += 4;\n\n            // Now the goal is to find two different sub-regions\n            // for the two nodes: the one previously recorded (r[0])\n            // and the one we want to add (n)\n\n            // Find the quadrant of the old node\n            if (\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] <\n              RegionMatrix[r + REGION_CENTER_X]\n            ) {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            // We remove r[0] from the region r, add its mass to r and record it in q\n            RegionMatrix[r + REGION_MASS] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];\n            RegionMatrix[r + REGION_MASS_CENTER_X] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];\n            RegionMatrix[r + REGION_MASS_CENTER_Y] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];\n\n            RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];\n            RegionMatrix[r + REGION_NODE] = -1;\n\n            // Find the quadrant of n\n            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            if (q === q2) {\n              // If both nodes are in the same quadrant,\n              // we have to try it again on this quadrant\n              if (subdivisionAttempts--) {\n                r = q;\n                continue; // while\n              } else {\n                // we are out of precision here, and we cannot subdivide anymore\n                // but we have to break the loop anyway\n                subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n                break; // while\n              }\n            }\n\n            // If both quadrants are different, we record n\n            // in its quadrant\n            RegionMatrix[q2 + REGION_NODE] = n;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // 2) Repulsion\n  //--------------\n  // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient\n\n  if (options.barnesHutOptimize) {\n    coefficient = options.scalingRatio;\n\n    // Applying repulsion through regions\n    for (n = 0; n < order; n += PPN) {\n      // Computing leaf quad nodes iteration\n\n      r = 0; // Starting with root region\n      while (true) {\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // The region has sub-regions\n\n          // We run the Barnes Hut test to see if we are at the right distance\n          distance =\n            Math.pow(\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X],\n              2\n            ) +\n            Math.pow(\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y],\n              2\n            );\n\n          s = RegionMatrix[r + REGION_SIZE];\n\n          if ((4 * s * s) / distance < thetaSquared) {\n            // We treat the region as a single body, and we repulse\n\n            xDist =\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];\n            yDist =\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n            // When this is done, we iterate. We have to look at the next sibling.\n            r = RegionMatrix[r + REGION_NEXT_SIBLING];\n            if (r < 0) break; // No next sibling: we have finished the tree\n\n            continue;\n          } else {\n            // The region is too close and we have to look at sub-regions\n            r = RegionMatrix[r + REGION_FIRST_CHILD];\n            continue;\n          }\n        } else {\n          // The region has no sub-region\n          // If there is a node r[0] and it is not n, then repulse\n          rn = RegionMatrix[r + REGION_NODE];\n\n          if (rn >= 0 && rn !== n) {\n            xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];\n            yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];\n\n            distance = xDist * xDist + yDist * yDist;\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n          }\n\n          // When this is done, we iterate. We have to look at the next sibling.\n          r = RegionMatrix[r + REGION_NEXT_SIBLING];\n\n          if (r < 0) break; // No next sibling: we have finished the tree\n\n          continue;\n        }\n      }\n    }\n  } else {\n    coefficient = options.scalingRatio;\n\n    // Square iteration\n    for (n1 = 0; n1 < order; n1 += PPN) {\n      for (n2 = 0; n2 < n1; n2 += PPN) {\n        // Common to both methods\n        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n        if (adjustSizes === true) {\n          //-- Anticollision Linear Repulsion\n          distance =\n            Math.sqrt(xDist * xDist + yDist * yDist) -\n            NodeMatrix[n1 + NODE_SIZE] -\n            NodeMatrix[n2 + NODE_SIZE];\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          } else if (distance < 0) {\n            factor =\n              100 *\n              coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS];\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        } else {\n          //-- Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist);\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n      }\n    }\n  }\n\n  // 3) Gravity\n  //------------\n  g = options.gravity / options.scalingRatio;\n  coefficient = options.scalingRatio;\n  for (n = 0; n < order; n += PPN) {\n    factor = 0;\n\n    // Common to both methods\n    xDist = NodeMatrix[n + NODE_X];\n    yDist = NodeMatrix[n + NODE_Y];\n    distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n    if (options.strongGravityMode) {\n      //-- Strong gravity\n      if (distance > 0) factor = coefficient * NodeMatrix[n + NODE_MASS] * g;\n    } else {\n      //-- Linear Anti-collision Repulsion n\n      if (distance > 0)\n        factor = (coefficient * NodeMatrix[n + NODE_MASS] * g) / distance;\n    }\n\n    // Updating node's dx and dy\n    NodeMatrix[n + NODE_DX] -= xDist * factor;\n    NodeMatrix[n + NODE_DY] -= yDist * factor;\n  }\n\n  // 4) Attraction\n  //---------------\n  coefficient =\n    1 * (options.outboundAttractionDistribution ? outboundAttCompensation : 1);\n\n  // TODO: simplify distance\n  // TODO: coefficient is always used as -c --> optimize?\n  for (e = 0; e < size; e += PPE) {\n    n1 = EdgeMatrix[e + EDGE_SOURCE];\n    n2 = EdgeMatrix[e + EDGE_TARGET];\n    w = EdgeMatrix[e + EDGE_WEIGHT];\n\n    // Edge weight influence\n    ewc = Math.pow(w, options.edgeWeightInfluence);\n\n    // Common measures\n    xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n    yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n    // Applying attraction to nodes\n    if (adjustSizes === true) {\n      distance =\n        Math.sqrt(xDist * xDist + yDist * yDist) -\n        NodeMatrix[n1 + NODE_SIZE] -\n        NodeMatrix[n2 + NODE_SIZE];\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n          }\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- Linear Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc;\n          }\n        }\n      }\n    } else {\n      distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Attraction\n          if (distance > 0)\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Attraction Mass Distributed\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n        } else {\n          //-- Linear Attraction\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc;\n        }\n      }\n    }\n\n    // Updating nodes' dx and dy\n    // TODO: if condition or factor = 1?\n    if (distance > 0) {\n      // Updating nodes' dx and dy\n      NodeMatrix[n1 + NODE_DX] += xDist * factor;\n      NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n      NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n      NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n    }\n  }\n\n  // 5) Apply Forces\n  //-----------------\n  var force, swinging, traction, nodespeed, newX, newY;\n\n  // MATH: sqrt and square distances\n  if (adjustSizes === true) {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        force = Math.sqrt(\n          Math.pow(NodeMatrix[n + NODE_DX], 2) +\n            Math.pow(NodeMatrix[n + NODE_DY], 2)\n        );\n\n        if (force > MAX_FORCE) {\n          NodeMatrix[n + NODE_DX] =\n            (NodeMatrix[n + NODE_DX] * MAX_FORCE) / force;\n          NodeMatrix[n + NODE_DY] =\n            (NodeMatrix[n + NODE_DY] * MAX_FORCE) / force;\n        }\n\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed = (0.1 * Math.log(1 + traction)) / (1 + Math.sqrt(swinging));\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  } else {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed =\n          (NodeMatrix[n + NODE_CONVERGENCE] * Math.log(1 + traction)) /\n          (1 + Math.sqrt(swinging));\n\n        // Updating node convergence\n        NodeMatrix[n + NODE_CONVERGENCE] = Math.min(\n          1,\n          Math.sqrt(\n            (nodespeed *\n              (Math.pow(NodeMatrix[n + NODE_DX], 2) +\n                Math.pow(NodeMatrix[n + NODE_DY], 2))) /\n              (1 + Math.sqrt(swinging))\n          )\n        );\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n\n  // We return the information about the layout (no need to return the matrices)\n  return {};\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
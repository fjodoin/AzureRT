{"ast":null,"code":"/**\n * Graphology Edge Adders\n * =======================\n *\n * Generic edge addition functions that can be used to avoid nasty repetitive\n * conditions.\n */\nexports.addEdge = function addEdge(graph, undirected, key, source, target, attributes) {\n  if (undirected) {\n    if (key === null || key === undefined) return graph.addUndirectedEdge(source, target, attributes);else return graph.addUndirectedEdgeWithKey(key, source, target, attributes);\n  } else {\n    if (key === null || key === undefined) return graph.addDirectedEdge(source, target, attributes);else return graph.addDirectedEdgeWithKey(key, source, target, attributes);\n  }\n};\nexports.copyEdge = function copyEdge(graph, undirected, key, source, target, attributes) {\n  attributes = Object.assign({}, attributes);\n  if (undirected) {\n    if (key === null || key === undefined) return graph.addUndirectedEdge(source, target, attributes);else return graph.addUndirectedEdgeWithKey(key, source, target, attributes);\n  } else {\n    if (key === null || key === undefined) return graph.addDirectedEdge(source, target, attributes);else return graph.addDirectedEdgeWithKey(key, source, target, attributes);\n  }\n};\nexports.mergeEdge = function mergeEdge(graph, undirected, key, source, target, attributes) {\n  if (undirected) {\n    if (key === null || key === undefined) return graph.mergeUndirectedEdge(source, target, attributes);else return graph.mergeUndirectedEdgeWithKey(key, source, target, attributes);\n  } else {\n    if (key === null || key === undefined) return graph.mergeDirectedEdge(source, target, attributes);else return graph.mergeDirectedEdgeWithKey(key, source, target, attributes);\n  }\n};\nexports.updateEdge = function updateEdge(graph, undirected, key, source, target, updater) {\n  if (undirected) {\n    if (key === null || key === undefined) return graph.updateUndirectedEdge(source, target, updater);else return graph.updateUndirectedEdgeWithKey(key, source, target, updater);\n  } else {\n    if (key === null || key === undefined) return graph.updateDirectedEdge(source, target, updater);else return graph.updateDirectedEdgeWithKey(key, source, target, updater);\n  }\n};","map":{"version":3,"names":["exports","addEdge","graph","undirected","key","source","target","attributes","undefined","addUndirectedEdge","addUndirectedEdgeWithKey","addDirectedEdge","addDirectedEdgeWithKey","copyEdge","Object","assign","mergeEdge","mergeUndirectedEdge","mergeUndirectedEdgeWithKey","mergeDirectedEdge","mergeDirectedEdgeWithKey","updateEdge","updater","updateUndirectedEdge","updateUndirectedEdgeWithKey","updateDirectedEdge","updateDirectedEdgeWithKey"],"sources":["/Users/fjodoin/Desktop/Research/AzureRT/azure_resource_graph/training/graphing/sigma-graph/node_modules/graphology-utils/add-edge.js"],"sourcesContent":["/**\n * Graphology Edge Adders\n * =======================\n *\n * Generic edge addition functions that can be used to avoid nasty repetitive\n * conditions.\n */\nexports.addEdge = function addEdge(\n  graph,\n  undirected,\n  key,\n  source,\n  target,\n  attributes\n) {\n  if (undirected) {\n    if (key === null || key === undefined)\n      return graph.addUndirectedEdge(source, target, attributes);\n    else return graph.addUndirectedEdgeWithKey(key, source, target, attributes);\n  } else {\n    if (key === null || key === undefined)\n      return graph.addDirectedEdge(source, target, attributes);\n    else return graph.addDirectedEdgeWithKey(key, source, target, attributes);\n  }\n};\n\nexports.copyEdge = function copyEdge(\n  graph,\n  undirected,\n  key,\n  source,\n  target,\n  attributes\n) {\n  attributes = Object.assign({}, attributes);\n\n  if (undirected) {\n    if (key === null || key === undefined)\n      return graph.addUndirectedEdge(source, target, attributes);\n    else return graph.addUndirectedEdgeWithKey(key, source, target, attributes);\n  } else {\n    if (key === null || key === undefined)\n      return graph.addDirectedEdge(source, target, attributes);\n    else return graph.addDirectedEdgeWithKey(key, source, target, attributes);\n  }\n};\n\nexports.mergeEdge = function mergeEdge(\n  graph,\n  undirected,\n  key,\n  source,\n  target,\n  attributes\n) {\n  if (undirected) {\n    if (key === null || key === undefined)\n      return graph.mergeUndirectedEdge(source, target, attributes);\n    else\n      return graph.mergeUndirectedEdgeWithKey(key, source, target, attributes);\n  } else {\n    if (key === null || key === undefined)\n      return graph.mergeDirectedEdge(source, target, attributes);\n    else return graph.mergeDirectedEdgeWithKey(key, source, target, attributes);\n  }\n};\n\nexports.updateEdge = function updateEdge(\n  graph,\n  undirected,\n  key,\n  source,\n  target,\n  updater\n) {\n  if (undirected) {\n    if (key === null || key === undefined)\n      return graph.updateUndirectedEdge(source, target, updater);\n    else return graph.updateUndirectedEdgeWithKey(key, source, target, updater);\n  } else {\n    if (key === null || key === undefined)\n      return graph.updateDirectedEdge(source, target, updater);\n    else return graph.updateDirectedEdgeWithKey(key, source, target, updater);\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
{"ast":null,"code":"import { _ as _objectSpread2, a as _defineProperty } from './index-236c62ad.esm.js';\nimport { _ as _inherits, a as _createClass, b as _classCallCheck, c as _callSuper, d as _toPropertyKey } from './inherits-d1a1e29b.esm.js';\nimport { TypedEventEmitter } from '../types/dist/sigma-types.esm.js';\nimport { A as ANIMATE_DEFAULTS, e as easings, g as graphExtent, c as createNormalizationFunction, m as matrixFromCamera, z as zIndexOrdering, a as getMatrixImpact, b as createElement, d as getPixelRatio, f as multiplyVec2, i as identity, v as validateGraph } from './normalization-be445518.esm.js';\nimport { DEFAULT_SETTINGS, validateSettings, resolveSettings } from '../settings/dist/sigma-settings.esm.js';\nimport { _ as _slicedToArray, a as _arrayLikeToArray, b as _unsupportedIterableToArray, g as getPixelColor, c as colorToIndex } from './colors-beb06eb2.esm.js';\nimport { _ as _typeof, e as extend } from './data-11df7124.esm.js';\nimport 'events';\nimport 'graphology-utils/is-graph';\n\n/**\n * Defaults.\n */\nvar DEFAULT_ZOOMING_RATIO = 1.5;\n\n/**\n * Event types.\n */\n/**\n * Camera class\n */\nvar Camera = /*#__PURE__*/function (_TypedEventEmitter) {\n  function Camera() {\n    var _this;\n    _classCallCheck(this, Camera);\n    _this = _callSuper(this, Camera);\n\n    // State\n    _defineProperty(_this, \"x\", 0.5);\n    _defineProperty(_this, \"y\", 0.5);\n    _defineProperty(_this, \"angle\", 0);\n    _defineProperty(_this, \"ratio\", 1);\n    _defineProperty(_this, \"minRatio\", null);\n    _defineProperty(_this, \"maxRatio\", null);\n    _defineProperty(_this, \"enabledZooming\", true);\n    _defineProperty(_this, \"enabledPanning\", true);\n    _defineProperty(_this, \"enabledRotation\", true);\n    _defineProperty(_this, \"clean\", null);\n    _defineProperty(_this, \"nextFrame\", null);\n    _defineProperty(_this, \"previousState\", null);\n    _defineProperty(_this, \"enabled\", true);\n    _this.previousState = _this.getState();\n    return _this;\n  }\n\n  /**\n   * Static method used to create a Camera object with a given state.\n   */\n  _inherits(Camera, _TypedEventEmitter);\n  return _createClass(Camera, [{\n    key: \"enable\",\n    value:\n    /**\n     * Method used to enable the camera.\n     */\n    function enable() {\n      this.enabled = true;\n      return this;\n    }\n\n    /**\n     * Method used to disable the camera.\n     */\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n\n    /**\n     * Method used to retrieve the camera's current state.\n     */\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return {\n        x: this.x,\n        y: this.y,\n        angle: this.angle,\n        ratio: this.ratio\n      };\n    }\n\n    /**\n     * Method used to check whether the camera has the given state.\n     */\n  }, {\n    key: \"hasState\",\n    value: function hasState(state) {\n      return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n    }\n\n    /**\n     * Method used to retrieve the camera's previous state.\n     */\n  }, {\n    key: \"getPreviousState\",\n    value: function getPreviousState() {\n      var state = this.previousState;\n      if (!state) return null;\n      return {\n        x: state.x,\n        y: state.y,\n        angle: state.angle,\n        ratio: state.ratio\n      };\n    }\n\n    /**\n     * Method used to check minRatio and maxRatio values.\n     */\n  }, {\n    key: \"getBoundedRatio\",\n    value: function getBoundedRatio(ratio) {\n      var r = ratio;\n      if (typeof this.minRatio === \"number\") r = Math.max(r, this.minRatio);\n      if (typeof this.maxRatio === \"number\") r = Math.min(r, this.maxRatio);\n      return r;\n    }\n\n    /**\n     * Method used to check various things to return a legit state candidate.\n     */\n  }, {\n    key: \"validateState\",\n    value: function validateState(state) {\n      var validatedState = {};\n      if (this.enabledPanning && typeof state.x === \"number\") validatedState.x = state.x;\n      if (this.enabledPanning && typeof state.y === \"number\") validatedState.y = state.y;\n      if (this.enabledZooming && typeof state.ratio === \"number\") validatedState.ratio = this.getBoundedRatio(state.ratio);\n      if (this.enabledRotation && typeof state.angle === \"number\") validatedState.angle = state.angle;\n      return this.clean ? this.clean(_objectSpread2(_objectSpread2({}, this.getState()), validatedState)) : validatedState;\n    }\n\n    /**\n     * Method used to check whether the camera is currently being animated.\n     */\n  }, {\n    key: \"isAnimated\",\n    value: function isAnimated() {\n      return !!this.nextFrame;\n    }\n\n    /**\n     * Method used to set the camera's state.\n     */\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      if (!this.enabled) return this;\n\n      // Keeping track of last state\n      this.previousState = this.getState();\n      var validState = this.validateState(state);\n      if (typeof validState.x === \"number\") this.x = validState.x;\n      if (typeof validState.y === \"number\") this.y = validState.y;\n      if (typeof validState.ratio === \"number\") this.ratio = validState.ratio;\n      if (typeof validState.angle === \"number\") this.angle = validState.angle;\n\n      // Emitting\n      if (!this.hasState(this.previousState)) this.emit(\"updated\", this.getState());\n      return this;\n    }\n\n    /**\n     * Method used to update the camera's state using a function.\n     */\n  }, {\n    key: \"updateState\",\n    value: function updateState(updater) {\n      this.setState(updater(this.getState()));\n      return this;\n    }\n\n    /**\n     * Method used to animate the camera.\n     */\n  }, {\n    key: \"animate\",\n    value: function animate(state) {\n      var _this2 = this;\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var callback = arguments.length > 2 ? arguments[2] : undefined;\n      if (!callback) return new Promise(function (resolve) {\n        return _this2.animate(state, opts, resolve);\n      });\n      if (!this.enabled) return;\n      var options = _objectSpread2(_objectSpread2({}, ANIMATE_DEFAULTS), opts);\n      var validState = this.validateState(state);\n      var easing = typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n\n      // State\n      var start = Date.now(),\n        initialState = this.getState();\n\n      // Function performing the animation\n      var _fn = function fn() {\n        var t = (Date.now() - start) / options.duration;\n\n        // The animation is over:\n        if (t >= 1) {\n          _this2.nextFrame = null;\n          _this2.setState(validState);\n          if (_this2.animationCallback) {\n            _this2.animationCallback.call(null);\n            _this2.animationCallback = undefined;\n          }\n          return;\n        }\n        var coefficient = easing(t);\n        var newState = {};\n        if (typeof validState.x === \"number\") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n        if (typeof validState.y === \"number\") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n        if (_this2.enabledRotation && typeof validState.angle === \"number\") newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n        if (typeof validState.ratio === \"number\") newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n        _this2.setState(newState);\n        _this2.nextFrame = requestAnimationFrame(_fn);\n      };\n      if (this.nextFrame) {\n        cancelAnimationFrame(this.nextFrame);\n        if (this.animationCallback) this.animationCallback.call(null);\n        this.nextFrame = requestAnimationFrame(_fn);\n      } else {\n        _fn();\n      }\n      this.animationCallback = callback;\n    }\n\n    /**\n     * Method used to zoom the camera.\n     */\n  }, {\n    key: \"animatedZoom\",\n    value: function animatedZoom(factorOrOptions) {\n      if (!factorOrOptions) return this.animate({\n        ratio: this.ratio / DEFAULT_ZOOMING_RATIO\n      });\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio / factorOrOptions\n      });\n      return this.animate({\n        ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n\n    /**\n     * Method used to unzoom the camera.\n     */\n  }, {\n    key: \"animatedUnzoom\",\n    value: function animatedUnzoom(factorOrOptions) {\n      if (!factorOrOptions) return this.animate({\n        ratio: this.ratio * DEFAULT_ZOOMING_RATIO\n      });\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio * factorOrOptions\n      });\n      return this.animate({\n        ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n\n    /**\n     * Method used to reset the camera.\n     */\n  }, {\n    key: \"animatedReset\",\n    value: function animatedReset(options) {\n      return this.animate({\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0\n      }, options);\n    }\n\n    /**\n     * Returns a new Camera instance, with the same state as the current camera.\n     */\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return Camera.from(this.getState());\n    }\n  }], [{\n    key: \"from\",\n    value: function from(state) {\n      var camera = new Camera();\n      return camera.setState(state);\n    }\n  }]);\n}(TypedEventEmitter);\n\n/**\n * Captor utils functions\n * ======================\n */\n\n/**\n * Extract the local X and Y coordinates from a mouse event or touch object. If\n * a DOM element is given, it uses this element's offset to compute the position\n * (this allows using events that are not bound to the container itself and\n * still have a proper position).\n *\n * @param  {event}       e - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {number}      The local Y value of the mouse.\n */\nfunction getPosition(e, dom) {\n  var bbox = dom.getBoundingClientRect();\n  return {\n    x: e.clientX - bbox.left,\n    y: e.clientY - bbox.top\n  };\n}\n\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}       e   - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getMouseCoords(e, dom) {\n  var res = _objectSpread2(_objectSpread2({}, getPosition(e, dom)), {}, {\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault: function preventSigmaDefault() {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e\n  });\n  return res;\n}\n\n/**\n * Takes a touch coords or a mouse coords, and always returns a clean mouse coords object.\n */\nfunction cleanMouseCoords(e) {\n  var res = \"x\" in e ? e : _objectSpread2(_objectSpread2({}, e.touches[0] || e.previousTouches[0]), {}, {\n    original: e.original,\n    sigmaDefaultPrevented: e.sigmaDefaultPrevented,\n    preventSigmaDefault: function preventSigmaDefault() {\n      e.sigmaDefaultPrevented = true;\n      res.sigmaDefaultPrevented = true;\n    }\n  });\n  return res;\n}\n\n/**\n * Convert mouse wheel event coords to sigma coords.\n *\n * @param  {event}       e   - A wheel mouse event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getWheelCoords(e, dom) {\n  return _objectSpread2(_objectSpread2({}, getMouseCoords(e, dom)), {}, {\n    delta: getWheelDelta(e)\n  });\n}\nvar MAX_TOUCHES = 2;\nfunction getTouchesArray(touches) {\n  var arr = [];\n  for (var i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);\n  return arr;\n}\n\n/**\n * Convert touch coords to sigma coords.\n *\n * @param  {event}       e               - A touch event.\n * @param  {Touch[]}     previousTouches - An array of the previously stored touches.\n * @param  {HTMLElement} dom             - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getTouchCoords(e, previousTouches, dom) {\n  var res = {\n    touches: getTouchesArray(e.touches).map(function (touch) {\n      return getPosition(touch, dom);\n    }),\n    previousTouches: previousTouches.map(function (touch) {\n      return getPosition(touch, dom);\n    }),\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault: function preventSigmaDefault() {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e\n  };\n  return res;\n}\n\n/**\n * Extract the wheel delta from a mouse event or touch object.\n *\n * @param  {event}  e - A mouse event or touch object.\n * @return {number}     The wheel delta of the mouse.\n */\nfunction getWheelDelta(e) {\n  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat\n  if (typeof e.deltaY !== \"undefined\") return e.deltaY * -3 / 360;\n  if (typeof e.detail !== \"undefined\") return e.detail / -9;\n  throw new Error(\"Captor: could not extract delta from event.\");\n}\n\n/**\n * Abstract class representing a captor like the user's mouse or touch controls.\n */\nvar Captor = /*#__PURE__*/function (_TypedEventEmitter) {\n  function Captor(container, renderer) {\n    var _this;\n    _classCallCheck(this, Captor);\n    _this = _callSuper(this, Captor);\n    // Properties\n    _this.container = container;\n    _this.renderer = renderer;\n    return _this;\n  }\n  _inherits(Captor, _TypedEventEmitter);\n  return _createClass(Captor);\n}(TypedEventEmitter);\nvar MOUSE_SETTINGS_KEYS = [\"doubleClickTimeout\", \"doubleClickZoomingDuration\", \"doubleClickZoomingRatio\", \"dragTimeout\", \"draggedEventsTolerance\", \"inertiaDuration\", \"inertiaRatio\", \"zoomDuration\", \"zoomingRatio\"];\nvar DEFAULT_MOUSE_SETTINGS = MOUSE_SETTINGS_KEYS.reduce(function (iter, key) {\n  return _objectSpread2(_objectSpread2({}, iter), {}, _defineProperty({}, key, DEFAULT_SETTINGS[key]));\n}, {});\n\n/**\n * Event types.\n */\n/**\n * Mouse captor class.\n *\n * @constructor\n */\nvar MouseCaptor = /*#__PURE__*/function (_Captor) {\n  function MouseCaptor(container, renderer) {\n    var _this;\n    _classCallCheck(this, MouseCaptor);\n    _this = _callSuper(this, MouseCaptor, [container, renderer]);\n\n    // Binding methods\n    // State\n    _defineProperty(_this, \"enabled\", true);\n    _defineProperty(_this, \"draggedEvents\", 0);\n    _defineProperty(_this, \"downStartTime\", null);\n    _defineProperty(_this, \"lastMouseX\", null);\n    _defineProperty(_this, \"lastMouseY\", null);\n    _defineProperty(_this, \"isMouseDown\", false);\n    _defineProperty(_this, \"isMoving\", false);\n    _defineProperty(_this, \"movingTimeout\", null);\n    _defineProperty(_this, \"startCameraState\", null);\n    _defineProperty(_this, \"clicks\", 0);\n    _defineProperty(_this, \"doubleClickTimeout\", null);\n    _defineProperty(_this, \"currentWheelDirection\", 0);\n    _defineProperty(_this, \"settings\", DEFAULT_MOUSE_SETTINGS);\n    _this.handleClick = _this.handleClick.bind(_this);\n    _this.handleRightClick = _this.handleRightClick.bind(_this);\n    _this.handleDown = _this.handleDown.bind(_this);\n    _this.handleUp = _this.handleUp.bind(_this);\n    _this.handleMove = _this.handleMove.bind(_this);\n    _this.handleWheel = _this.handleWheel.bind(_this);\n    _this.handleLeave = _this.handleLeave.bind(_this);\n    _this.handleEnter = _this.handleEnter.bind(_this);\n\n    // Binding events\n    container.addEventListener(\"click\", _this.handleClick, {\n      capture: false\n    });\n    container.addEventListener(\"contextmenu\", _this.handleRightClick, {\n      capture: false\n    });\n    container.addEventListener(\"mousedown\", _this.handleDown, {\n      capture: false\n    });\n    container.addEventListener(\"wheel\", _this.handleWheel, {\n      capture: false\n    });\n    container.addEventListener(\"mouseleave\", _this.handleLeave, {\n      capture: false\n    });\n    container.addEventListener(\"mouseenter\", _this.handleEnter, {\n      capture: false\n    });\n    document.addEventListener(\"mousemove\", _this.handleMove, {\n      capture: false\n    });\n    document.addEventListener(\"mouseup\", _this.handleUp, {\n      capture: false\n    });\n    return _this;\n  }\n  _inherits(MouseCaptor, _Captor);\n  return _createClass(MouseCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"click\", this.handleClick);\n      container.removeEventListener(\"contextmenu\", this.handleRightClick);\n      container.removeEventListener(\"mousedown\", this.handleDown);\n      container.removeEventListener(\"wheel\", this.handleWheel);\n      container.removeEventListener(\"mouseleave\", this.handleLeave);\n      container.removeEventListener(\"mouseenter\", this.handleEnter);\n      document.removeEventListener(\"mousemove\", this.handleMove);\n      document.removeEventListener(\"mouseup\", this.handleUp);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      this.clicks++;\n      if (this.clicks === 2) {\n        this.clicks = 0;\n        if (typeof this.doubleClickTimeout === \"number\") {\n          clearTimeout(this.doubleClickTimeout);\n          this.doubleClickTimeout = null;\n        }\n        return this.handleDoubleClick(e);\n      }\n      setTimeout(function () {\n        _this2.clicks = 0;\n        _this2.doubleClickTimeout = null;\n      }, this.settings.doubleClickTimeout);\n\n      // NOTE: this is here to prevent click events on drag\n      if (this.draggedEvents < this.settings.draggedEventsTolerance) this.emit(\"click\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleRightClick\",\n    value: function handleRightClick(e) {\n      if (!this.enabled) return;\n      this.emit(\"rightClick\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleDoubleClick\",\n    value: function handleDoubleClick(e) {\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var mouseCoords = getMouseCoords(e, this.container);\n      this.emit(\"doubleClick\", mouseCoords);\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // default behavior\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio / this.settings.doubleClickZoomingRatio);\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticInOut\",\n        duration: this.settings.doubleClickZoomingDuration\n      });\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(e) {\n      if (!this.enabled) return;\n\n      // We only start dragging on left button\n      if (e.button === 0) {\n        this.startCameraState = this.renderer.getCamera().getState();\n        var _getPosition = getPosition(e, this.container),\n          x = _getPosition.x,\n          y = _getPosition.y;\n        this.lastMouseX = x;\n        this.lastMouseY = y;\n        this.draggedEvents = 0;\n        this.downStartTime = Date.now();\n        this.isMouseDown = true;\n      }\n      this.emit(\"mousedown\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleUp\",\n    value: function handleUp(e) {\n      var _this3 = this;\n      if (!this.enabled || !this.isMouseDown) return;\n      var camera = this.renderer.getCamera();\n      this.isMouseDown = false;\n      if (typeof this.movingTimeout === \"number\") {\n        clearTimeout(this.movingTimeout);\n        this.movingTimeout = null;\n      }\n      var _getPosition2 = getPosition(e, this.container),\n        x = _getPosition2.x,\n        y = _getPosition2.y;\n      var cameraState = camera.getState(),\n        previousCameraState = camera.getPreviousState() || {\n          x: 0,\n          y: 0\n        };\n      if (this.isMoving) {\n        camera.animate({\n          x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)\n        }, {\n          duration: this.settings.inertiaDuration,\n          easing: \"quadraticOut\"\n        });\n      } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n        camera.setState({\n          x: cameraState.x,\n          y: cameraState.y\n        });\n      }\n      this.isMoving = false;\n      setTimeout(function () {\n        var shouldRefresh = _this3.draggedEvents > 0;\n        _this3.draggedEvents = 0;\n\n        // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work\n        // when someone releases camera pan drag after having stopped moving.\n        // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2\n        // See also issue: https://github.com/jacomyal/sigma.js/issues/1290\n        // It could be possible to render instead of scheduling a refresh but for\n        // now it seems good enough.\n        if (shouldRefresh && _this3.renderer.getSetting(\"hideEdgesOnMove\")) _this3.renderer.refresh();\n      }, 0);\n      this.emit(\"mouseup\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this4 = this;\n      if (!this.enabled) return;\n      var mouseCoords = getMouseCoords(e, this.container);\n\n      // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n      // a drag-and-drop effect that works even when the mouse is out of the\n      // container:\n      this.emit(\"mousemovebody\", mouseCoords);\n\n      // Only trigger the \"mousemove\" event when the mouse is actually hovering\n      // the container, to avoid weirdly hovering nodes and/or edges when the\n      // mouse is not hover the container:\n      if (e.target === this.container || e.composedPath()[0] === this.container) {\n        this.emit(\"mousemove\", mouseCoords);\n      }\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n      // stage while the mouse is not hover the container:\n      if (this.isMouseDown) {\n        this.isMoving = true;\n        this.draggedEvents++;\n        if (typeof this.movingTimeout === \"number\") {\n          clearTimeout(this.movingTimeout);\n        }\n        this.movingTimeout = window.setTimeout(function () {\n          _this4.movingTimeout = null;\n          _this4.isMoving = false;\n        }, this.settings.dragTimeout);\n        var camera = this.renderer.getCamera();\n        var _getPosition3 = getPosition(e, this.container),\n          eX = _getPosition3.x,\n          eY = _getPosition3.y;\n        var lastMouse = this.renderer.viewportToFramedGraph({\n          x: this.lastMouseX,\n          y: this.lastMouseY\n        });\n        var mouse = this.renderer.viewportToFramedGraph({\n          x: eX,\n          y: eY\n        });\n        var offsetX = lastMouse.x - mouse.x,\n          offsetY = lastMouse.y - mouse.y;\n        var cameraState = camera.getState();\n        var x = cameraState.x + offsetX,\n          y = cameraState.y + offsetY;\n        camera.setState({\n          x: x,\n          y: y\n        });\n        this.lastMouseX = eX;\n        this.lastMouseY = eY;\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      this.emit(\"mouseleave\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleEnter\",\n    value: function handleEnter(e) {\n      this.emit(\"mouseenter\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(e) {\n      var _this5 = this;\n      var camera = this.renderer.getCamera();\n      if (!this.enabled || !camera.enabledZooming) return;\n      var delta = getWheelDelta(e);\n      if (!delta) return;\n      var wheelCoords = getWheelCoords(e, this.container);\n      this.emit(\"wheel\", wheelCoords);\n      if (wheelCoords.sigmaDefaultPrevented) {\n        e.preventDefault();\n        e.stopPropagation();\n        return;\n      }\n\n      // Default behavior\n      var currentRatio = camera.getState().ratio;\n      var ratioDiff = delta > 0 ? 1 / this.settings.zoomingRatio : this.settings.zoomingRatio;\n      var newRatio = camera.getBoundedRatio(currentRatio * ratioDiff);\n      var wheelDirection = delta > 0 ? 1 : -1;\n      var now = Date.now();\n\n      // Exit early without preventing default behavior when ratio doesn't change:\n      if (currentRatio === newRatio) return;\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Cancel events that are too close each other and in the same direction:\n      if (this.currentWheelDirection === wheelDirection && this.lastWheelTriggerTime && now - this.lastWheelTriggerTime < this.settings.zoomDuration / 5) {\n        return;\n      }\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticOut\",\n        duration: this.settings.zoomDuration\n      }, function () {\n        _this5.currentWheelDirection = 0;\n      });\n      this.currentWheelDirection = wheelDirection;\n      this.lastWheelTriggerTime = now;\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      this.settings = settings;\n    }\n  }]);\n}(Captor);\nvar TOUCH_SETTINGS_KEYS = [\"dragTimeout\", \"inertiaDuration\", \"inertiaRatio\", \"doubleClickTimeout\", \"doubleClickZoomingRatio\", \"doubleClickZoomingDuration\", \"tapMoveTolerance\"];\nvar DEFAULT_TOUCH_SETTINGS = TOUCH_SETTINGS_KEYS.reduce(function (iter, key) {\n  return _objectSpread2(_objectSpread2({}, iter), {}, _defineProperty({}, key, DEFAULT_SETTINGS[key]));\n}, {});\n\n/**\n * Event types.\n */\n/**\n * Touch captor class.\n *\n * @constructor\n */\nvar TouchCaptor = /*#__PURE__*/function (_Captor) {\n  function TouchCaptor(container, renderer) {\n    var _this;\n    _classCallCheck(this, TouchCaptor);\n    _this = _callSuper(this, TouchCaptor, [container, renderer]);\n\n    // Binding methods:\n    _defineProperty(_this, \"enabled\", true);\n    _defineProperty(_this, \"isMoving\", false);\n    _defineProperty(_this, \"hasMoved\", false);\n    _defineProperty(_this, \"touchMode\", 0);\n    _defineProperty(_this, \"startTouchesPositions\", []);\n    _defineProperty(_this, \"lastTouches\", []);\n    _defineProperty(_this, \"lastTap\", null);\n    _defineProperty(_this, \"settings\", DEFAULT_TOUCH_SETTINGS);\n    _this.handleStart = _this.handleStart.bind(_this);\n    _this.handleLeave = _this.handleLeave.bind(_this);\n    _this.handleMove = _this.handleMove.bind(_this);\n\n    // Binding events\n    container.addEventListener(\"touchstart\", _this.handleStart, {\n      capture: false\n    });\n    container.addEventListener(\"touchcancel\", _this.handleLeave, {\n      capture: false\n    });\n    document.addEventListener(\"touchend\", _this.handleLeave, {\n      capture: false,\n      passive: false\n    });\n    document.addEventListener(\"touchmove\", _this.handleMove, {\n      capture: false,\n      passive: false\n    });\n    return _this;\n  }\n  _inherits(TouchCaptor, _Captor);\n  return _createClass(TouchCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"touchstart\", this.handleStart);\n      container.removeEventListener(\"touchcancel\", this.handleLeave);\n      document.removeEventListener(\"touchend\", this.handleLeave);\n      document.removeEventListener(\"touchmove\", this.handleMove);\n    }\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.container.offsetWidth,\n        height: this.container.offsetHeight\n      };\n    }\n  }, {\n    key: \"handleStart\",\n    value: function handleStart(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      e.preventDefault();\n      var touches = getTouchesArray(e.touches);\n      this.touchMode = touches.length;\n      this.startCameraState = this.renderer.getCamera().getState();\n      this.startTouchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this2.container);\n      });\n\n      // When there are two touches down, let's record distance and angle as well:\n      if (this.touchMode === 2) {\n        var _this$startTouchesPos = _slicedToArray(this.startTouchesPositions, 2),\n          _this$startTouchesPos2 = _this$startTouchesPos[0],\n          x0 = _this$startTouchesPos2.x,\n          y0 = _this$startTouchesPos2.y,\n          _this$startTouchesPos3 = _this$startTouchesPos[1],\n          x1 = _this$startTouchesPos3.x,\n          y1 = _this$startTouchesPos3.y;\n        this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);\n        this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n      }\n      this.emit(\"touchdown\", getTouchCoords(e, this.lastTouches, this.container));\n      this.lastTouches = touches;\n      this.lastTouchesPositions = this.startTouchesPositions;\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      if (!this.enabled || !this.startTouchesPositions.length) return;\n      if (e.cancelable) e.preventDefault();\n      if (this.movingTimeout) {\n        this.isMoving = false;\n        clearTimeout(this.movingTimeout);\n      }\n      switch (this.touchMode) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        case 2:\n          if (e.touches.length === 1) {\n            this.handleStart(e);\n            e.preventDefault();\n            break;\n          }\n        /* falls through */\n        case 1:\n          if (this.isMoving) {\n            var camera = this.renderer.getCamera();\n            var cameraState = camera.getState(),\n              previousCameraState = camera.getPreviousState() || {\n                x: 0,\n                y: 0\n              };\n            camera.animate({\n              x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n              y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)\n            }, {\n              duration: this.settings.inertiaDuration,\n              easing: \"quadraticOut\"\n            });\n          }\n          this.hasMoved = false;\n          this.isMoving = false;\n          this.touchMode = 0;\n          break;\n      }\n      this.emit(\"touchup\", getTouchCoords(e, this.lastTouches, this.container));\n\n      // When the last touch ends and there hasn't been too much movement, trigger a \"tap\" or \"doubletap\" event:\n      if (!e.touches.length) {\n        var position = getPosition(this.lastTouches[0], this.container);\n        var downPosition = this.startTouchesPositions[0];\n        var dSquare = Math.pow(position.x - downPosition.x, 2) + Math.pow(position.y - downPosition.y, 2);\n        if (!e.touches.length && dSquare < Math.pow(this.settings.tapMoveTolerance, 2)) {\n          // Only trigger \"doubletap\" when the last tap is recent enough:\n          if (this.lastTap && Date.now() - this.lastTap.time < this.settings.doubleClickTimeout) {\n            var touchCoords = getTouchCoords(e, this.lastTouches, this.container);\n            this.emit(\"doubletap\", touchCoords);\n            this.lastTap = null;\n            if (!touchCoords.sigmaDefaultPrevented) {\n              var _camera = this.renderer.getCamera();\n              var newRatio = _camera.getBoundedRatio(_camera.getState().ratio / this.settings.doubleClickZoomingRatio);\n              _camera.animate(this.renderer.getViewportZoomedState(position, newRatio), {\n                easing: \"quadraticInOut\",\n                duration: this.settings.doubleClickZoomingDuration\n              });\n            }\n          }\n          // Else, trigger a normal \"tap\" event:\n          else {\n            var _touchCoords = getTouchCoords(e, this.lastTouches, this.container);\n            this.emit(\"tap\", _touchCoords);\n            this.lastTap = {\n              time: Date.now(),\n              position: _touchCoords.touches[0] || _touchCoords.previousTouches[0]\n            };\n          }\n        }\n      }\n      this.lastTouches = getTouchesArray(e.touches);\n      this.startTouchesPositions = [];\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this3 = this;\n      if (!this.enabled || !this.startTouchesPositions.length) return;\n      e.preventDefault();\n      var touches = getTouchesArray(e.touches);\n      var touchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this3.container);\n      });\n      var lastTouches = this.lastTouches;\n      this.lastTouches = touches;\n      this.lastTouchesPositions = touchesPositions;\n      var touchCoords = getTouchCoords(e, lastTouches, this.container);\n      this.emit(\"touchmove\", touchCoords);\n      if (touchCoords.sigmaDefaultPrevented) return;\n\n      // If a move was initiated at some point, and we get back to start point,\n      // we should still consider that we did move (which also happens after a\n      // multiple touch when only one touch remains in which case handleStart\n      // is recalled within handleLeave).\n      // Now, some mobile browsers report zero-distance moves so we also check that\n      // one of the touches did actually move from the origin position.\n      this.hasMoved || (this.hasMoved = touchesPositions.some(function (position, idx) {\n        var startPosition = _this3.startTouchesPositions[idx];\n        return startPosition && (position.x !== startPosition.x || position.y !== startPosition.y);\n      }));\n\n      // If there was no move, do not trigger touch moves behavior\n      if (!this.hasMoved) {\n        return;\n      }\n      this.isMoving = true;\n      if (this.movingTimeout) clearTimeout(this.movingTimeout);\n      this.movingTimeout = window.setTimeout(function () {\n        _this3.isMoving = false;\n      }, this.settings.dragTimeout);\n      var camera = this.renderer.getCamera();\n      var startCameraState = this.startCameraState;\n      var padding = this.renderer.getSetting(\"stagePadding\");\n      switch (this.touchMode) {\n        case 1:\n          {\n            var _this$renderer$viewpo = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]),\n              xStart = _this$renderer$viewpo.x,\n              yStart = _this$renderer$viewpo.y;\n            var _this$renderer$viewpo2 = this.renderer.viewportToFramedGraph(touchesPositions[0]),\n              x = _this$renderer$viewpo2.x,\n              y = _this$renderer$viewpo2.y;\n            camera.setState({\n              x: startCameraState.x + xStart - x,\n              y: startCameraState.y + yStart - y\n            });\n            break;\n          }\n        case 2:\n          {\n            /**\n             * Here is the thinking here:\n             *\n             * 1. We can find the new angle and ratio, by comparing the vector from \"touch one\" to \"touch two\" at the start\n             *    of the d'n'd and now\n             *\n             * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph\n             *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport\n             *    position of this same touch now\n             */\n            var newCameraState = {\n              x: 0.5,\n              y: 0.5,\n              angle: 0,\n              ratio: 1\n            };\n            var _touchesPositions$ = touchesPositions[0],\n              x0 = _touchesPositions$.x,\n              y0 = _touchesPositions$.y;\n            var _touchesPositions$2 = touchesPositions[1],\n              x1 = _touchesPositions$2.x,\n              y1 = _touchesPositions$2.y;\n            var angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;\n            var ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;\n\n            // 1.\n            var newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);\n            newCameraState.ratio = newRatio;\n            newCameraState.angle = startCameraState.angle + angleDiff;\n\n            // 2.\n            var dimensions = this.getDimensions();\n            var touchGraphPosition = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], {\n              cameraState: startCameraState\n            });\n            var smallestDimension = Math.min(dimensions.width, dimensions.height) - 2 * padding;\n            var dx = smallestDimension / dimensions.width;\n            var dy = smallestDimension / dimensions.height;\n            var ratio = newRatio / smallestDimension;\n\n            // Align with center of the graph:\n            var _x = x0 - smallestDimension / 2 / dx;\n            var _y = y0 - smallestDimension / 2 / dy;\n\n            // Rotate:\n            var _ref = [_x * Math.cos(-newCameraState.angle) - _y * Math.sin(-newCameraState.angle), _y * Math.cos(-newCameraState.angle) + _x * Math.sin(-newCameraState.angle)];\n            _x = _ref[0];\n            _y = _ref[1];\n            newCameraState.x = touchGraphPosition.x - _x * ratio;\n            newCameraState.y = touchGraphPosition.y + _y * ratio;\n            camera.setState(newCameraState);\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      this.settings = settings;\n    }\n  }]);\n}(Captor);\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\n/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscellaneous heuristics related to label display.\n * @module\n */\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /*#__PURE__*/function () {\n  function LabelCandidate(key, size) {\n    _classCallCheck(this, LabelCandidate);\n    this.key = key;\n    this.size = size;\n  }\n  return _createClass(LabelCandidate, null, [{\n    key: \"compare\",\n    value: function compare(first, second) {\n      // First we compare by size\n      if (first.size > second.size) return -1;\n      if (first.size < second.size) return 1;\n\n      // Then since no two nodes can have the same key, we use it to\n      // deterministically tie-break by key\n      if (first.key > second.key) return 1;\n\n      // NOTE: this comparator cannot return 0\n      return -1;\n    }\n  }]);\n}();\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /*#__PURE__*/function () {\n  function LabelGrid() {\n    _classCallCheck(this, LabelGrid);\n    _defineProperty(this, \"width\", 0);\n    _defineProperty(this, \"height\", 0);\n    _defineProperty(this, \"cellSize\", 0);\n    _defineProperty(this, \"columns\", 0);\n    _defineProperty(this, \"rows\", 0);\n    _defineProperty(this, \"cells\", {});\n  }\n  return _createClass(LabelGrid, [{\n    key: \"resizeAndClear\",\n    value: function resizeAndClear(dimensions, cellSize) {\n      this.width = dimensions.width;\n      this.height = dimensions.height;\n      this.cellSize = cellSize;\n      this.columns = Math.ceil(dimensions.width / cellSize);\n      this.rows = Math.ceil(dimensions.height / cellSize);\n      this.cells = {};\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(pos) {\n      var xIndex = Math.floor(pos.x / this.cellSize);\n      var yIndex = Math.floor(pos.y / this.cellSize);\n      return yIndex * this.columns + xIndex;\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, size, pos) {\n      var candidate = new LabelCandidate(key, size);\n      var index = this.getIndex(pos);\n      var cell = this.cells[index];\n      if (!cell) {\n        cell = [];\n        this.cells[index] = cell;\n      }\n      cell.push(candidate);\n    }\n  }, {\n    key: \"organize\",\n    value: function organize() {\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        cell.sort(LabelCandidate.compare);\n      }\n    }\n  }, {\n    key: \"getLabelsToDisplay\",\n    value: function getLabelsToDisplay(ratio, density) {\n      // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n      // TODO: adjust threshold lower, but increase cells a bit?\n      // TODO: hunt for geom issue in disguise\n      // TODO: memoize while ratio does not move. method to force recompute\n      var cellArea = this.cellSize * this.cellSize;\n      var scaledCellArea = cellArea / ratio / ratio;\n      var scaledDensity = scaledCellArea * density / cellArea;\n      var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n      var labels = [];\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n          labels.push(cell[i].key);\n        }\n      }\n      return labels;\n    }\n  }]);\n}();\n\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n  var graph = params.graph,\n    hoveredNode = params.hoveredNode,\n    highlightedNodes = params.highlightedNodes,\n    displayedNodeLabels = params.displayedNodeLabels;\n  var worthyEdges = [];\n\n  // TODO: the code below can be optimized using #.forEach and batching the code per adj\n\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n  graph.forEachEdge(function (edge, _, source, target) {\n    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {\n      worthyEdges.push(edge);\n    }\n  });\n  return worthyEdges;\n}\n\n/**\n * Constants.\n */\nvar X_LABEL_MARGIN = 150;\nvar Y_LABEL_MARGIN = 50;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n  if (!hasOwnProperty.call(data, \"x\") || !hasOwnProperty.call(data, \"y\")) throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n  if (!data.color) data.color = settings.defaultNodeColor;\n  if (!data.label && data.label !== \"\") data.label = null;\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;else data.label = null;\n  if (!data.size) data.size = 2;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"highlighted\")) data.highlighted = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\nfunction applyEdgeDefaults(settings, _key, data) {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n  if (!data.label) data.label = \"\";\n  if (!data.size) data.size = 0.5;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma$1 = /*#__PURE__*/function (_TypedEventEmitter) {\n  function Sigma(graph, container) {\n    var _this;\n    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, Sigma);\n    _this = _callSuper(this, Sigma);\n\n    // Resolving settings\n    _defineProperty(_this, \"elements\", {});\n    _defineProperty(_this, \"canvasContexts\", {});\n    _defineProperty(_this, \"webGLContexts\", {});\n    _defineProperty(_this, \"pickingLayers\", new Set());\n    _defineProperty(_this, \"textures\", {});\n    _defineProperty(_this, \"frameBuffers\", {});\n    _defineProperty(_this, \"activeListeners\", {});\n    _defineProperty(_this, \"labelGrid\", new LabelGrid());\n    _defineProperty(_this, \"nodeDataCache\", {});\n    _defineProperty(_this, \"edgeDataCache\", {});\n    // Indices to keep track of the index of the item inside programs\n    _defineProperty(_this, \"nodeProgramIndex\", {});\n    _defineProperty(_this, \"edgeProgramIndex\", {});\n    _defineProperty(_this, \"nodesWithForcedLabels\", new Set());\n    _defineProperty(_this, \"edgesWithForcedLabels\", new Set());\n    _defineProperty(_this, \"nodeExtent\", {\n      x: [0, 1],\n      y: [0, 1]\n    });\n    _defineProperty(_this, \"nodeZExtent\", [Infinity, -Infinity]);\n    _defineProperty(_this, \"edgeZExtent\", [Infinity, -Infinity]);\n    _defineProperty(_this, \"matrix\", identity());\n    _defineProperty(_this, \"invMatrix\", identity());\n    _defineProperty(_this, \"correctionRatio\", 1);\n    _defineProperty(_this, \"customBBox\", null);\n    _defineProperty(_this, \"normalizationFunction\", createNormalizationFunction({\n      x: [0, 1],\n      y: [0, 1]\n    }));\n    // Cache:\n    _defineProperty(_this, \"graphToViewportRatio\", 1);\n    _defineProperty(_this, \"itemIDsIndex\", {});\n    _defineProperty(_this, \"nodeIndices\", {});\n    _defineProperty(_this, \"edgeIndices\", {});\n    // Starting dimensions and pixel ratio\n    _defineProperty(_this, \"width\", 0);\n    _defineProperty(_this, \"height\", 0);\n    _defineProperty(_this, \"pixelRatio\", getPixelRatio());\n    _defineProperty(_this, \"pickingDownSizingRatio\", 2 * _this.pixelRatio);\n    // Graph State\n    _defineProperty(_this, \"displayedNodeLabels\", new Set());\n    _defineProperty(_this, \"displayedEdgeLabels\", new Set());\n    _defineProperty(_this, \"highlightedNodes\", new Set());\n    _defineProperty(_this, \"hoveredNode\", null);\n    _defineProperty(_this, \"hoveredEdge\", null);\n    // Internal states\n    _defineProperty(_this, \"renderFrame\", null);\n    _defineProperty(_this, \"renderHighlightedNodesFrame\", null);\n    _defineProperty(_this, \"needToProcess\", false);\n    _defineProperty(_this, \"checkEdgesEventsFrame\", null);\n    // Programs\n    _defineProperty(_this, \"nodePrograms\", {});\n    _defineProperty(_this, \"nodeHoverPrograms\", {});\n    _defineProperty(_this, \"edgePrograms\", {});\n    _this.settings = resolveSettings(settings);\n\n    // Validating\n    validateSettings(_this.settings);\n    validateGraph(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n\n    // Properties\n    _this.graph = graph;\n    _this.container = container;\n\n    // Initializing contexts\n    _this.createWebGLContext(\"edges\", {\n      picking: settings.enableEdgeEvents\n    });\n    _this.createCanvasContext(\"edgeLabels\");\n    _this.createWebGLContext(\"nodes\", {\n      picking: true\n    });\n    _this.createCanvasContext(\"labels\");\n    _this.createCanvasContext(\"hovers\");\n    _this.createWebGLContext(\"hoverNodes\");\n    _this.createCanvasContext(\"mouse\", {\n      style: {\n        touchAction: \"none\",\n        userSelect: \"none\"\n      }\n    });\n\n    // Initial resize\n    _this.resize();\n\n    // Loading programs\n    for (var type in _this.settings.nodeProgramClasses) {\n      _this.registerNodeProgram(type, _this.settings.nodeProgramClasses[type], _this.settings.nodeHoverProgramClasses[type]);\n    }\n    for (var _type in _this.settings.edgeProgramClasses) {\n      _this.registerEdgeProgram(_type, _this.settings.edgeProgramClasses[_type]);\n    }\n\n    // Initializing the camera\n    _this.camera = new Camera();\n\n    // Binding camera events\n    _this.bindCameraHandlers();\n\n    // Initializing captors\n    _this.mouseCaptor = new MouseCaptor(_this.elements.mouse, _this);\n    _this.mouseCaptor.setSettings(_this.settings);\n    _this.touchCaptor = new TouchCaptor(_this.elements.mouse, _this);\n    _this.touchCaptor.setSettings(_this.settings);\n\n    // Binding event handlers\n    _this.bindEventHandlers();\n\n    // Binding graph handlers\n    _this.bindGraphHandlers();\n\n    // Trigger eventual settings-related things\n    _this.handleSettingsUpdate();\n\n    // Processing data for the first time & render\n    _this.refresh();\n    return _this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to register a node program\n   *\n   * @param  {string}           key              - The program's key, matching the related nodes \"type\" values.\n   * @param  {NodeProgramType}  NodeProgramClass - A nodes program class.\n   * @param  {NodeProgramType?} NodeHoverProgram - A nodes program class to render hovered nodes (optional).\n   * @return {Sigma}\n   */\n  _inherits(Sigma, _TypedEventEmitter);\n  return _createClass(Sigma, [{\n    key: \"registerNodeProgram\",\n    value: function registerNodeProgram(key, NodeProgramClass, NodeHoverProgram) {\n      if (this.nodePrograms[key]) this.nodePrograms[key].kill();\n      if (this.nodeHoverPrograms[key]) this.nodeHoverPrograms[key].kill();\n      this.nodePrograms[key] = new NodeProgramClass(this.webGLContexts.nodes, this.frameBuffers.nodes, this);\n      this.nodeHoverPrograms[key] = new (NodeHoverProgram || NodeProgramClass)(this.webGLContexts.hoverNodes, null, this);\n      return this;\n    }\n\n    /**\n     * Internal function used to register an edge program\n     *\n     * @param  {string}          key              - The program's key, matching the related edges \"type\" values.\n     * @param  {EdgeProgramType} EdgeProgramClass - An edges program class.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"registerEdgeProgram\",\n    value: function registerEdgeProgram(key, EdgeProgramClass) {\n      if (this.edgePrograms[key]) this.edgePrograms[key].kill();\n      this.edgePrograms[key] = new EdgeProgramClass(this.webGLContexts.edges, this.frameBuffers.edges, this);\n      return this;\n    }\n\n    /**\n     * Internal function used to unregister a node program\n     *\n     * @param  {string} key - The program's key, matching the related nodes \"type\" values.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unregisterNodeProgram\",\n    value: function unregisterNodeProgram(key) {\n      if (this.nodePrograms[key]) {\n        var _this$nodePrograms = this.nodePrograms,\n          program = _this$nodePrograms[key],\n          programs = _objectWithoutProperties(_this$nodePrograms, [key].map(_toPropertyKey));\n        program.kill();\n        this.nodePrograms = programs;\n      }\n      if (this.nodeHoverPrograms[key]) {\n        var _this$nodeHoverProgra = this.nodeHoverPrograms,\n          _program = _this$nodeHoverProgra[key],\n          _programs = _objectWithoutProperties(_this$nodeHoverProgra, [key].map(_toPropertyKey));\n        _program.kill();\n        this.nodePrograms = _programs;\n      }\n      return this;\n    }\n\n    /**\n     * Internal function used to unregister an edge program\n     *\n     * @param  {string} key - The program's key, matching the related edges \"type\" values.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unregisterEdgeProgram\",\n    value: function unregisterEdgeProgram(key) {\n      if (this.edgePrograms[key]) {\n        var _this$edgePrograms = this.edgePrograms,\n          program = _this$edgePrograms[key],\n          programs = _objectWithoutProperties(_this$edgePrograms, [key].map(_toPropertyKey));\n        program.kill();\n        this.edgePrograms = programs;\n      }\n      return this;\n    }\n\n    /**\n     * Method (re)binding WebGL texture (for picking).\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resetWebGLTexture\",\n    value: function resetWebGLTexture(id) {\n      var gl = this.webGLContexts[id];\n      var frameBuffer = this.frameBuffers[id];\n      var currentTexture = this.textures[id];\n      if (currentTexture) gl.deleteTexture(currentTexture);\n      var pickingTexture = gl.createTexture();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.bindTexture(gl.TEXTURE_2D, pickingTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);\n      this.textures[id] = pickingTexture;\n      return this;\n    }\n\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindCameraHandlers\",\n    value: function bindCameraHandlers() {\n      var _this2 = this;\n      this.activeListeners.camera = function () {\n        _this2.scheduleRender();\n      };\n      this.camera.on(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method unbinding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unbindCameraHandlers\",\n    value: function unbindCameraHandlers() {\n      this.camera.removeListener(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method that returns the closest node to a given position.\n     */\n  }, {\n    key: \"getNodeAtPosition\",\n    value: function getNodeAtPosition(position) {\n      var x = position.x,\n        y = position.y;\n      var color = getPixelColor(this.webGLContexts.nodes, this.frameBuffers.nodes, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = colorToIndex.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"node\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method binding event handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindEventHandlers\",\n    value: function bindEventHandlers() {\n      var _this3 = this;\n      // Handling window resize\n      this.activeListeners.handleResize = function () {\n        // need to call a refresh to rebuild the labelgrid\n        _this3.scheduleRefresh();\n      };\n      window.addEventListener(\"resize\", this.activeListeners.handleResize);\n\n      // Handling mouse move\n      this.activeListeners.handleMove = function (e) {\n        var event = cleanMouseCoords(e);\n        var baseEvent = {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        };\n        var nodeToHover = _this3.getNodeAtPosition(event);\n        if (nodeToHover && _this3.hoveredNode !== nodeToHover && !_this3.nodeDataCache[nodeToHover].hidden) {\n          // Handling passing from one node to the other directly\n          if (_this3.hoveredNode) _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.hoveredNode = nodeToHover;\n          _this3.emit(\"enterNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: nodeToHover\n          }));\n          _this3.scheduleHighlightedNodesRender();\n          return;\n        }\n\n        // Checking if the hovered node is still hovered\n        if (_this3.hoveredNode) {\n          if (_this3.getNodeAtPosition(event) !== _this3.hoveredNode) {\n            var node = _this3.hoveredNode;\n            _this3.hoveredNode = null;\n            _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              node: node\n            }));\n            _this3.scheduleHighlightedNodesRender();\n            return;\n          }\n        }\n        if (_this3.settings.enableEdgeEvents) {\n          var edgeToHover = _this3.hoveredNode ? null : _this3.getEdgeAtPoint(baseEvent.event.x, baseEvent.event.y);\n          if (edgeToHover !== _this3.hoveredEdge) {\n            if (_this3.hoveredEdge) _this3.emit(\"leaveEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: _this3.hoveredEdge\n            }));\n            if (edgeToHover) _this3.emit(\"enterEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: edgeToHover\n            }));\n            _this3.hoveredEdge = edgeToHover;\n          }\n        }\n      };\n\n      // Handling mouse move over body (only to dispatch the proper event):\n      this.activeListeners.handleMoveBody = function (e) {\n        var event = cleanMouseCoords(e);\n        _this3.emit(\"moveBody\", {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        });\n      };\n\n      // Handling mouse leave stage:\n      this.activeListeners.handleLeave = function (e) {\n        var event = cleanMouseCoords(e);\n        var baseEvent = {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        };\n        if (_this3.hoveredNode) {\n          _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        if (_this3.settings.enableEdgeEvents && _this3.hoveredEdge) {\n          _this3.emit(\"leaveEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            edge: _this3.hoveredEdge\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        _this3.emit(\"leaveStage\", _objectSpread2({}, baseEvent));\n      };\n\n      // Handling mouse enter stage:\n      this.activeListeners.handleEnter = function (e) {\n        var event = cleanMouseCoords(e);\n        var baseEvent = {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        };\n        _this3.emit(\"enterStage\", _objectSpread2({}, baseEvent));\n      };\n\n      // Handling click\n      var createInteractionListener = function createInteractionListener(eventType) {\n        return function (e) {\n          var event = cleanMouseCoords(e);\n          var baseEvent = {\n            event: event,\n            preventSigmaDefault: function preventSigmaDefault() {\n              event.preventSigmaDefault();\n            }\n          };\n          var nodeAtPosition = _this3.getNodeAtPosition(event);\n          if (nodeAtPosition) return _this3.emit(\"\".concat(eventType, \"Node\"), _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: nodeAtPosition\n          }));\n          if (_this3.settings.enableEdgeEvents) {\n            var edge = _this3.getEdgeAtPoint(event.x, event.y);\n            if (edge) return _this3.emit(\"\".concat(eventType, \"Edge\"), _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: edge\n            }));\n          }\n          return _this3.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n        };\n      };\n      this.activeListeners.handleClick = createInteractionListener(\"click\");\n      this.activeListeners.handleRightClick = createInteractionListener(\"rightClick\");\n      this.activeListeners.handleDoubleClick = createInteractionListener(\"doubleClick\");\n      this.activeListeners.handleWheel = createInteractionListener(\"wheel\");\n      this.activeListeners.handleDown = createInteractionListener(\"down\");\n      this.activeListeners.handleUp = createInteractionListener(\"up\");\n      this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n      this.mouseCaptor.on(\"mousemovebody\", this.activeListeners.handleMoveBody);\n      this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n      this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n      this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n      this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n      this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n      this.mouseCaptor.on(\"mouseup\", this.activeListeners.handleUp);\n      this.mouseCaptor.on(\"mouseleave\", this.activeListeners.handleLeave);\n      this.mouseCaptor.on(\"mouseenter\", this.activeListeners.handleEnter);\n      this.touchCaptor.on(\"touchdown\", this.activeListeners.handleDown);\n      this.touchCaptor.on(\"touchdown\", this.activeListeners.handleMove);\n      this.touchCaptor.on(\"touchup\", this.activeListeners.handleUp);\n      this.touchCaptor.on(\"touchmove\", this.activeListeners.handleMove);\n      this.touchCaptor.on(\"tap\", this.activeListeners.handleClick);\n      this.touchCaptor.on(\"doubletap\", this.activeListeners.handleDoubleClick);\n      this.touchCaptor.on(\"touchmove\", this.activeListeners.handleMoveBody);\n      return this;\n    }\n\n    /**\n     * Method binding graph handlers\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindGraphHandlers\",\n    value: function bindGraphHandlers() {\n      var _this4 = this;\n      var graph = this.graph;\n      var LAYOUT_IMPACTING_FIELDS = new Set([\"x\", \"y\", \"zIndex\", \"type\"]);\n      this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints;\n        var updatedFields = (_e$hints = e.hints) === null || _e$hints === void 0 ? void 0 : _e$hints.attributes;\n        // we process all nodes\n        _this4.graph.forEachNode(function (node) {\n          return _this4.updateNode(node);\n        });\n\n        // if coord, type or zIndex have changed, we need to schedule a render\n        // (zIndex for the programIndex)\n        var layoutChanged = !updatedFields || updatedFields.some(function (f) {\n          return LAYOUT_IMPACTING_FIELDS.has(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            nodes: graph.nodes()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n      this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints2;\n        var updatedFields = (_e$hints2 = e.hints) === null || _e$hints2 === void 0 ? void 0 : _e$hints2.attributes;\n        // we process all edges\n        _this4.graph.forEachEdge(function (edge) {\n          return _this4.updateEdge(edge);\n        });\n        var layoutChanged = updatedFields && [\"zIndex\", \"type\"].some(function (f) {\n          return updatedFields === null || updatedFields === void 0 ? void 0 : updatedFields.includes(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            edges: graph.edges()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n\n      // On add node, we add the node in indices and then call for a render\n      this.activeListeners.addNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.addNode(node);\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On update node, we update indices and then call for a render\n      this.activeListeners.updateNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop node, we remove the node from indices and then call for a refresh\n      this.activeListeners.dropNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.removeNode(node);\n        // schedule a render for everything\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On add edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.addEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.addEdge(edge);\n        // schedule a render for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          schedule: true\n        });\n      };\n\n      // On update edge, we update indices and then call for a refresh\n      this.activeListeners.updateEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // schedule a repaint for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.dropEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.removeEdge(edge);\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On clear edges, we clear the edge indices and then call for a refresh\n      this.activeListeners.clearEdgesGraphUpdate = function () {\n        // we clear the edge data structures\n        _this4.clearEdgeState();\n        _this4.clearEdgeIndices();\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On graph clear, we clear indices and then call for a refresh\n      this.activeListeners.clearGraphUpdate = function () {\n        // clear graph state\n        _this4.clearEdgeState();\n        _this4.clearNodeState();\n\n        // clear graph indices\n        _this4.clearEdgeIndices();\n        _this4.clearNodeIndices();\n\n        // schedule a render for all\n        _this4.refresh({\n          schedule: true\n        });\n      };\n      graph.on(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.on(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.on(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n      return this;\n    }\n\n    /**\n     * Method used to unbind handlers from the graph.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"unbindGraphHandlers\",\n    value: function unbindGraphHandlers() {\n      var graph = this.graph;\n      graph.removeListener(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n    }\n\n    /**\n     * Method looking for an edge colliding with a given point at (x, y). Returns\n     * the key of the edge if any, or null else.\n     */\n  }, {\n    key: \"getEdgeAtPoint\",\n    value: function getEdgeAtPoint(x, y) {\n      var color = getPixelColor(this.webGLContexts.edges, this.frameBuffers.edges, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = colorToIndex.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"edge\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method used to process the whole graph's data.\n     *  - extent\n     *  - normalizationFunction\n     *  - compute node's coordinate\n     *  - labelgrid\n     *  - program data allocation\n     * @return {Sigma}\n     */\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this5 = this;\n      this.emit(\"beforeProcess\");\n      var graph = this.graph;\n      var settings = this.settings;\n      var dimensions = this.getDimensions();\n\n      //\n      // NODES\n      //\n      this.nodeExtent = graphExtent(this.graph);\n      if (!this.settings.autoRescale) {\n        var width = dimensions.width,\n          height = dimensions.height;\n        var _this$nodeExtent = this.nodeExtent,\n          x = _this$nodeExtent.x,\n          y = _this$nodeExtent.y;\n        this.nodeExtent = {\n          x: [(x[0] + x[1]) / 2 - width / 2, (x[0] + x[1]) / 2 + width / 2],\n          y: [(y[0] + y[1]) / 2 - height / 2, (y[0] + y[1]) / 2 + height / 2]\n        };\n      }\n      this.normalizationFunction = createNormalizationFunction(this.customBBox || this.nodeExtent);\n\n      // NOTE: it is important to compute this matrix after computing the node's extent\n      // because #.getGraphDimensions relies on it\n      var nullCamera = new Camera();\n      var nullCameraMatrix = matrixFromCamera(nullCamera.getState(), dimensions, this.getGraphDimensions(), this.getStagePadding());\n      // Resetting the label grid\n      // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n      this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n      var nodesPerPrograms = {};\n      var nodeIndices = {};\n      var edgeIndices = {};\n      var itemIDsIndex = {};\n      var incrID = 1;\n      var nodes = graph.nodes();\n\n      // Do some indexation on the whole graph\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n        var data = this.nodeDataCache[node];\n\n        // Get initial coordinates\n        var attrs = graph.getNodeAttributes(node);\n        data.x = attrs.x;\n        data.y = attrs.y;\n        this.normalizationFunction.applyTo(data);\n\n        // labelgrid\n        if (typeof data.label === \"string\" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {\n          matrix: nullCameraMatrix\n        }));\n\n        // update count per program\n        nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n      }\n      this.labelGrid.organize();\n\n      // Allocate memory to programs\n      for (var type in this.nodePrograms) {\n        if (!hasOwnProperty.call(this.nodePrograms, type)) {\n          throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n        }\n        this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        nodesPerPrograms[type] = 0;\n      }\n\n      // Order nodes by zIndex before to add them to program\n      if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1]) nodes = zIndexOrdering(this.nodeZExtent, function (node) {\n        return _this5.nodeDataCache[node].zIndex;\n      }, nodes);\n\n      // Add data to programs\n      for (var _i = 0, _l = nodes.length; _i < _l; _i++) {\n        var _node = nodes[_i];\n        nodeIndices[_node] = incrID;\n        itemIDsIndex[nodeIndices[_node]] = {\n          type: \"node\",\n          id: _node\n        };\n        incrID++;\n        var _data = this.nodeDataCache[_node];\n        this.addNodeToProgram(_node, nodeIndices[_node], nodesPerPrograms[_data.type]++);\n      }\n\n      //\n      // EDGES\n      //\n\n      var edgesPerPrograms = {};\n      var edges = graph.edges();\n\n      // Allocate memory to programs\n      for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {\n        var edge = edges[_i2];\n        var _data2 = this.edgeDataCache[edge];\n        edgesPerPrograms[_data2.type] = (edgesPerPrograms[_data2.type] || 0) + 1;\n      }\n\n      // Order edges by zIndex before to add them to program\n      if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1]) edges = zIndexOrdering(this.edgeZExtent, function (edge) {\n        return _this5.edgeDataCache[edge].zIndex;\n      }, edges);\n      for (var _type2 in this.edgePrograms) {\n        if (!hasOwnProperty.call(this.edgePrograms, _type2)) {\n          throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(_type2, \"\\\"!\"));\n        }\n        this.edgePrograms[_type2].reallocate(edgesPerPrograms[_type2] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        edgesPerPrograms[_type2] = 0;\n      }\n\n      // Add data to programs\n      for (var _i3 = 0, _l3 = edges.length; _i3 < _l3; _i3++) {\n        var _edge = edges[_i3];\n        edgeIndices[_edge] = incrID;\n        itemIDsIndex[edgeIndices[_edge]] = {\n          type: \"edge\",\n          id: _edge\n        };\n        incrID++;\n        var _data3 = this.edgeDataCache[_edge];\n        this.addEdgeToProgram(_edge, edgeIndices[_edge], edgesPerPrograms[_data3.type]++);\n      }\n      this.itemIDsIndex = itemIDsIndex;\n      this.nodeIndices = nodeIndices;\n      this.edgeIndices = edgeIndices;\n      this.emit(\"afterProcess\");\n      return this;\n    }\n\n    /**\n     * Method that backports potential settings updates where it's needed.\n     * @private\n     */\n  }, {\n    key: \"handleSettingsUpdate\",\n    value: function handleSettingsUpdate(oldSettings) {\n      var _this6 = this;\n      var settings = this.settings;\n      this.camera.minRatio = settings.minCameraRatio;\n      this.camera.maxRatio = settings.maxCameraRatio;\n      this.camera.enabledZooming = settings.enableCameraZooming;\n      this.camera.enabledPanning = settings.enableCameraPanning;\n      this.camera.enabledRotation = settings.enableCameraRotation;\n      if (settings.cameraPanBoundaries) {\n        this.camera.clean = function (state) {\n          return _this6.cleanCameraState(state, settings.cameraPanBoundaries && _typeof(settings.cameraPanBoundaries) === \"object\" ? settings.cameraPanBoundaries : {});\n        };\n      } else {\n        this.camera.clean = null;\n      }\n      this.camera.setState(this.camera.validateState(this.camera.getState()));\n      if (oldSettings) {\n        // Check edge programs:\n        if (oldSettings.edgeProgramClasses !== settings.edgeProgramClasses) {\n          for (var type in settings.edgeProgramClasses) {\n            if (settings.edgeProgramClasses[type] !== oldSettings.edgeProgramClasses[type]) {\n              this.registerEdgeProgram(type, settings.edgeProgramClasses[type]);\n            }\n          }\n          for (var _type3 in oldSettings.edgeProgramClasses) {\n            if (!settings.edgeProgramClasses[_type3]) this.unregisterEdgeProgram(_type3);\n          }\n        }\n\n        // Check node programs:\n        if (oldSettings.nodeProgramClasses !== settings.nodeProgramClasses || oldSettings.nodeHoverProgramClasses !== settings.nodeHoverProgramClasses) {\n          for (var _type4 in settings.nodeProgramClasses) {\n            if (settings.nodeProgramClasses[_type4] !== oldSettings.nodeProgramClasses[_type4] || settings.nodeHoverProgramClasses[_type4] !== oldSettings.nodeHoverProgramClasses[_type4]) {\n              this.registerNodeProgram(_type4, settings.nodeProgramClasses[_type4], settings.nodeHoverProgramClasses[_type4]);\n            }\n          }\n          for (var _type5 in oldSettings.nodeProgramClasses) {\n            if (!settings.nodeProgramClasses[_type5]) this.unregisterNodeProgram(_type5);\n          }\n        }\n      }\n\n      // Update captors settings:\n      this.mouseCaptor.setSettings(this.settings);\n      this.touchCaptor.setSettings(this.settings);\n      return this;\n    }\n  }, {\n    key: \"cleanCameraState\",\n    value: function cleanCameraState(state) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$tolerance = _ref.tolerance,\n        tolerance = _ref$tolerance === void 0 ? 0 : _ref$tolerance,\n        boundaries = _ref.boundaries;\n      var newState = _objectSpread2({}, state);\n\n      // Extract necessary properties\n      var _ref2 = boundaries || this.nodeExtent,\n        _ref2$x = _slicedToArray(_ref2.x, 2),\n        xMinGraph = _ref2$x[0],\n        xMaxGraph = _ref2$x[1],\n        _ref2$y = _slicedToArray(_ref2.y, 2),\n        yMinGraph = _ref2$y[0],\n        yMaxGraph = _ref2$y[1];\n\n      // Transform the four corners of the graph rectangle using the provided camera state\n      var corners = [this.graphToViewport({\n        x: xMinGraph,\n        y: yMinGraph\n      }, {\n        cameraState: state\n      }), this.graphToViewport({\n        x: xMaxGraph,\n        y: yMinGraph\n      }, {\n        cameraState: state\n      }), this.graphToViewport({\n        x: xMinGraph,\n        y: yMaxGraph\n      }, {\n        cameraState: state\n      }), this.graphToViewport({\n        x: xMaxGraph,\n        y: yMaxGraph\n      }, {\n        cameraState: state\n      })];\n\n      // Look for new extents, based on these four corners\n      var xMin = Infinity,\n        xMax = -Infinity,\n        yMin = Infinity,\n        yMax = -Infinity;\n      corners.forEach(function (_ref3) {\n        var x = _ref3.x,\n          y = _ref3.y;\n        xMin = Math.min(xMin, x);\n        xMax = Math.max(xMax, x);\n        yMin = Math.min(yMin, y);\n        yMax = Math.max(yMax, y);\n      });\n\n      // For each dimension, constraint the smaller element (camera or graph) to fit in the larger one:\n      var graphWidth = xMax - xMin;\n      var graphHeight = yMax - yMin;\n      var _this$getDimensions = this.getDimensions(),\n        width = _this$getDimensions.width,\n        height = _this$getDimensions.height;\n      var dx = 0;\n      var dy = 0;\n      if (graphWidth >= width) {\n        if (xMax < width - tolerance) dx = xMax - (width - tolerance);else if (xMin > tolerance) dx = xMin - tolerance;\n      } else {\n        if (xMax > width + tolerance) dx = xMax - (width + tolerance);else if (xMin < -tolerance) dx = xMin + tolerance;\n      }\n      if (graphHeight >= height) {\n        if (yMax < height - tolerance) dy = yMax - (height - tolerance);else if (yMin > tolerance) dy = yMin - tolerance;\n      } else {\n        if (yMax > height + tolerance) dy = yMax - (height + tolerance);else if (yMin < -tolerance) dy = yMin + tolerance;\n      }\n      if (dx || dy) {\n        // Transform [dx, dy] from viewport to graph (using two different point to transform that vector):\n        var origin = this.viewportToFramedGraph({\n          x: 0,\n          y: 0\n        }, {\n          cameraState: state\n        });\n        var delta = this.viewportToFramedGraph({\n          x: dx,\n          y: dy\n        }, {\n          cameraState: state\n        });\n        dx = delta.x - origin.x;\n        dy = delta.y - origin.y;\n        newState.x += dx;\n        newState.y += dy;\n      }\n      return newState;\n    }\n\n    /**\n     * Method used to render labels.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderLabels\",\n    value: function renderLabels() {\n      if (!this.settings.renderLabels) return this;\n      var cameraState = this.camera.getState();\n\n      // Selecting labels to draw\n      var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n      extend(labelsToDisplay, this.nodesWithForcedLabels);\n      this.displayedNodeLabels = new Set();\n\n      // Drawing labels\n      var context = this.canvasContexts.labels;\n      for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n        var node = labelsToDisplay[i];\n        var data = this.nodeDataCache[node];\n\n        // If the node was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        // NOTE: we can do better probably\n        if (this.displayedNodeLabels.has(node)) continue;\n\n        // If the node is hidden, we don't need to display its label obviously\n        if (data.hidden) continue;\n        var _this$framedGraphToVi = this.framedGraphToViewport(data),\n          x = _this$framedGraphToVi.x,\n          y = _this$framedGraphToVi.y;\n\n        // NOTE: we can cache the labels we need to render until the camera's ratio changes\n        var size = this.scaleSize(data.size);\n\n        // Is node big enough?\n        if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n\n        // Is node actually on screen (with some margin)\n        // NOTE: we used to rely on the quadtree for this, but the coordinates\n        // conversion make it unreliable and at that point we already converted\n        // to viewport coordinates and since the label grid already culls the\n        // number of potential labels to display this looks like a good\n        // performance compromise.\n        // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n        // considering cells obviously outside of the range of the current\n        // view rectangle.\n        if (x < -X_LABEL_MARGIN || x > this.width + X_LABEL_MARGIN || y < -Y_LABEL_MARGIN || y > this.height + Y_LABEL_MARGIN) continue;\n\n        // Because displayed edge labels depend directly on actually rendered node\n        // labels, we need to only add to this.displayedNodeLabels nodes whose label\n        // is rendered.\n        // This makes this.displayedNodeLabels depend on viewport, which might become\n        // an issue once we start memoizing getLabelsToDisplay.\n        this.displayedNodeLabels.add(node);\n        var defaultDrawNodeLabel = this.settings.defaultDrawNodeLabel;\n        var nodeProgram = this.nodePrograms[data.type];\n        var drawLabel = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawLabel) || defaultDrawNodeLabel;\n        drawLabel(context, _objectSpread2(_objectSpread2({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), this.settings);\n      }\n      return this;\n    }\n\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderEdgeLabels\",\n    value: function renderEdgeLabels() {\n      if (!this.settings.renderEdgeLabels) return this;\n      var context = this.canvasContexts.edgeLabels;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n      var edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({\n        graph: this.graph,\n        hoveredNode: this.hoveredNode,\n        displayedNodeLabels: this.displayedNodeLabels,\n        highlightedNodes: this.highlightedNodes\n      });\n      extend(edgeLabelsToDisplay, this.edgesWithForcedLabels);\n      var displayedLabels = new Set();\n      for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n        var edge = edgeLabelsToDisplay[i],\n          extremities = this.graph.extremities(edge),\n          sourceData = this.nodeDataCache[extremities[0]],\n          targetData = this.nodeDataCache[extremities[1]],\n          edgeData = this.edgeDataCache[edge];\n\n        // If the edge was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        if (displayedLabels.has(edge)) continue;\n\n        // If the edge is hidden we don't need to display its label\n        // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n        if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n          continue;\n        }\n        var defaultDrawEdgeLabel = this.settings.defaultDrawEdgeLabel;\n        var edgeProgram = this.edgePrograms[edgeData.type];\n        var drawLabel = (edgeProgram === null || edgeProgram === void 0 ? void 0 : edgeProgram.drawLabel) || defaultDrawEdgeLabel;\n        drawLabel(context, _objectSpread2(_objectSpread2({\n          key: edge\n        }, edgeData), {}, {\n          size: this.scaleSize(edgeData.size)\n        }), _objectSpread2(_objectSpread2(_objectSpread2({\n          key: extremities[0]\n        }, sourceData), this.framedGraphToViewport(sourceData)), {}, {\n          size: this.scaleSize(sourceData.size)\n        }), _objectSpread2(_objectSpread2(_objectSpread2({\n          key: extremities[1]\n        }, targetData), this.framedGraphToViewport(targetData)), {}, {\n          size: this.scaleSize(targetData.size)\n        }), this.settings);\n        displayedLabels.add(edge);\n      }\n      this.displayedEdgeLabels = displayedLabels;\n      return this;\n    }\n\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderHighlightedNodes\",\n    value: function renderHighlightedNodes() {\n      var _this7 = this;\n      var context = this.canvasContexts.hovers;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n\n      // Rendering\n      var render = function render(node) {\n        var data = _this7.nodeDataCache[node];\n        var _this7$framedGraphToV = _this7.framedGraphToViewport(data),\n          x = _this7$framedGraphToV.x,\n          y = _this7$framedGraphToV.y;\n        var size = _this7.scaleSize(data.size);\n        var defaultDrawNodeHover = _this7.settings.defaultDrawNodeHover;\n        var nodeProgram = _this7.nodePrograms[data.type];\n        var drawHover = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawHover) || defaultDrawNodeHover;\n        drawHover(context, _objectSpread2(_objectSpread2({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), _this7.settings);\n      };\n      var nodesToRender = [];\n      if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n        nodesToRender.push(this.hoveredNode);\n      }\n      this.highlightedNodes.forEach(function (node) {\n        // The hovered node has already been highlighted\n        if (node !== _this7.hoveredNode) nodesToRender.push(node);\n      });\n\n      // Draw labels:\n      nodesToRender.forEach(function (node) {\n        return render(node);\n      });\n\n      // Draw WebGL nodes on top of the labels:\n      var nodesPerPrograms = {};\n\n      // 1. Count nodes per type:\n      nodesToRender.forEach(function (node) {\n        var type = _this7.nodeDataCache[node].type;\n        nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n      });\n      // 2. Allocate for each type for the proper number of nodes\n      for (var type in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // Also reset count, to use when rendering:\n        nodesPerPrograms[type] = 0;\n      }\n      // 3. Process all nodes to render:\n      nodesToRender.forEach(function (node) {\n        var data = _this7.nodeDataCache[node];\n        _this7.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);\n      });\n      // 4. Clear hovered nodes layer:\n      this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n      // 5. Render:\n      var renderParams = this.getRenderParams();\n      for (var _type6 in this.nodeHoverPrograms) {\n        var program = this.nodeHoverPrograms[_type6];\n        program.render(renderParams);\n      }\n    }\n\n    /**\n     * Method used to schedule a hover render.\n     *\n     */\n  }, {\n    key: \"scheduleHighlightedNodesRender\",\n    value: function scheduleHighlightedNodesRender() {\n      var _this8 = this;\n      if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n      this.renderHighlightedNodesFrame = requestAnimationFrame(function () {\n        // Resetting state\n        _this8.renderHighlightedNodesFrame = null;\n\n        // Rendering\n        _this8.renderHighlightedNodes();\n        _this8.renderEdgeLabels();\n      });\n    }\n\n    /**\n     * Method used to render.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this9 = this;\n      this.emit(\"beforeRender\");\n      var exitRender = function exitRender() {\n        _this9.emit(\"afterRender\");\n        return _this9;\n      };\n\n      // If a render was scheduled, we cancel it\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n\n      // First we need to resize\n      this.resize();\n\n      // Do we need to reprocess data?\n      if (this.needToProcess) this.process();\n      this.needToProcess = false;\n\n      // Clearing the canvases\n      this.clear();\n\n      // Prepare the textures\n      this.pickingLayers.forEach(function (layer) {\n        return _this9.resetWebGLTexture(layer);\n      });\n\n      // If we have no nodes we can stop right there\n      if (!this.graph.order) return exitRender();\n\n      // TODO: improve this heuristic or move to the captor itself?\n      // TODO: deal with the touch captor here as well\n      var mouseCaptor = this.mouseCaptor;\n      var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;\n\n      // Then we need to extract a matrix from the camera\n      var cameraState = this.camera.getState();\n      var viewportDimensions = this.getDimensions();\n      var graphDimensions = this.getGraphDimensions();\n      var padding = this.getStagePadding();\n      this.matrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding);\n      this.invMatrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding, true);\n      this.correctionRatio = getMatrixImpact(this.matrix, cameraState, viewportDimensions);\n      this.graphToViewportRatio = this.getGraphToViewportRatio();\n\n      // [jacomyal]\n      // This comment is related to the one above the `getMatrixImpact` definition:\n      // - `this.correctionRatio` is somehow not completely explained\n      // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n      //   graph\n      // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n      // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n      // when I change the graph, the viewport or the camera. It might be useful later, so I prefer to let this comment:\n      // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n\n      var params = this.getRenderParams();\n\n      // Drawing nodes\n      for (var type in this.nodePrograms) {\n        var program = this.nodePrograms[type];\n        program.render(params);\n      }\n\n      // Drawing edges\n      if (!this.settings.hideEdgesOnMove || !moving) {\n        for (var _type7 in this.edgePrograms) {\n          var _program2 = this.edgePrograms[_type7];\n          _program2.render(params);\n        }\n      }\n\n      // Do not display labels on move per setting\n      if (this.settings.hideLabelsOnMove && moving) return exitRender();\n      this.renderLabels();\n      this.renderEdgeLabels();\n      this.renderHighlightedNodes();\n      return exitRender();\n    }\n\n    /**\n     * Add a node in the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"addNode\",\n    value: function addNode(key) {\n      // Node display data resolution:\n      //  1. First we get the node's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //     Note that this function must return a total object and won't be merged\n      //  3. We apply our defaults, while running some vital checks\n      //  4. We apply the normalization function\n      // We shallow copy node data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getNodeAttributes(key));\n      if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);\n      var data = applyNodeDefaults(this.settings, key, attr);\n      this.nodeDataCache[key] = data;\n\n      // Label:\n      // We delete and add if needed because this function is also used from\n      // update\n      this.nodesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);\n\n      // Highlighted:\n      // We remove and re add if needed because this function is also used from\n      // update\n      this.highlightedNodes[\"delete\"](key);\n      if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);\n\n      // zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update a node the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"updateNode\",\n    value: function updateNode(key) {\n      this.addNode(key);\n\n      // Re-apply normalization on the node\n      var data = this.nodeDataCache[key];\n      this.normalizationFunction.applyTo(data);\n    }\n\n    /**\n     * Remove a node from the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(key) {\n      // Remove from node cache\n      delete this.nodeDataCache[key];\n      // Remove from node program index\n      delete this.nodeProgramIndex[key];\n      // Remove from higlighted nodes\n      this.highlightedNodes[\"delete\"](key);\n      // Remove from hovered\n      if (this.hoveredNode === key) this.hoveredNode = null;\n      // Remove from forced label\n      this.nodesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Add an edge into the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(key) {\n      // Edge display data resolution:\n      //  1. First we get the edge's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //  3. Note that this function must return a total object and won't be merged\n      //  4. We apply our defaults, while running some vital checks\n      // We shallow copy edge data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getEdgeAttributes(key));\n      if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);\n      var data = applyEdgeDefaults(this.settings, key, attr);\n      this.edgeDataCache[key] = data;\n\n      // Forced label\n      // we filter and re push if needed because this function is also used from\n      // update\n      this.edgesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);\n\n      // Check zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update an edge in the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"updateEdge\",\n    value: function updateEdge(key) {\n      this.addEdge(key);\n    }\n\n    /**\n     * Remove an edge from the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"removeEdge\",\n    value: function removeEdge(key) {\n      // Remove from edge cache\n      delete this.edgeDataCache[key];\n      // Remove from programId index\n      delete this.edgeProgramIndex[key];\n      // Remove from hovered\n      if (this.hoveredEdge === key) this.hoveredEdge = null;\n      // Remove from forced label\n      this.edgesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Clear all indices related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeIndices\",\n    value: function clearNodeIndices() {\n      // LabelGrid & nodeExtent are only manage/populated in the process function\n      this.labelGrid = new LabelGrid();\n      this.nodeExtent = {\n        x: [0, 1],\n        y: [0, 1]\n      };\n      this.nodeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.nodesWithForcedLabels = new Set();\n      this.nodeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeIndices\",\n    value: function clearEdgeIndices() {\n      this.edgeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.edgesWithForcedLabels = new Set();\n      this.edgeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices.\n     * @private\n     */\n  }, {\n    key: \"clearIndices\",\n    value: function clearIndices() {\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n    }\n\n    /**\n     * Clear all graph state related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeState\",\n    value: function clearNodeState() {\n      this.displayedNodeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredNode = null;\n    }\n\n    /**\n     * Clear all graph state related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeState\",\n    value: function clearEdgeState() {\n      this.displayedEdgeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredEdge = null;\n    }\n\n    /**\n     * Clear all graph state.\n     * @private\n     */\n  }, {\n    key: \"clearState\",\n    value: function clearState() {\n      this.clearEdgeState();\n      this.clearNodeState();\n    }\n\n    /**\n     * Add the node data to its program.\n     * @private\n     * @param node The node's graphology ID\n     * @param fingerprint A fingerprint used to identity the node with picking\n     * @param position The index where to place the node in the program\n     */\n  }, {\n    key: \"addNodeToProgram\",\n    value: function addNodeToProgram(node, fingerprint, position) {\n      var data = this.nodeDataCache[node];\n      var nodeProgram = this.nodePrograms[data.type];\n      if (!nodeProgram) throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(data.type, \"\\\"!\"));\n      nodeProgram.process(fingerprint, position, data);\n      // Saving program index\n      this.nodeProgramIndex[node] = position;\n    }\n\n    /**\n     * Add the edge data to its program.\n     * @private\n     * @param edge The edge's graphology ID\n     * @param fingerprint A fingerprint used to identity the edge with picking\n     * @param position The index where to place the edge in the program\n     */\n  }, {\n    key: \"addEdgeToProgram\",\n    value: function addEdgeToProgram(edge, fingerprint, position) {\n      var data = this.edgeDataCache[edge];\n      var edgeProgram = this.edgePrograms[data.type];\n      if (!edgeProgram) throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(data.type, \"\\\"!\"));\n      var extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]];\n      edgeProgram.process(fingerprint, position, sourceData, targetData, data);\n      // Saving program index\n      this.edgeProgramIndex[edge] = position;\n    }\n\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n\n    /**\n     * Function used to get the render params.\n     *\n     * @return {RenderParams}\n     */\n  }, {\n    key: \"getRenderParams\",\n    value: function getRenderParams() {\n      return {\n        matrix: this.matrix,\n        invMatrix: this.invMatrix,\n        width: this.width,\n        height: this.height,\n        pixelRatio: this.pixelRatio,\n        zoomRatio: this.camera.ratio,\n        cameraAngle: this.camera.angle,\n        sizeRatio: 1 / this.scaleSize(),\n        correctionRatio: this.correctionRatio,\n        downSizingRatio: this.pickingDownSizingRatio,\n        minEdgeThickness: this.settings.minEdgeThickness,\n        antiAliasingFeather: this.settings.antiAliasingFeather\n      };\n    }\n\n    /**\n     * Function used to retrieve the actual stage padding value.\n     *\n     * @return {number}\n     */\n  }, {\n    key: \"getStagePadding\",\n    value: function getStagePadding() {\n      var _this$settings = this.settings,\n        stagePadding = _this$settings.stagePadding,\n        autoRescale = _this$settings.autoRescale;\n      return autoRescale ? stagePadding || 0 : 0;\n    }\n\n    /**\n     * Function used to create a layer element.\n     *\n     * @param {string} id - Context's id.\n     * @param {string} tag - The HTML tag to use.\n     * @param options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createLayer\",\n    value: function createLayer(id, tag) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (this.elements[id]) throw new Error(\"Sigma: a layer named \\\"\".concat(id, \"\\\" already exists\"));\n      var element = createElement(tag, {\n        position: \"absolute\"\n      }, {\n        \"class\": \"sigma-\".concat(id)\n      });\n      if (options.style) Object.assign(element.style, options.style);\n      this.elements[id] = element;\n      if (\"beforeLayer\" in options && options.beforeLayer) {\n        this.elements[options.beforeLayer].before(element);\n      } else if (\"afterLayer\" in options && options.afterLayer) {\n        this.elements[options.afterLayer].after(element);\n      } else {\n        this.container.appendChild(element);\n      }\n      return element;\n    }\n\n    /**\n     * Function used to create a canvas element.\n     *\n     * @param {string} id - Context's id.\n     * @param options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvas\",\n    value: function createCanvas(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.createLayer(id, \"canvas\", options);\n    }\n\n    /**\n     * Function used to create a canvas context and add the relevant DOM elements.\n     *\n     * @param  {string} id - Context's id.\n     * @param  options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvasContext\",\n    value: function createCanvasContext(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var canvas = this.createCanvas(id, options);\n      var contextOptions = {\n        preserveDrawingBuffer: false,\n        antialias: false\n      };\n      this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n      return this;\n    }\n\n    /**\n     * Function used to create a WebGL context and add the relevant DOM\n     * elements.\n     *\n     * @param  {string}  id      - Context's id.\n     * @param  {object?} options - #getContext params to override (optional)\n     * @return {WebGLRenderingContext}\n     */\n  }, {\n    key: \"createWebGLContext\",\n    value: function createWebGLContext(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var canvas = (options === null || options === void 0 ? void 0 : options.canvas) || this.createCanvas(id, options);\n      if (options.hidden) canvas.remove();\n      var contextOptions = _objectSpread2({\n        preserveDrawingBuffer: false,\n        antialias: false\n      }, options);\n      var context;\n\n      // First we try webgl2 for an easy performance boost\n      context = canvas.getContext(\"webgl2\", contextOptions);\n\n      // Else we fall back to webgl\n      if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n\n      // Edge, I am looking right at you...\n      if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n      var gl = context;\n      this.webGLContexts[id] = gl;\n\n      // Blending:\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Prepare frame buffer for picking layers:\n      if (options.picking) {\n        this.pickingLayers.add(id);\n        var newFrameBuffer = gl.createFramebuffer();\n        if (!newFrameBuffer) throw new Error(\"Sigma: cannot create a new frame buffer for layer \".concat(id));\n        this.frameBuffers[id] = newFrameBuffer;\n      }\n      return gl;\n    }\n\n    /**\n     * Function used to properly kill a layer.\n     *\n     * @param  {string} id - Layer id.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"killLayer\",\n    value: function killLayer(id) {\n      var element = this.elements[id];\n      if (!element) throw new Error(\"Sigma: cannot kill layer \".concat(id, \", which does not exist\"));\n      if (this.webGLContexts[id]) {\n        var _gl$getExtension;\n        var gl = this.webGLContexts[id];\n        (_gl$getExtension = gl.getExtension(\"WEBGL_lose_context\")) === null || _gl$getExtension === void 0 || _gl$getExtension.loseContext();\n        delete this.webGLContexts[id];\n      } else if (this.canvasContexts[id]) {\n        delete this.canvasContexts[id];\n      }\n\n      // Delete layer element\n      element.remove();\n      delete this.elements[id];\n      return this;\n    }\n\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"getCamera\",\n    value: function getCamera() {\n      return this.camera;\n    }\n\n    /**\n     * Method setting the renderer's camera.\n     *\n     * @param  {Camera} camera - New camera.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCamera\",\n    value: function setCamera(camera) {\n      this.unbindCameraHandlers();\n      this.camera = camera;\n      this.bindCameraHandlers();\n    }\n\n    /**\n     * Method returning the container DOM element.\n     *\n     * @return {HTMLElement}\n     */\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.container;\n    }\n\n    /**\n     * Method returning the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"getGraph\",\n    value: function getGraph() {\n      return this.graph;\n    }\n\n    /**\n     * Method used to set the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"setGraph\",\n    value: function setGraph(graph) {\n      if (graph === this.graph) return;\n\n      // Check hoveredNode and hoveredEdge\n      if (this.hoveredNode && !graph.hasNode(this.hoveredNode)) this.hoveredNode = null;\n      if (this.hoveredEdge && !graph.hasEdge(this.hoveredEdge)) this.hoveredEdge = null;\n\n      // Unbinding handlers on the current graph\n      this.unbindGraphHandlers();\n      if (this.checkEdgesEventsFrame !== null) {\n        cancelAnimationFrame(this.checkEdgesEventsFrame);\n        this.checkEdgesEventsFrame = null;\n      }\n\n      // Installing new graph\n      this.graph = graph;\n\n      // Binding new handlers\n      this.bindGraphHandlers();\n\n      // Re-rendering now to avoid discrepancies from now to next frame\n      this.refresh();\n    }\n\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {MouseCaptor}\n     */\n  }, {\n    key: \"getMouseCaptor\",\n    value: function getMouseCaptor() {\n      return this.mouseCaptor;\n    }\n\n    /**\n     * Method returning the touch captor.\n     *\n     * @return {TouchCaptor}\n     */\n  }, {\n    key: \"getTouchCaptor\",\n    value: function getTouchCaptor() {\n      return this.touchCaptor;\n    }\n\n    /**\n     * Method returning the current renderer's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n\n    /**\n     * Method returning the current graph's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getGraphDimensions\",\n    value: function getGraphDimensions() {\n      var extent = this.customBBox || this.nodeExtent;\n      return {\n        width: extent.x[1] - extent.x[0] || 1,\n        height: extent.y[1] - extent.y[0] || 1\n      };\n    }\n\n    /**\n     * Method used to get all the sigma node attributes.\n     * It's useful for example to get the position of a node\n     * and to get values that are set by the nodeReducer\n     *\n     * @param  {string} key - The node's key.\n     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n     */\n  }, {\n    key: \"getNodeDisplayData\",\n    value: function getNodeDisplayData(key) {\n      var node = this.nodeDataCache[key];\n      return node ? Object.assign({}, node) : undefined;\n    }\n\n    /**\n     * Method used to get all the sigma edge attributes.\n     * It's useful for example to get values that are set by the edgeReducer.\n     *\n     * @param  {string} key - The edge's key.\n     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n     */\n  }, {\n    key: \"getEdgeDisplayData\",\n    value: function getEdgeDisplayData(key) {\n      var edge = this.edgeDataCache[key];\n      return edge ? Object.assign({}, edge) : undefined;\n    }\n\n    /**\n     * Method used to get the set of currently displayed node labels.\n     *\n     * @return {Set<string>} A set of node keys whose label is displayed.\n     */\n  }, {\n    key: \"getNodeDisplayedLabels\",\n    value: function getNodeDisplayedLabels() {\n      return new Set(this.displayedNodeLabels);\n    }\n\n    /**\n     * Method used to get the set of currently displayed edge labels.\n     *\n     * @return {Set<string>} A set of edge keys whose label is displayed.\n     */\n  }, {\n    key: \"getEdgeDisplayedLabels\",\n    value: function getEdgeDisplayedLabels() {\n      return new Set(this.displayedEdgeLabels);\n    }\n\n    /**\n     * Method returning a copy of the settings collection.\n     *\n     * @return {Settings} A copy of the settings collection.\n     */\n  }, {\n    key: \"getSettings\",\n    value: function getSettings() {\n      return _objectSpread2({}, this.settings);\n    }\n\n    /**\n     * Method returning the current value for a given setting key.\n     *\n     * @param  {string} key - The setting key to get.\n     * @return {any} The value attached to this setting key or undefined if not found\n     */\n  }, {\n    key: \"getSetting\",\n    value: function getSetting(key) {\n      return this.settings[key];\n    }\n\n    /**\n     * Method setting the value of a given setting key. Note that this will schedule\n     * a new render next frame.\n     *\n     * @param  {string} key - The setting key to set.\n     * @param  {any}    value - The value to set.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setSetting\",\n    value: function setSetting(key, value) {\n      var oldValues = _objectSpread2({}, this.settings);\n      this.settings[key] = value;\n      validateSettings(this.settings);\n      this.handleSettingsUpdate(oldValues);\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method updating the value of a given setting key using the provided function.\n     * Note that this will schedule a new render next frame.\n     *\n     * @param  {string}   key     - The setting key to set.\n     * @param  {function} updater - The update function.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"updateSetting\",\n    value: function updateSetting(key, updater) {\n      this.setSetting(key, updater(this.settings[key]));\n      return this;\n    }\n\n    /**\n     * Method setting multiple settings at once.\n     *\n     * @param  {Partial<Settings>} settings - The settings to set.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      var oldValues = _objectSpread2({}, this.settings);\n      this.settings = _objectSpread2(_objectSpread2({}, this.settings), settings);\n      validateSettings(this.settings);\n      this.handleSettingsUpdate(oldValues);\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method used to resize the renderer.\n     *\n     * @param  {boolean} force - If true, then resize is processed even if size is unchanged (optional).\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resize\",\n    value: function resize(force) {\n      var previousWidth = this.width,\n        previousHeight = this.height;\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n      this.pixelRatio = getPixelRatio();\n      if (this.width === 0) {\n        if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n      if (this.height === 0) {\n        if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n\n      // If nothing has changed, we can stop right here\n      if (!force && previousWidth === this.width && previousHeight === this.height) return this;\n\n      // Sizing dom elements\n      for (var id in this.elements) {\n        var element = this.elements[id];\n        element.style.width = this.width + \"px\";\n        element.style.height = this.height + \"px\";\n      }\n\n      // Sizing canvas contexts\n      for (var _id in this.canvasContexts) {\n        this.elements[_id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        if (this.pixelRatio !== 1) this.canvasContexts[_id].scale(this.pixelRatio, this.pixelRatio);\n      }\n\n      // Sizing WebGL contexts\n      for (var _id2 in this.webGLContexts) {\n        this.elements[_id2].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id2].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        var gl = this.webGLContexts[_id2];\n        gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n\n        // Clear picking texture if needed\n        if (this.pickingLayers.has(_id2)) {\n          var currentTexture = this.textures[_id2];\n          if (currentTexture) gl.deleteTexture(currentTexture);\n        }\n      }\n      this.emit(\"resize\");\n      return this;\n    }\n\n    /**\n     * Method used to clear all the canvases.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.emit(\"beforeClear\");\n      this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n      this.emit(\"afterClear\");\n      return this;\n    }\n\n    /**\n     * Method used to refresh, i.e. force the renderer to reprocess graph\n     * data and render, but keep the state.\n     * - if a partialGraph is provided, we only reprocess those nodes & edges.\n     * - if schedule is TRUE, we schedule a render instead of sync render\n     * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh(opts) {\n      var _this10 = this;\n      var skipIndexation = (opts === null || opts === void 0 ? void 0 : opts.skipIndexation) !== undefined ? opts === null || opts === void 0 ? void 0 : opts.skipIndexation : false;\n      var schedule = (opts === null || opts === void 0 ? void 0 : opts.schedule) !== undefined ? opts.schedule : false;\n      var fullRefresh = !opts || !opts.partialGraph;\n      if (fullRefresh) {\n        // Re-index graph data\n        this.clearEdgeIndices();\n        this.clearNodeIndices();\n        this.graph.forEachNode(function (node) {\n          return _this10.addNode(node);\n        });\n        this.graph.forEachEdge(function (edge) {\n          return _this10.addEdge(edge);\n        });\n      } else {\n        var _opts$partialGraph, _opts$partialGraph2;\n        var nodes = ((_opts$partialGraph = opts.partialGraph) === null || _opts$partialGraph === void 0 ? void 0 : _opts$partialGraph.nodes) || [];\n        for (var i = 0, l = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0; i < l; i++) {\n          var node = nodes[i];\n          // Recompute node's data (ie. apply reducer)\n          this.updateNode(node);\n          // Add node to the program if layout is unchanged.\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var programIndex = this.nodeProgramIndex[node];\n            if (programIndex === undefined) throw new Error(\"Sigma: node \\\"\".concat(node, \"\\\" can't be repaint\"));\n            this.addNodeToProgram(node, this.nodeIndices[node], programIndex);\n          }\n        }\n        var edges = (opts === null || opts === void 0 || (_opts$partialGraph2 = opts.partialGraph) === null || _opts$partialGraph2 === void 0 ? void 0 : _opts$partialGraph2.edges) || [];\n        for (var _i4 = 0, _l4 = edges.length; _i4 < _l4; _i4++) {\n          var edge = edges[_i4];\n          // Recompute edge's data (ie. apply reducer)\n          this.updateEdge(edge);\n          // Add edge to the program\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var _programIndex = this.edgeProgramIndex[edge];\n            if (_programIndex === undefined) throw new Error(\"Sigma: edge \\\"\".concat(edge, \"\\\" can't be repaint\"));\n            this.addEdgeToProgram(edge, this.edgeIndices[edge], _programIndex);\n          }\n        }\n      }\n\n      // Do we need to call the process function ?\n      if (fullRefresh || !skipIndexation) this.needToProcess = true;\n      if (schedule) this.scheduleRender();else this.render();\n      return this;\n    }\n\n    /**\n     * Method used to schedule a render at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRender\",\n    value: function scheduleRender() {\n      var _this11 = this;\n      if (!this.renderFrame) {\n        this.renderFrame = requestAnimationFrame(function () {\n          _this11.render();\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n     * at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRefresh\",\n    value: function scheduleRefresh(opts) {\n      return this.refresh(_objectSpread2(_objectSpread2({}, opts), {}, {\n        schedule: true\n      }));\n    }\n\n    /**\n     * Method used to (un)zoom, while preserving the position of a viewport point.\n     * Used for instance to zoom \"on the mouse cursor\".\n     *\n     * @param viewportTarget\n     * @param newRatio\n     * @return {CameraState}\n     */\n  }, {\n    key: \"getViewportZoomedState\",\n    value: function getViewportZoomedState(viewportTarget, newRatio) {\n      var _this$camera$getState = this.camera.getState(),\n        ratio = _this$camera$getState.ratio,\n        angle = _this$camera$getState.angle,\n        x = _this$camera$getState.x,\n        y = _this$camera$getState.y;\n      var _this$settings2 = this.settings,\n        minCameraRatio = _this$settings2.minCameraRatio,\n        maxCameraRatio = _this$settings2.maxCameraRatio;\n      if (typeof maxCameraRatio === \"number\") newRatio = Math.min(newRatio, maxCameraRatio);\n      if (typeof minCameraRatio === \"number\") newRatio = Math.max(newRatio, minCameraRatio);\n      var ratioDiff = newRatio / ratio;\n      var center = {\n        x: this.width / 2,\n        y: this.height / 2\n      };\n      var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n      var graphCenterPosition = this.viewportToFramedGraph(center);\n      return {\n        angle: angle,\n        x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n        y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n        ratio: newRatio\n      };\n    }\n\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n  }, {\n    key: \"viewRectangle\",\n    value: function viewRectangle() {\n      var p1 = this.viewportToFramedGraph({\n          x: 0,\n          y: 0\n        }),\n        p2 = this.viewportToFramedGraph({\n          x: this.width,\n          y: 0\n        }),\n        h = this.viewportToFramedGraph({\n          x: 0,\n          y: this.height\n        });\n      return {\n        x1: p1.x,\n        y1: p1.y,\n        x2: p2.x,\n        y2: p2.y,\n        height: p2.y - h.y\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"framedGraphToViewport\",\n    value: function framedGraphToViewport(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n      var matrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding()) : this.matrix;\n      var viewportPos = multiplyVec2(matrix, coordinates);\n      return {\n        x: (1 + viewportPos.x) * this.width / 2,\n        y: (1 - viewportPos.y) * this.height / 2\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"viewportToFramedGraph\",\n    value: function viewportToFramedGraph(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n      var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding(), true) : this.invMatrix;\n      var res = multiplyVec2(invMatrix, {\n        x: coordinates.x / this.width * 2 - 1,\n        y: 1 - coordinates.y / this.height * 2\n      });\n      if (isNaN(res.x)) res.x = 0;\n      if (isNaN(res.y)) res.y = 0;\n      return res;\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n     * stage) to the graph system (the reference system of data as they are in the given graph instance).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  viewportPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"viewportToGraph\",\n    value: function viewportToGraph(viewportPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  graphPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"graphToViewport\",\n    value: function graphToViewport(graphPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n    }\n\n    /**\n     * Method returning the distance multiplier between the graph system and the\n     * viewport system.\n     */\n  }, {\n    key: \"getGraphToViewportRatio\",\n    value: function getGraphToViewportRatio() {\n      var graphP1 = {\n        x: 0,\n        y: 0\n      };\n      var graphP2 = {\n        x: 1,\n        y: 1\n      };\n      var graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n      var viewportP1 = this.graphToViewport(graphP1);\n      var viewportP2 = this.graphToViewport(graphP2);\n      var viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n      return viewportD / graphD;\n    }\n\n    /**\n     * Method returning the graph's bounding box.\n     *\n     * @return {{ x: Extent, y: Extent }}\n     */\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      return this.nodeExtent;\n    }\n\n    /**\n     * Method returning the graph's custom bounding box, if any.\n     *\n     * @return {{ x: Extent, y: Extent } | null}\n     */\n  }, {\n    key: \"getCustomBBox\",\n    value: function getCustomBBox() {\n      return this.customBBox;\n    }\n\n    /**\n     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCustomBBox\",\n    value: function setCustomBBox(customBBox) {\n      this.customBBox = customBBox;\n      this.scheduleRender();\n      return this;\n    }\n\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      // Emitting \"kill\" events so that plugins and such can cleanup\n      this.emit(\"kill\");\n\n      // Releasing events\n      this.removeAllListeners();\n\n      // Releasing camera handlers\n      this.unbindCameraHandlers();\n\n      // Releasing DOM events & captors\n      window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n      this.mouseCaptor.kill();\n      this.touchCaptor.kill();\n\n      // Releasing graph handlers\n      this.unbindGraphHandlers();\n\n      // Releasing cache & state\n      this.clearIndices();\n      this.clearState();\n      this.nodeDataCache = {};\n      this.edgeDataCache = {};\n      this.highlightedNodes.clear();\n\n      // Clearing frames\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n      if (this.renderHighlightedNodesFrame) {\n        cancelAnimationFrame(this.renderHighlightedNodesFrame);\n        this.renderHighlightedNodesFrame = null;\n      }\n\n      // Destroying canvases\n      var container = this.container;\n      while (container.firstChild) container.removeChild(container.firstChild);\n\n      // Destroying remaining collections\n      this.canvasContexts = {};\n      this.webGLContexts = {};\n      this.elements = {};\n\n      // Kill programs:\n      for (var type in this.nodePrograms) {\n        this.nodePrograms[type].kill();\n      }\n      for (var _type8 in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[_type8].kill();\n      }\n      for (var _type9 in this.edgePrograms) {\n        this.edgePrograms[_type9].kill();\n      }\n      this.nodePrograms = {};\n      this.nodeHoverPrograms = {};\n      this.edgePrograms = {};\n\n      // Kill all canvas/WebGL contexts\n      for (var id in this.elements) {\n        this.killLayer(id);\n      }\n    }\n\n    /**\n     * Method used to scale the given size according to the camera's ratio, i.e.\n     * zooming state.\n     *\n     * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n     * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n     * @return {number}              - The scaled size.\n     */\n  }, {\n    key: \"scaleSize\",\n    value: function scaleSize() {\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var cameraRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.camera.ratio;\n      return size / this.settings.zoomToSizeRatioFunction(cameraRatio) * (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1);\n    }\n\n    /**\n     * Method that returns the collection of all used canvases.\n     * At the moment, the instantiated canvases are the following, and in the\n     * following order in the DOM:\n     * - `edges`\n     * - `nodes`\n     * - `edgeLabels`\n     * - `labels`\n     * - `hovers`\n     * - `hoverNodes`\n     * - `mouse`\n     *\n     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n     */\n  }, {\n    key: \"getCanvases\",\n    value: function getCanvases() {\n      var res = {};\n      for (var layer in this.elements) if (this.elements[layer] instanceof HTMLCanvasElement) res[layer] = this.elements[layer];\n      return res;\n    }\n  }]);\n}(TypedEventEmitter);\n\n/**\n * Sigma.js Library Endpoint\n * =========================\n *\n * The library endpoint.\n * @module\n */\nvar Sigma = Sigma$1;\nexport { Camera, MouseCaptor, Sigma$1 as Sigma, TouchCaptor, Sigma as default };","map":{"version":3,"names":["_","_objectSpread2","a","_defineProperty","_inherits","_createClass","b","_classCallCheck","c","_callSuper","d","_toPropertyKey","TypedEventEmitter","A","ANIMATE_DEFAULTS","e","easings","g","graphExtent","createNormalizationFunction","m","matrixFromCamera","z","zIndexOrdering","getMatrixImpact","createElement","getPixelRatio","f","multiplyVec2","i","identity","v","validateGraph","DEFAULT_SETTINGS","validateSettings","resolveSettings","_slicedToArray","_arrayLikeToArray","_unsupportedIterableToArray","getPixelColor","colorToIndex","_typeof","extend","DEFAULT_ZOOMING_RATIO","Camera","_TypedEventEmitter","_this","previousState","getState","key","value","enable","enabled","disable","x","y","angle","ratio","hasState","state","getPreviousState","getBoundedRatio","r","minRatio","Math","max","maxRatio","min","validateState","validatedState","enabledPanning","enabledZooming","enabledRotation","clean","isAnimated","nextFrame","setState","validState","emit","updateState","updater","animate","_this2","opts","arguments","length","undefined","callback","Promise","resolve","options","easing","start","Date","now","initialState","_fn","fn","t","duration","animationCallback","call","coefficient","newState","requestAnimationFrame","cancelAnimationFrame","animatedZoom","factorOrOptions","factor","animatedUnzoom","animatedReset","copy","from","camera","getPosition","dom","bbox","getBoundingClientRect","clientX","left","clientY","top","getMouseCoords","res","sigmaDefaultPrevented","preventSigmaDefault","original","cleanMouseCoords","touches","previousTouches","getWheelCoords","delta","getWheelDelta","MAX_TOUCHES","getTouchesArray","arr","l","push","getTouchCoords","map","touch","deltaY","detail","Error","Captor","container","renderer","MOUSE_SETTINGS_KEYS","DEFAULT_MOUSE_SETTINGS","reduce","iter","MouseCaptor","_Captor","handleClick","bind","handleRightClick","handleDown","handleUp","handleMove","handleWheel","handleLeave","handleEnter","addEventListener","capture","document","kill","removeEventListener","clicks","doubleClickTimeout","clearTimeout","handleDoubleClick","setTimeout","settings","draggedEvents","draggedEventsTolerance","preventDefault","stopPropagation","mouseCoords","getCamera","newRatio","doubleClickZoomingRatio","getViewportZoomedState","doubleClickZoomingDuration","button","startCameraState","_getPosition","lastMouseX","lastMouseY","downStartTime","isMouseDown","_this3","movingTimeout","_getPosition2","cameraState","previousCameraState","isMoving","inertiaRatio","inertiaDuration","shouldRefresh","getSetting","refresh","_this4","target","composedPath","window","dragTimeout","_getPosition3","eX","eY","lastMouse","viewportToFramedGraph","mouse","offsetX","offsetY","_this5","wheelCoords","currentRatio","ratioDiff","zoomingRatio","wheelDirection","currentWheelDirection","lastWheelTriggerTime","zoomDuration","setSettings","TOUCH_SETTINGS_KEYS","DEFAULT_TOUCH_SETTINGS","TouchCaptor","handleStart","passive","getDimensions","width","offsetWidth","height","offsetHeight","touchMode","startTouchesPositions","_this$startTouchesPos","_this$startTouchesPos2","x0","y0","_this$startTouchesPos3","x1","y1","startTouchesAngle","atan2","startTouchesDistance","sqrt","pow","lastTouches","lastTouchesPositions","cancelable","hasMoved","position","downPosition","dSquare","tapMoveTolerance","lastTap","time","touchCoords","_camera","_touchCoords","touchesPositions","some","idx","startPosition","padding","_this$renderer$viewpo","xStart","yStart","_this$renderer$viewpo2","newCameraState","_touchesPositions$","_touchesPositions$2","angleDiff","hypot","dimensions","touchGraphPosition","smallestDimension","dx","dy","_x","_y","_ref","cos","sin","_arrayWithoutHoles","Array","isArray","_iterableToArray","Symbol","iterator","_nonIterableSpread","TypeError","_toConsumableArray","_objectWithoutPropertiesLoose","n","hasOwnProperty","includes","_objectWithoutProperties","o","Object","getOwnPropertySymbols","s","propertyIsEnumerable","LabelCandidate","size","compare","first","second","LabelGrid","resizeAndClear","cellSize","columns","ceil","rows","cells","getIndex","pos","xIndex","floor","yIndex","add","candidate","index","cell","organize","k","sort","getLabelsToDisplay","density","cellArea","scaledCellArea","scaledDensity","labelsToDisplayPerCell","labels","edgeLabelsToDisplayFromNodes","params","graph","hoveredNode","highlightedNodes","displayedNodeLabels","worthyEdges","forEachEdge","edge","source","has","X_LABEL_MARGIN","Y_LABEL_MARGIN","prototype","applyNodeDefaults","data","concat","color","defaultNodeColor","label","hidden","highlighted","forceLabel","type","defaultNodeType","zIndex","applyEdgeDefaults","_key","defaultEdgeColor","defaultEdgeType","Sigma$1","Sigma","Set","Infinity","pixelRatio","HTMLElement","createWebGLContext","picking","enableEdgeEvents","createCanvasContext","style","touchAction","userSelect","resize","nodeProgramClasses","registerNodeProgram","nodeHoverProgramClasses","_type","edgeProgramClasses","registerEdgeProgram","bindCameraHandlers","mouseCaptor","elements","touchCaptor","bindEventHandlers","bindGraphHandlers","handleSettingsUpdate","NodeProgramClass","NodeHoverProgram","nodePrograms","nodeHoverPrograms","webGLContexts","nodes","frameBuffers","hoverNodes","EdgeProgramClass","edgePrograms","edges","unregisterNodeProgram","_this$nodePrograms","program","programs","_this$nodeHoverProgra","_program","_programs","unregisterEdgeProgram","_this$edgePrograms","resetWebGLTexture","id","gl","frameBuffer","currentTexture","textures","deleteTexture","pickingTexture","createTexture","bindFramebuffer","FRAMEBUFFER","bindTexture","TEXTURE_2D","texImage2D","RGBA","UNSIGNED_BYTE","framebufferTexture2D","COLOR_ATTACHMENT0","activeListeners","scheduleRender","on","unbindCameraHandlers","removeListener","getNodeAtPosition","pickingDownSizingRatio","apply","itemAt","itemIDsIndex","handleResize","scheduleRefresh","event","baseEvent","nodeToHover","nodeDataCache","node","scheduleHighlightedNodesRender","edgeToHover","getEdgeAtPoint","hoveredEdge","handleMoveBody","createInteractionListener","eventType","nodeAtPosition","LAYOUT_IMPACTING_FIELDS","eachNodeAttributesUpdatedGraphUpdate","_e$hints","updatedFields","hints","attributes","forEachNode","updateNode","layoutChanged","partialGraph","skipIndexation","schedule","eachEdgeAttributesUpdatedGraphUpdate","_e$hints2","updateEdge","addNodeGraphUpdate","payload","addNode","updateNodeGraphUpdate","dropNodeGraphUpdate","removeNode","addEdgeGraphUpdate","addEdge","updateEdgeGraphUpdate","dropEdgeGraphUpdate","removeEdge","clearEdgesGraphUpdate","clearEdgeState","clearEdgeIndices","clearGraphUpdate","clearNodeState","clearNodeIndices","unbindGraphHandlers","process","nodeExtent","autoRescale","_this$nodeExtent","normalizationFunction","customBBox","nullCamera","nullCameraMatrix","getGraphDimensions","getStagePadding","labelGrid","labelGridCellSize","nodesPerPrograms","nodeIndices","edgeIndices","incrID","attrs","getNodeAttributes","applyTo","framedGraphToViewport","matrix","reallocate","nodeZExtent","_i","_l","_node","_data","addNodeToProgram","edgesPerPrograms","_i2","_l2","_data2","edgeDataCache","edgeZExtent","_type2","_i3","_l3","_edge","_data3","addEdgeToProgram","oldSettings","_this6","minCameraRatio","maxCameraRatio","enableCameraZooming","enableCameraPanning","enableCameraRotation","cameraPanBoundaries","cleanCameraState","_type3","_type4","_type5","_ref$tolerance","tolerance","boundaries","_ref2","_ref2$x","xMinGraph","xMaxGraph","_ref2$y","yMinGraph","yMaxGraph","corners","graphToViewport","xMin","xMax","yMin","yMax","forEach","_ref3","graphWidth","graphHeight","_this$getDimensions","origin","renderLabels","labelsToDisplay","labelDensity","nodesWithForcedLabels","context","canvasContexts","_this$framedGraphToVi","scaleSize","labelRenderedSizeThreshold","defaultDrawNodeLabel","nodeProgram","drawLabel","renderEdgeLabels","edgeLabels","clearRect","edgeLabelsToDisplay","edgesWithForcedLabels","displayedLabels","extremities","sourceData","targetData","edgeData","defaultDrawEdgeLabel","edgeProgram","displayedEdgeLabels","renderHighlightedNodes","_this7","hovers","render","_this7$framedGraphToV","defaultDrawNodeHover","drawHover","nodesToRender","clear","COLOR_BUFFER_BIT","renderParams","getRenderParams","_type6","_this8","renderHighlightedNodesFrame","renderFrame","_this9","exitRender","needToProcess","pickingLayers","layer","order","moving","viewportDimensions","graphDimensions","invMatrix","correctionRatio","graphToViewportRatio","getGraphToViewportRatio","hideEdgesOnMove","_type7","_program2","hideLabelsOnMove","attr","assign","nodeReducer","nodeProgramIndex","getEdgeAttributes","edgeReducer","edgeProgramIndex","clearIndices","clearState","fingerprint","zoomRatio","cameraAngle","sizeRatio","downSizingRatio","minEdgeThickness","antiAliasingFeather","_this$settings","stagePadding","createLayer","tag","element","beforeLayer","before","afterLayer","after","appendChild","createCanvas","canvas","contextOptions","preserveDrawingBuffer","antialias","getContext","remove","blendFunc","ONE","ONE_MINUS_SRC_ALPHA","newFrameBuffer","createFramebuffer","killLayer","_gl$getExtension","getExtension","loseContext","setCamera","getContainer","getGraph","setGraph","hasNode","hasEdge","checkEdgesEventsFrame","getMouseCaptor","getTouchCaptor","extent","getNodeDisplayData","getEdgeDisplayData","getNodeDisplayedLabels","getEdgeDisplayedLabels","getSettings","setSetting","oldValues","updateSetting","force","previousWidth","previousHeight","allowInvalidContainer","_id","setAttribute","scale","_id2","viewport","WebGLRenderingContext","_this10","fullRefresh","_opts$partialGraph","_opts$partialGraph2","programIndex","_i4","_l4","_programIndex","_this11","viewportTarget","_this$camera$getState","_this$settings2","center","graphMousePosition","graphCenterPosition","viewRectangle","p1","p2","h","x2","y2","coordinates","override","recomputeMatrix","viewportPos","isNaN","viewportToGraph","viewportPoint","inverse","graphPoint","graphP1","graphP2","graphD","viewportP1","viewportP2","viewportD","getBBox","getCustomBBox","setCustomBBox","removeAllListeners","firstChild","removeChild","_type8","_type9","cameraRatio","zoomToSizeRatioFunction","getCanvases","HTMLCanvasElement","default"],"sources":["/Users/fjodoin/Desktop/Research/AzureRT/azure_resource_graph/training/graphing/sigma-graph/node_modules/sigma/dist/sigma.esm.js"],"sourcesContent":["import { _ as _objectSpread2, a as _defineProperty } from './index-236c62ad.esm.js';\nimport { _ as _inherits, a as _createClass, b as _classCallCheck, c as _callSuper, d as _toPropertyKey } from './inherits-d1a1e29b.esm.js';\nimport { TypedEventEmitter } from '../types/dist/sigma-types.esm.js';\nimport { A as ANIMATE_DEFAULTS, e as easings, g as graphExtent, c as createNormalizationFunction, m as matrixFromCamera, z as zIndexOrdering, a as getMatrixImpact, b as createElement, d as getPixelRatio, f as multiplyVec2, i as identity, v as validateGraph } from './normalization-be445518.esm.js';\nimport { DEFAULT_SETTINGS, validateSettings, resolveSettings } from '../settings/dist/sigma-settings.esm.js';\nimport { _ as _slicedToArray, a as _arrayLikeToArray, b as _unsupportedIterableToArray, g as getPixelColor, c as colorToIndex } from './colors-beb06eb2.esm.js';\nimport { _ as _typeof, e as extend } from './data-11df7124.esm.js';\nimport 'events';\nimport 'graphology-utils/is-graph';\n\n/**\n * Defaults.\n */\nvar DEFAULT_ZOOMING_RATIO = 1.5;\n\n/**\n * Event types.\n */\n/**\n * Camera class\n */\nvar Camera = /*#__PURE__*/function (_TypedEventEmitter) {\n  function Camera() {\n    var _this;\n    _classCallCheck(this, Camera);\n    _this = _callSuper(this, Camera);\n\n    // State\n    _defineProperty(_this, \"x\", 0.5);\n    _defineProperty(_this, \"y\", 0.5);\n    _defineProperty(_this, \"angle\", 0);\n    _defineProperty(_this, \"ratio\", 1);\n    _defineProperty(_this, \"minRatio\", null);\n    _defineProperty(_this, \"maxRatio\", null);\n    _defineProperty(_this, \"enabledZooming\", true);\n    _defineProperty(_this, \"enabledPanning\", true);\n    _defineProperty(_this, \"enabledRotation\", true);\n    _defineProperty(_this, \"clean\", null);\n    _defineProperty(_this, \"nextFrame\", null);\n    _defineProperty(_this, \"previousState\", null);\n    _defineProperty(_this, \"enabled\", true);\n    _this.previousState = _this.getState();\n    return _this;\n  }\n\n  /**\n   * Static method used to create a Camera object with a given state.\n   */\n  _inherits(Camera, _TypedEventEmitter);\n  return _createClass(Camera, [{\n    key: \"enable\",\n    value:\n    /**\n     * Method used to enable the camera.\n     */\n    function enable() {\n      this.enabled = true;\n      return this;\n    }\n\n    /**\n     * Method used to disable the camera.\n     */\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n\n    /**\n     * Method used to retrieve the camera's current state.\n     */\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return {\n        x: this.x,\n        y: this.y,\n        angle: this.angle,\n        ratio: this.ratio\n      };\n    }\n\n    /**\n     * Method used to check whether the camera has the given state.\n     */\n  }, {\n    key: \"hasState\",\n    value: function hasState(state) {\n      return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n    }\n\n    /**\n     * Method used to retrieve the camera's previous state.\n     */\n  }, {\n    key: \"getPreviousState\",\n    value: function getPreviousState() {\n      var state = this.previousState;\n      if (!state) return null;\n      return {\n        x: state.x,\n        y: state.y,\n        angle: state.angle,\n        ratio: state.ratio\n      };\n    }\n\n    /**\n     * Method used to check minRatio and maxRatio values.\n     */\n  }, {\n    key: \"getBoundedRatio\",\n    value: function getBoundedRatio(ratio) {\n      var r = ratio;\n      if (typeof this.minRatio === \"number\") r = Math.max(r, this.minRatio);\n      if (typeof this.maxRatio === \"number\") r = Math.min(r, this.maxRatio);\n      return r;\n    }\n\n    /**\n     * Method used to check various things to return a legit state candidate.\n     */\n  }, {\n    key: \"validateState\",\n    value: function validateState(state) {\n      var validatedState = {};\n      if (this.enabledPanning && typeof state.x === \"number\") validatedState.x = state.x;\n      if (this.enabledPanning && typeof state.y === \"number\") validatedState.y = state.y;\n      if (this.enabledZooming && typeof state.ratio === \"number\") validatedState.ratio = this.getBoundedRatio(state.ratio);\n      if (this.enabledRotation && typeof state.angle === \"number\") validatedState.angle = state.angle;\n      return this.clean ? this.clean(_objectSpread2(_objectSpread2({}, this.getState()), validatedState)) : validatedState;\n    }\n\n    /**\n     * Method used to check whether the camera is currently being animated.\n     */\n  }, {\n    key: \"isAnimated\",\n    value: function isAnimated() {\n      return !!this.nextFrame;\n    }\n\n    /**\n     * Method used to set the camera's state.\n     */\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      if (!this.enabled) return this;\n\n      // Keeping track of last state\n      this.previousState = this.getState();\n      var validState = this.validateState(state);\n      if (typeof validState.x === \"number\") this.x = validState.x;\n      if (typeof validState.y === \"number\") this.y = validState.y;\n      if (typeof validState.ratio === \"number\") this.ratio = validState.ratio;\n      if (typeof validState.angle === \"number\") this.angle = validState.angle;\n\n      // Emitting\n      if (!this.hasState(this.previousState)) this.emit(\"updated\", this.getState());\n      return this;\n    }\n\n    /**\n     * Method used to update the camera's state using a function.\n     */\n  }, {\n    key: \"updateState\",\n    value: function updateState(updater) {\n      this.setState(updater(this.getState()));\n      return this;\n    }\n\n    /**\n     * Method used to animate the camera.\n     */\n  }, {\n    key: \"animate\",\n    value: function animate(state) {\n      var _this2 = this;\n      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var callback = arguments.length > 2 ? arguments[2] : undefined;\n      if (!callback) return new Promise(function (resolve) {\n        return _this2.animate(state, opts, resolve);\n      });\n      if (!this.enabled) return;\n      var options = _objectSpread2(_objectSpread2({}, ANIMATE_DEFAULTS), opts);\n      var validState = this.validateState(state);\n      var easing = typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n\n      // State\n      var start = Date.now(),\n        initialState = this.getState();\n\n      // Function performing the animation\n      var _fn = function fn() {\n        var t = (Date.now() - start) / options.duration;\n\n        // The animation is over:\n        if (t >= 1) {\n          _this2.nextFrame = null;\n          _this2.setState(validState);\n          if (_this2.animationCallback) {\n            _this2.animationCallback.call(null);\n            _this2.animationCallback = undefined;\n          }\n          return;\n        }\n        var coefficient = easing(t);\n        var newState = {};\n        if (typeof validState.x === \"number\") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n        if (typeof validState.y === \"number\") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n        if (_this2.enabledRotation && typeof validState.angle === \"number\") newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n        if (typeof validState.ratio === \"number\") newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n        _this2.setState(newState);\n        _this2.nextFrame = requestAnimationFrame(_fn);\n      };\n      if (this.nextFrame) {\n        cancelAnimationFrame(this.nextFrame);\n        if (this.animationCallback) this.animationCallback.call(null);\n        this.nextFrame = requestAnimationFrame(_fn);\n      } else {\n        _fn();\n      }\n      this.animationCallback = callback;\n    }\n\n    /**\n     * Method used to zoom the camera.\n     */\n  }, {\n    key: \"animatedZoom\",\n    value: function animatedZoom(factorOrOptions) {\n      if (!factorOrOptions) return this.animate({\n        ratio: this.ratio / DEFAULT_ZOOMING_RATIO\n      });\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio / factorOrOptions\n      });\n      return this.animate({\n        ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n\n    /**\n     * Method used to unzoom the camera.\n     */\n  }, {\n    key: \"animatedUnzoom\",\n    value: function animatedUnzoom(factorOrOptions) {\n      if (!factorOrOptions) return this.animate({\n        ratio: this.ratio * DEFAULT_ZOOMING_RATIO\n      });\n      if (typeof factorOrOptions === \"number\") return this.animate({\n        ratio: this.ratio * factorOrOptions\n      });\n      return this.animate({\n        ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n      }, factorOrOptions);\n    }\n\n    /**\n     * Method used to reset the camera.\n     */\n  }, {\n    key: \"animatedReset\",\n    value: function animatedReset(options) {\n      return this.animate({\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0\n      }, options);\n    }\n\n    /**\n     * Returns a new Camera instance, with the same state as the current camera.\n     */\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return Camera.from(this.getState());\n    }\n  }], [{\n    key: \"from\",\n    value: function from(state) {\n      var camera = new Camera();\n      return camera.setState(state);\n    }\n  }]);\n}(TypedEventEmitter);\n\n/**\n * Captor utils functions\n * ======================\n */\n\n/**\n * Extract the local X and Y coordinates from a mouse event or touch object. If\n * a DOM element is given, it uses this element's offset to compute the position\n * (this allows using events that are not bound to the container itself and\n * still have a proper position).\n *\n * @param  {event}       e - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {number}      The local Y value of the mouse.\n */\nfunction getPosition(e, dom) {\n  var bbox = dom.getBoundingClientRect();\n  return {\n    x: e.clientX - bbox.left,\n    y: e.clientY - bbox.top\n  };\n}\n\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}       e   - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getMouseCoords(e, dom) {\n  var res = _objectSpread2(_objectSpread2({}, getPosition(e, dom)), {}, {\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault: function preventSigmaDefault() {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e\n  });\n  return res;\n}\n\n/**\n * Takes a touch coords or a mouse coords, and always returns a clean mouse coords object.\n */\nfunction cleanMouseCoords(e) {\n  var res = \"x\" in e ? e : _objectSpread2(_objectSpread2({}, e.touches[0] || e.previousTouches[0]), {}, {\n    original: e.original,\n    sigmaDefaultPrevented: e.sigmaDefaultPrevented,\n    preventSigmaDefault: function preventSigmaDefault() {\n      e.sigmaDefaultPrevented = true;\n      res.sigmaDefaultPrevented = true;\n    }\n  });\n  return res;\n}\n\n/**\n * Convert mouse wheel event coords to sigma coords.\n *\n * @param  {event}       e   - A wheel mouse event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getWheelCoords(e, dom) {\n  return _objectSpread2(_objectSpread2({}, getMouseCoords(e, dom)), {}, {\n    delta: getWheelDelta(e)\n  });\n}\nvar MAX_TOUCHES = 2;\nfunction getTouchesArray(touches) {\n  var arr = [];\n  for (var i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);\n  return arr;\n}\n\n/**\n * Convert touch coords to sigma coords.\n *\n * @param  {event}       e               - A touch event.\n * @param  {Touch[]}     previousTouches - An array of the previously stored touches.\n * @param  {HTMLElement} dom             - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getTouchCoords(e, previousTouches, dom) {\n  var res = {\n    touches: getTouchesArray(e.touches).map(function (touch) {\n      return getPosition(touch, dom);\n    }),\n    previousTouches: previousTouches.map(function (touch) {\n      return getPosition(touch, dom);\n    }),\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault: function preventSigmaDefault() {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e\n  };\n  return res;\n}\n\n/**\n * Extract the wheel delta from a mouse event or touch object.\n *\n * @param  {event}  e - A mouse event or touch object.\n * @return {number}     The wheel delta of the mouse.\n */\nfunction getWheelDelta(e) {\n  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat\n  if (typeof e.deltaY !== \"undefined\") return e.deltaY * -3 / 360;\n  if (typeof e.detail !== \"undefined\") return e.detail / -9;\n  throw new Error(\"Captor: could not extract delta from event.\");\n}\n\n/**\n * Abstract class representing a captor like the user's mouse or touch controls.\n */\nvar Captor = /*#__PURE__*/function (_TypedEventEmitter) {\n  function Captor(container, renderer) {\n    var _this;\n    _classCallCheck(this, Captor);\n    _this = _callSuper(this, Captor);\n    // Properties\n    _this.container = container;\n    _this.renderer = renderer;\n    return _this;\n  }\n  _inherits(Captor, _TypedEventEmitter);\n  return _createClass(Captor);\n}(TypedEventEmitter);\n\nvar MOUSE_SETTINGS_KEYS = [\"doubleClickTimeout\", \"doubleClickZoomingDuration\", \"doubleClickZoomingRatio\", \"dragTimeout\", \"draggedEventsTolerance\", \"inertiaDuration\", \"inertiaRatio\", \"zoomDuration\", \"zoomingRatio\"];\nvar DEFAULT_MOUSE_SETTINGS = MOUSE_SETTINGS_KEYS.reduce(function (iter, key) {\n  return _objectSpread2(_objectSpread2({}, iter), {}, _defineProperty({}, key, DEFAULT_SETTINGS[key]));\n}, {});\n\n/**\n * Event types.\n */\n/**\n * Mouse captor class.\n *\n * @constructor\n */\nvar MouseCaptor = /*#__PURE__*/function (_Captor) {\n  function MouseCaptor(container, renderer) {\n    var _this;\n    _classCallCheck(this, MouseCaptor);\n    _this = _callSuper(this, MouseCaptor, [container, renderer]);\n\n    // Binding methods\n    // State\n    _defineProperty(_this, \"enabled\", true);\n    _defineProperty(_this, \"draggedEvents\", 0);\n    _defineProperty(_this, \"downStartTime\", null);\n    _defineProperty(_this, \"lastMouseX\", null);\n    _defineProperty(_this, \"lastMouseY\", null);\n    _defineProperty(_this, \"isMouseDown\", false);\n    _defineProperty(_this, \"isMoving\", false);\n    _defineProperty(_this, \"movingTimeout\", null);\n    _defineProperty(_this, \"startCameraState\", null);\n    _defineProperty(_this, \"clicks\", 0);\n    _defineProperty(_this, \"doubleClickTimeout\", null);\n    _defineProperty(_this, \"currentWheelDirection\", 0);\n    _defineProperty(_this, \"settings\", DEFAULT_MOUSE_SETTINGS);\n    _this.handleClick = _this.handleClick.bind(_this);\n    _this.handleRightClick = _this.handleRightClick.bind(_this);\n    _this.handleDown = _this.handleDown.bind(_this);\n    _this.handleUp = _this.handleUp.bind(_this);\n    _this.handleMove = _this.handleMove.bind(_this);\n    _this.handleWheel = _this.handleWheel.bind(_this);\n    _this.handleLeave = _this.handleLeave.bind(_this);\n    _this.handleEnter = _this.handleEnter.bind(_this);\n\n    // Binding events\n    container.addEventListener(\"click\", _this.handleClick, {\n      capture: false\n    });\n    container.addEventListener(\"contextmenu\", _this.handleRightClick, {\n      capture: false\n    });\n    container.addEventListener(\"mousedown\", _this.handleDown, {\n      capture: false\n    });\n    container.addEventListener(\"wheel\", _this.handleWheel, {\n      capture: false\n    });\n    container.addEventListener(\"mouseleave\", _this.handleLeave, {\n      capture: false\n    });\n    container.addEventListener(\"mouseenter\", _this.handleEnter, {\n      capture: false\n    });\n    document.addEventListener(\"mousemove\", _this.handleMove, {\n      capture: false\n    });\n    document.addEventListener(\"mouseup\", _this.handleUp, {\n      capture: false\n    });\n    return _this;\n  }\n  _inherits(MouseCaptor, _Captor);\n  return _createClass(MouseCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"click\", this.handleClick);\n      container.removeEventListener(\"contextmenu\", this.handleRightClick);\n      container.removeEventListener(\"mousedown\", this.handleDown);\n      container.removeEventListener(\"wheel\", this.handleWheel);\n      container.removeEventListener(\"mouseleave\", this.handleLeave);\n      container.removeEventListener(\"mouseenter\", this.handleEnter);\n      document.removeEventListener(\"mousemove\", this.handleMove);\n      document.removeEventListener(\"mouseup\", this.handleUp);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      this.clicks++;\n      if (this.clicks === 2) {\n        this.clicks = 0;\n        if (typeof this.doubleClickTimeout === \"number\") {\n          clearTimeout(this.doubleClickTimeout);\n          this.doubleClickTimeout = null;\n        }\n        return this.handleDoubleClick(e);\n      }\n      setTimeout(function () {\n        _this2.clicks = 0;\n        _this2.doubleClickTimeout = null;\n      }, this.settings.doubleClickTimeout);\n\n      // NOTE: this is here to prevent click events on drag\n      if (this.draggedEvents < this.settings.draggedEventsTolerance) this.emit(\"click\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleRightClick\",\n    value: function handleRightClick(e) {\n      if (!this.enabled) return;\n      this.emit(\"rightClick\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleDoubleClick\",\n    value: function handleDoubleClick(e) {\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var mouseCoords = getMouseCoords(e, this.container);\n      this.emit(\"doubleClick\", mouseCoords);\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // default behavior\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio / this.settings.doubleClickZoomingRatio);\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticInOut\",\n        duration: this.settings.doubleClickZoomingDuration\n      });\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(e) {\n      if (!this.enabled) return;\n\n      // We only start dragging on left button\n      if (e.button === 0) {\n        this.startCameraState = this.renderer.getCamera().getState();\n        var _getPosition = getPosition(e, this.container),\n          x = _getPosition.x,\n          y = _getPosition.y;\n        this.lastMouseX = x;\n        this.lastMouseY = y;\n        this.draggedEvents = 0;\n        this.downStartTime = Date.now();\n        this.isMouseDown = true;\n      }\n      this.emit(\"mousedown\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleUp\",\n    value: function handleUp(e) {\n      var _this3 = this;\n      if (!this.enabled || !this.isMouseDown) return;\n      var camera = this.renderer.getCamera();\n      this.isMouseDown = false;\n      if (typeof this.movingTimeout === \"number\") {\n        clearTimeout(this.movingTimeout);\n        this.movingTimeout = null;\n      }\n      var _getPosition2 = getPosition(e, this.container),\n        x = _getPosition2.x,\n        y = _getPosition2.y;\n      var cameraState = camera.getState(),\n        previousCameraState = camera.getPreviousState() || {\n          x: 0,\n          y: 0\n        };\n      if (this.isMoving) {\n        camera.animate({\n          x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)\n        }, {\n          duration: this.settings.inertiaDuration,\n          easing: \"quadraticOut\"\n        });\n      } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n        camera.setState({\n          x: cameraState.x,\n          y: cameraState.y\n        });\n      }\n      this.isMoving = false;\n      setTimeout(function () {\n        var shouldRefresh = _this3.draggedEvents > 0;\n        _this3.draggedEvents = 0;\n\n        // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work\n        // when someone releases camera pan drag after having stopped moving.\n        // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2\n        // See also issue: https://github.com/jacomyal/sigma.js/issues/1290\n        // It could be possible to render instead of scheduling a refresh but for\n        // now it seems good enough.\n        if (shouldRefresh && _this3.renderer.getSetting(\"hideEdgesOnMove\")) _this3.renderer.refresh();\n      }, 0);\n      this.emit(\"mouseup\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this4 = this;\n      if (!this.enabled) return;\n      var mouseCoords = getMouseCoords(e, this.container);\n\n      // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n      // a drag-and-drop effect that works even when the mouse is out of the\n      // container:\n      this.emit(\"mousemovebody\", mouseCoords);\n\n      // Only trigger the \"mousemove\" event when the mouse is actually hovering\n      // the container, to avoid weirdly hovering nodes and/or edges when the\n      // mouse is not hover the container:\n      if (e.target === this.container || e.composedPath()[0] === this.container) {\n        this.emit(\"mousemove\", mouseCoords);\n      }\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n      // stage while the mouse is not hover the container:\n      if (this.isMouseDown) {\n        this.isMoving = true;\n        this.draggedEvents++;\n        if (typeof this.movingTimeout === \"number\") {\n          clearTimeout(this.movingTimeout);\n        }\n        this.movingTimeout = window.setTimeout(function () {\n          _this4.movingTimeout = null;\n          _this4.isMoving = false;\n        }, this.settings.dragTimeout);\n        var camera = this.renderer.getCamera();\n        var _getPosition3 = getPosition(e, this.container),\n          eX = _getPosition3.x,\n          eY = _getPosition3.y;\n        var lastMouse = this.renderer.viewportToFramedGraph({\n          x: this.lastMouseX,\n          y: this.lastMouseY\n        });\n        var mouse = this.renderer.viewportToFramedGraph({\n          x: eX,\n          y: eY\n        });\n        var offsetX = lastMouse.x - mouse.x,\n          offsetY = lastMouse.y - mouse.y;\n        var cameraState = camera.getState();\n        var x = cameraState.x + offsetX,\n          y = cameraState.y + offsetY;\n        camera.setState({\n          x: x,\n          y: y\n        });\n        this.lastMouseX = eX;\n        this.lastMouseY = eY;\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      this.emit(\"mouseleave\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleEnter\",\n    value: function handleEnter(e) {\n      this.emit(\"mouseenter\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(e) {\n      var _this5 = this;\n      var camera = this.renderer.getCamera();\n      if (!this.enabled || !camera.enabledZooming) return;\n      var delta = getWheelDelta(e);\n      if (!delta) return;\n      var wheelCoords = getWheelCoords(e, this.container);\n      this.emit(\"wheel\", wheelCoords);\n      if (wheelCoords.sigmaDefaultPrevented) {\n        e.preventDefault();\n        e.stopPropagation();\n        return;\n      }\n\n      // Default behavior\n      var currentRatio = camera.getState().ratio;\n      var ratioDiff = delta > 0 ? 1 / this.settings.zoomingRatio : this.settings.zoomingRatio;\n      var newRatio = camera.getBoundedRatio(currentRatio * ratioDiff);\n      var wheelDirection = delta > 0 ? 1 : -1;\n      var now = Date.now();\n\n      // Exit early without preventing default behavior when ratio doesn't change:\n      if (currentRatio === newRatio) return;\n      e.preventDefault();\n      e.stopPropagation();\n\n      // Cancel events that are too close each other and in the same direction:\n      if (this.currentWheelDirection === wheelDirection && this.lastWheelTriggerTime && now - this.lastWheelTriggerTime < this.settings.zoomDuration / 5) {\n        return;\n      }\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticOut\",\n        duration: this.settings.zoomDuration\n      }, function () {\n        _this5.currentWheelDirection = 0;\n      });\n      this.currentWheelDirection = wheelDirection;\n      this.lastWheelTriggerTime = now;\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      this.settings = settings;\n    }\n  }]);\n}(Captor);\n\nvar TOUCH_SETTINGS_KEYS = [\"dragTimeout\", \"inertiaDuration\", \"inertiaRatio\", \"doubleClickTimeout\", \"doubleClickZoomingRatio\", \"doubleClickZoomingDuration\", \"tapMoveTolerance\"];\nvar DEFAULT_TOUCH_SETTINGS = TOUCH_SETTINGS_KEYS.reduce(function (iter, key) {\n  return _objectSpread2(_objectSpread2({}, iter), {}, _defineProperty({}, key, DEFAULT_SETTINGS[key]));\n}, {});\n\n/**\n * Event types.\n */\n/**\n * Touch captor class.\n *\n * @constructor\n */\nvar TouchCaptor = /*#__PURE__*/function (_Captor) {\n  function TouchCaptor(container, renderer) {\n    var _this;\n    _classCallCheck(this, TouchCaptor);\n    _this = _callSuper(this, TouchCaptor, [container, renderer]);\n\n    // Binding methods:\n    _defineProperty(_this, \"enabled\", true);\n    _defineProperty(_this, \"isMoving\", false);\n    _defineProperty(_this, \"hasMoved\", false);\n    _defineProperty(_this, \"touchMode\", 0);\n    _defineProperty(_this, \"startTouchesPositions\", []);\n    _defineProperty(_this, \"lastTouches\", []);\n    _defineProperty(_this, \"lastTap\", null);\n    _defineProperty(_this, \"settings\", DEFAULT_TOUCH_SETTINGS);\n    _this.handleStart = _this.handleStart.bind(_this);\n    _this.handleLeave = _this.handleLeave.bind(_this);\n    _this.handleMove = _this.handleMove.bind(_this);\n\n    // Binding events\n    container.addEventListener(\"touchstart\", _this.handleStart, {\n      capture: false\n    });\n    container.addEventListener(\"touchcancel\", _this.handleLeave, {\n      capture: false\n    });\n    document.addEventListener(\"touchend\", _this.handleLeave, {\n      capture: false,\n      passive: false\n    });\n    document.addEventListener(\"touchmove\", _this.handleMove, {\n      capture: false,\n      passive: false\n    });\n    return _this;\n  }\n  _inherits(TouchCaptor, _Captor);\n  return _createClass(TouchCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"touchstart\", this.handleStart);\n      container.removeEventListener(\"touchcancel\", this.handleLeave);\n      document.removeEventListener(\"touchend\", this.handleLeave);\n      document.removeEventListener(\"touchmove\", this.handleMove);\n    }\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.container.offsetWidth,\n        height: this.container.offsetHeight\n      };\n    }\n  }, {\n    key: \"handleStart\",\n    value: function handleStart(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      e.preventDefault();\n      var touches = getTouchesArray(e.touches);\n      this.touchMode = touches.length;\n      this.startCameraState = this.renderer.getCamera().getState();\n      this.startTouchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this2.container);\n      });\n\n      // When there are two touches down, let's record distance and angle as well:\n      if (this.touchMode === 2) {\n        var _this$startTouchesPos = _slicedToArray(this.startTouchesPositions, 2),\n          _this$startTouchesPos2 = _this$startTouchesPos[0],\n          x0 = _this$startTouchesPos2.x,\n          y0 = _this$startTouchesPos2.y,\n          _this$startTouchesPos3 = _this$startTouchesPos[1],\n          x1 = _this$startTouchesPos3.x,\n          y1 = _this$startTouchesPos3.y;\n        this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);\n        this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n      }\n      this.emit(\"touchdown\", getTouchCoords(e, this.lastTouches, this.container));\n      this.lastTouches = touches;\n      this.lastTouchesPositions = this.startTouchesPositions;\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      if (!this.enabled || !this.startTouchesPositions.length) return;\n      if (e.cancelable) e.preventDefault();\n      if (this.movingTimeout) {\n        this.isMoving = false;\n        clearTimeout(this.movingTimeout);\n      }\n      switch (this.touchMode) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        case 2:\n          if (e.touches.length === 1) {\n            this.handleStart(e);\n            e.preventDefault();\n            break;\n          }\n        /* falls through */\n        case 1:\n          if (this.isMoving) {\n            var camera = this.renderer.getCamera();\n            var cameraState = camera.getState(),\n              previousCameraState = camera.getPreviousState() || {\n                x: 0,\n                y: 0\n              };\n            camera.animate({\n              x: cameraState.x + this.settings.inertiaRatio * (cameraState.x - previousCameraState.x),\n              y: cameraState.y + this.settings.inertiaRatio * (cameraState.y - previousCameraState.y)\n            }, {\n              duration: this.settings.inertiaDuration,\n              easing: \"quadraticOut\"\n            });\n          }\n          this.hasMoved = false;\n          this.isMoving = false;\n          this.touchMode = 0;\n          break;\n      }\n      this.emit(\"touchup\", getTouchCoords(e, this.lastTouches, this.container));\n\n      // When the last touch ends and there hasn't been too much movement, trigger a \"tap\" or \"doubletap\" event:\n      if (!e.touches.length) {\n        var position = getPosition(this.lastTouches[0], this.container);\n        var downPosition = this.startTouchesPositions[0];\n        var dSquare = Math.pow(position.x - downPosition.x, 2) + Math.pow(position.y - downPosition.y, 2);\n        if (!e.touches.length && dSquare < Math.pow(this.settings.tapMoveTolerance, 2)) {\n          // Only trigger \"doubletap\" when the last tap is recent enough:\n          if (this.lastTap && Date.now() - this.lastTap.time < this.settings.doubleClickTimeout) {\n            var touchCoords = getTouchCoords(e, this.lastTouches, this.container);\n            this.emit(\"doubletap\", touchCoords);\n            this.lastTap = null;\n            if (!touchCoords.sigmaDefaultPrevented) {\n              var _camera = this.renderer.getCamera();\n              var newRatio = _camera.getBoundedRatio(_camera.getState().ratio / this.settings.doubleClickZoomingRatio);\n              _camera.animate(this.renderer.getViewportZoomedState(position, newRatio), {\n                easing: \"quadraticInOut\",\n                duration: this.settings.doubleClickZoomingDuration\n              });\n            }\n          }\n          // Else, trigger a normal \"tap\" event:\n          else {\n            var _touchCoords = getTouchCoords(e, this.lastTouches, this.container);\n            this.emit(\"tap\", _touchCoords);\n            this.lastTap = {\n              time: Date.now(),\n              position: _touchCoords.touches[0] || _touchCoords.previousTouches[0]\n            };\n          }\n        }\n      }\n      this.lastTouches = getTouchesArray(e.touches);\n      this.startTouchesPositions = [];\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this3 = this;\n      if (!this.enabled || !this.startTouchesPositions.length) return;\n      e.preventDefault();\n      var touches = getTouchesArray(e.touches);\n      var touchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this3.container);\n      });\n      var lastTouches = this.lastTouches;\n      this.lastTouches = touches;\n      this.lastTouchesPositions = touchesPositions;\n      var touchCoords = getTouchCoords(e, lastTouches, this.container);\n      this.emit(\"touchmove\", touchCoords);\n      if (touchCoords.sigmaDefaultPrevented) return;\n\n      // If a move was initiated at some point, and we get back to start point,\n      // we should still consider that we did move (which also happens after a\n      // multiple touch when only one touch remains in which case handleStart\n      // is recalled within handleLeave).\n      // Now, some mobile browsers report zero-distance moves so we also check that\n      // one of the touches did actually move from the origin position.\n      this.hasMoved || (this.hasMoved = touchesPositions.some(function (position, idx) {\n        var startPosition = _this3.startTouchesPositions[idx];\n        return startPosition && (position.x !== startPosition.x || position.y !== startPosition.y);\n      }));\n\n      // If there was no move, do not trigger touch moves behavior\n      if (!this.hasMoved) {\n        return;\n      }\n      this.isMoving = true;\n      if (this.movingTimeout) clearTimeout(this.movingTimeout);\n      this.movingTimeout = window.setTimeout(function () {\n        _this3.isMoving = false;\n      }, this.settings.dragTimeout);\n      var camera = this.renderer.getCamera();\n      var startCameraState = this.startCameraState;\n      var padding = this.renderer.getSetting(\"stagePadding\");\n      switch (this.touchMode) {\n        case 1:\n          {\n            var _this$renderer$viewpo = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]),\n              xStart = _this$renderer$viewpo.x,\n              yStart = _this$renderer$viewpo.y;\n            var _this$renderer$viewpo2 = this.renderer.viewportToFramedGraph(touchesPositions[0]),\n              x = _this$renderer$viewpo2.x,\n              y = _this$renderer$viewpo2.y;\n            camera.setState({\n              x: startCameraState.x + xStart - x,\n              y: startCameraState.y + yStart - y\n            });\n            break;\n          }\n        case 2:\n          {\n            /**\n             * Here is the thinking here:\n             *\n             * 1. We can find the new angle and ratio, by comparing the vector from \"touch one\" to \"touch two\" at the start\n             *    of the d'n'd and now\n             *\n             * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph\n             *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport\n             *    position of this same touch now\n             */\n            var newCameraState = {\n              x: 0.5,\n              y: 0.5,\n              angle: 0,\n              ratio: 1\n            };\n            var _touchesPositions$ = touchesPositions[0],\n              x0 = _touchesPositions$.x,\n              y0 = _touchesPositions$.y;\n            var _touchesPositions$2 = touchesPositions[1],\n              x1 = _touchesPositions$2.x,\n              y1 = _touchesPositions$2.y;\n            var angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;\n            var ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;\n\n            // 1.\n            var newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);\n            newCameraState.ratio = newRatio;\n            newCameraState.angle = startCameraState.angle + angleDiff;\n\n            // 2.\n            var dimensions = this.getDimensions();\n            var touchGraphPosition = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], {\n              cameraState: startCameraState\n            });\n            var smallestDimension = Math.min(dimensions.width, dimensions.height) - 2 * padding;\n            var dx = smallestDimension / dimensions.width;\n            var dy = smallestDimension / dimensions.height;\n            var ratio = newRatio / smallestDimension;\n\n            // Align with center of the graph:\n            var _x = x0 - smallestDimension / 2 / dx;\n            var _y = y0 - smallestDimension / 2 / dy;\n\n            // Rotate:\n            var _ref = [_x * Math.cos(-newCameraState.angle) - _y * Math.sin(-newCameraState.angle), _y * Math.cos(-newCameraState.angle) + _x * Math.sin(-newCameraState.angle)];\n            _x = _ref[0];\n            _y = _ref[1];\n            newCameraState.x = touchGraphPosition.x - _x * ratio;\n            newCameraState.y = touchGraphPosition.y + _y * ratio;\n            camera.setState(newCameraState);\n            break;\n          }\n      }\n    }\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      this.settings = settings;\n    }\n  }]);\n}(Captor);\n\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\n\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\n\nfunction _objectWithoutPropertiesLoose(r, e) {\n  if (null == r) return {};\n  var t = {};\n  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {\n    if (e.includes(n)) continue;\n    t[n] = r[n];\n  }\n  return t;\n}\n\nfunction _objectWithoutProperties(e, t) {\n  if (null == e) return {};\n  var o,\n    r,\n    i = _objectWithoutPropertiesLoose(e, t);\n  if (Object.getOwnPropertySymbols) {\n    var s = Object.getOwnPropertySymbols(e);\n    for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);\n  }\n  return i;\n}\n\n/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscellaneous heuristics related to label display.\n * @module\n */\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /*#__PURE__*/function () {\n  function LabelCandidate(key, size) {\n    _classCallCheck(this, LabelCandidate);\n    this.key = key;\n    this.size = size;\n  }\n  return _createClass(LabelCandidate, null, [{\n    key: \"compare\",\n    value: function compare(first, second) {\n      // First we compare by size\n      if (first.size > second.size) return -1;\n      if (first.size < second.size) return 1;\n\n      // Then since no two nodes can have the same key, we use it to\n      // deterministically tie-break by key\n      if (first.key > second.key) return 1;\n\n      // NOTE: this comparator cannot return 0\n      return -1;\n    }\n  }]);\n}();\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /*#__PURE__*/function () {\n  function LabelGrid() {\n    _classCallCheck(this, LabelGrid);\n    _defineProperty(this, \"width\", 0);\n    _defineProperty(this, \"height\", 0);\n    _defineProperty(this, \"cellSize\", 0);\n    _defineProperty(this, \"columns\", 0);\n    _defineProperty(this, \"rows\", 0);\n    _defineProperty(this, \"cells\", {});\n  }\n  return _createClass(LabelGrid, [{\n    key: \"resizeAndClear\",\n    value: function resizeAndClear(dimensions, cellSize) {\n      this.width = dimensions.width;\n      this.height = dimensions.height;\n      this.cellSize = cellSize;\n      this.columns = Math.ceil(dimensions.width / cellSize);\n      this.rows = Math.ceil(dimensions.height / cellSize);\n      this.cells = {};\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(pos) {\n      var xIndex = Math.floor(pos.x / this.cellSize);\n      var yIndex = Math.floor(pos.y / this.cellSize);\n      return yIndex * this.columns + xIndex;\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, size, pos) {\n      var candidate = new LabelCandidate(key, size);\n      var index = this.getIndex(pos);\n      var cell = this.cells[index];\n      if (!cell) {\n        cell = [];\n        this.cells[index] = cell;\n      }\n      cell.push(candidate);\n    }\n  }, {\n    key: \"organize\",\n    value: function organize() {\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        cell.sort(LabelCandidate.compare);\n      }\n    }\n  }, {\n    key: \"getLabelsToDisplay\",\n    value: function getLabelsToDisplay(ratio, density) {\n      // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n      // TODO: adjust threshold lower, but increase cells a bit?\n      // TODO: hunt for geom issue in disguise\n      // TODO: memoize while ratio does not move. method to force recompute\n      var cellArea = this.cellSize * this.cellSize;\n      var scaledCellArea = cellArea / ratio / ratio;\n      var scaledDensity = scaledCellArea * density / cellArea;\n      var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n      var labels = [];\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n          labels.push(cell[i].key);\n        }\n      }\n      return labels;\n    }\n  }]);\n}();\n\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n  var graph = params.graph,\n    hoveredNode = params.hoveredNode,\n    highlightedNodes = params.highlightedNodes,\n    displayedNodeLabels = params.displayedNodeLabels;\n  var worthyEdges = [];\n\n  // TODO: the code below can be optimized using #.forEach and batching the code per adj\n\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n  graph.forEachEdge(function (edge, _, source, target) {\n    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {\n      worthyEdges.push(edge);\n    }\n  });\n  return worthyEdges;\n}\n\n/**\n * Constants.\n */\nvar X_LABEL_MARGIN = 150;\nvar Y_LABEL_MARGIN = 50;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n  if (!hasOwnProperty.call(data, \"x\") || !hasOwnProperty.call(data, \"y\")) throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n  if (!data.color) data.color = settings.defaultNodeColor;\n  if (!data.label && data.label !== \"\") data.label = null;\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;else data.label = null;\n  if (!data.size) data.size = 2;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"highlighted\")) data.highlighted = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\nfunction applyEdgeDefaults(settings, _key, data) {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n  if (!data.label) data.label = \"\";\n  if (!data.size) data.size = 0.5;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma$1 = /*#__PURE__*/function (_TypedEventEmitter) {\n  function Sigma(graph, container) {\n    var _this;\n    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    _classCallCheck(this, Sigma);\n    _this = _callSuper(this, Sigma);\n\n    // Resolving settings\n    _defineProperty(_this, \"elements\", {});\n    _defineProperty(_this, \"canvasContexts\", {});\n    _defineProperty(_this, \"webGLContexts\", {});\n    _defineProperty(_this, \"pickingLayers\", new Set());\n    _defineProperty(_this, \"textures\", {});\n    _defineProperty(_this, \"frameBuffers\", {});\n    _defineProperty(_this, \"activeListeners\", {});\n    _defineProperty(_this, \"labelGrid\", new LabelGrid());\n    _defineProperty(_this, \"nodeDataCache\", {});\n    _defineProperty(_this, \"edgeDataCache\", {});\n    // Indices to keep track of the index of the item inside programs\n    _defineProperty(_this, \"nodeProgramIndex\", {});\n    _defineProperty(_this, \"edgeProgramIndex\", {});\n    _defineProperty(_this, \"nodesWithForcedLabels\", new Set());\n    _defineProperty(_this, \"edgesWithForcedLabels\", new Set());\n    _defineProperty(_this, \"nodeExtent\", {\n      x: [0, 1],\n      y: [0, 1]\n    });\n    _defineProperty(_this, \"nodeZExtent\", [Infinity, -Infinity]);\n    _defineProperty(_this, \"edgeZExtent\", [Infinity, -Infinity]);\n    _defineProperty(_this, \"matrix\", identity());\n    _defineProperty(_this, \"invMatrix\", identity());\n    _defineProperty(_this, \"correctionRatio\", 1);\n    _defineProperty(_this, \"customBBox\", null);\n    _defineProperty(_this, \"normalizationFunction\", createNormalizationFunction({\n      x: [0, 1],\n      y: [0, 1]\n    }));\n    // Cache:\n    _defineProperty(_this, \"graphToViewportRatio\", 1);\n    _defineProperty(_this, \"itemIDsIndex\", {});\n    _defineProperty(_this, \"nodeIndices\", {});\n    _defineProperty(_this, \"edgeIndices\", {});\n    // Starting dimensions and pixel ratio\n    _defineProperty(_this, \"width\", 0);\n    _defineProperty(_this, \"height\", 0);\n    _defineProperty(_this, \"pixelRatio\", getPixelRatio());\n    _defineProperty(_this, \"pickingDownSizingRatio\", 2 * _this.pixelRatio);\n    // Graph State\n    _defineProperty(_this, \"displayedNodeLabels\", new Set());\n    _defineProperty(_this, \"displayedEdgeLabels\", new Set());\n    _defineProperty(_this, \"highlightedNodes\", new Set());\n    _defineProperty(_this, \"hoveredNode\", null);\n    _defineProperty(_this, \"hoveredEdge\", null);\n    // Internal states\n    _defineProperty(_this, \"renderFrame\", null);\n    _defineProperty(_this, \"renderHighlightedNodesFrame\", null);\n    _defineProperty(_this, \"needToProcess\", false);\n    _defineProperty(_this, \"checkEdgesEventsFrame\", null);\n    // Programs\n    _defineProperty(_this, \"nodePrograms\", {});\n    _defineProperty(_this, \"nodeHoverPrograms\", {});\n    _defineProperty(_this, \"edgePrograms\", {});\n    _this.settings = resolveSettings(settings);\n\n    // Validating\n    validateSettings(_this.settings);\n    validateGraph(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n\n    // Properties\n    _this.graph = graph;\n    _this.container = container;\n\n    // Initializing contexts\n    _this.createWebGLContext(\"edges\", {\n      picking: settings.enableEdgeEvents\n    });\n    _this.createCanvasContext(\"edgeLabels\");\n    _this.createWebGLContext(\"nodes\", {\n      picking: true\n    });\n    _this.createCanvasContext(\"labels\");\n    _this.createCanvasContext(\"hovers\");\n    _this.createWebGLContext(\"hoverNodes\");\n    _this.createCanvasContext(\"mouse\", {\n      style: {\n        touchAction: \"none\",\n        userSelect: \"none\"\n      }\n    });\n\n    // Initial resize\n    _this.resize();\n\n    // Loading programs\n    for (var type in _this.settings.nodeProgramClasses) {\n      _this.registerNodeProgram(type, _this.settings.nodeProgramClasses[type], _this.settings.nodeHoverProgramClasses[type]);\n    }\n    for (var _type in _this.settings.edgeProgramClasses) {\n      _this.registerEdgeProgram(_type, _this.settings.edgeProgramClasses[_type]);\n    }\n\n    // Initializing the camera\n    _this.camera = new Camera();\n\n    // Binding camera events\n    _this.bindCameraHandlers();\n\n    // Initializing captors\n    _this.mouseCaptor = new MouseCaptor(_this.elements.mouse, _this);\n    _this.mouseCaptor.setSettings(_this.settings);\n    _this.touchCaptor = new TouchCaptor(_this.elements.mouse, _this);\n    _this.touchCaptor.setSettings(_this.settings);\n\n    // Binding event handlers\n    _this.bindEventHandlers();\n\n    // Binding graph handlers\n    _this.bindGraphHandlers();\n\n    // Trigger eventual settings-related things\n    _this.handleSettingsUpdate();\n\n    // Processing data for the first time & render\n    _this.refresh();\n    return _this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to register a node program\n   *\n   * @param  {string}           key              - The program's key, matching the related nodes \"type\" values.\n   * @param  {NodeProgramType}  NodeProgramClass - A nodes program class.\n   * @param  {NodeProgramType?} NodeHoverProgram - A nodes program class to render hovered nodes (optional).\n   * @return {Sigma}\n   */\n  _inherits(Sigma, _TypedEventEmitter);\n  return _createClass(Sigma, [{\n    key: \"registerNodeProgram\",\n    value: function registerNodeProgram(key, NodeProgramClass, NodeHoverProgram) {\n      if (this.nodePrograms[key]) this.nodePrograms[key].kill();\n      if (this.nodeHoverPrograms[key]) this.nodeHoverPrograms[key].kill();\n      this.nodePrograms[key] = new NodeProgramClass(this.webGLContexts.nodes, this.frameBuffers.nodes, this);\n      this.nodeHoverPrograms[key] = new (NodeHoverProgram || NodeProgramClass)(this.webGLContexts.hoverNodes, null, this);\n      return this;\n    }\n\n    /**\n     * Internal function used to register an edge program\n     *\n     * @param  {string}          key              - The program's key, matching the related edges \"type\" values.\n     * @param  {EdgeProgramType} EdgeProgramClass - An edges program class.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"registerEdgeProgram\",\n    value: function registerEdgeProgram(key, EdgeProgramClass) {\n      if (this.edgePrograms[key]) this.edgePrograms[key].kill();\n      this.edgePrograms[key] = new EdgeProgramClass(this.webGLContexts.edges, this.frameBuffers.edges, this);\n      return this;\n    }\n\n    /**\n     * Internal function used to unregister a node program\n     *\n     * @param  {string} key - The program's key, matching the related nodes \"type\" values.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unregisterNodeProgram\",\n    value: function unregisterNodeProgram(key) {\n      if (this.nodePrograms[key]) {\n        var _this$nodePrograms = this.nodePrograms,\n          program = _this$nodePrograms[key],\n          programs = _objectWithoutProperties(_this$nodePrograms, [key].map(_toPropertyKey));\n        program.kill();\n        this.nodePrograms = programs;\n      }\n      if (this.nodeHoverPrograms[key]) {\n        var _this$nodeHoverProgra = this.nodeHoverPrograms,\n          _program = _this$nodeHoverProgra[key],\n          _programs = _objectWithoutProperties(_this$nodeHoverProgra, [key].map(_toPropertyKey));\n        _program.kill();\n        this.nodePrograms = _programs;\n      }\n      return this;\n    }\n\n    /**\n     * Internal function used to unregister an edge program\n     *\n     * @param  {string} key - The program's key, matching the related edges \"type\" values.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unregisterEdgeProgram\",\n    value: function unregisterEdgeProgram(key) {\n      if (this.edgePrograms[key]) {\n        var _this$edgePrograms = this.edgePrograms,\n          program = _this$edgePrograms[key],\n          programs = _objectWithoutProperties(_this$edgePrograms, [key].map(_toPropertyKey));\n        program.kill();\n        this.edgePrograms = programs;\n      }\n      return this;\n    }\n\n    /**\n     * Method (re)binding WebGL texture (for picking).\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resetWebGLTexture\",\n    value: function resetWebGLTexture(id) {\n      var gl = this.webGLContexts[id];\n      var frameBuffer = this.frameBuffers[id];\n      var currentTexture = this.textures[id];\n      if (currentTexture) gl.deleteTexture(currentTexture);\n      var pickingTexture = gl.createTexture();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.bindTexture(gl.TEXTURE_2D, pickingTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);\n      this.textures[id] = pickingTexture;\n      return this;\n    }\n\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindCameraHandlers\",\n    value: function bindCameraHandlers() {\n      var _this2 = this;\n      this.activeListeners.camera = function () {\n        _this2.scheduleRender();\n      };\n      this.camera.on(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method unbinding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unbindCameraHandlers\",\n    value: function unbindCameraHandlers() {\n      this.camera.removeListener(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method that returns the closest node to a given position.\n     */\n  }, {\n    key: \"getNodeAtPosition\",\n    value: function getNodeAtPosition(position) {\n      var x = position.x,\n        y = position.y;\n      var color = getPixelColor(this.webGLContexts.nodes, this.frameBuffers.nodes, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = colorToIndex.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"node\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method binding event handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindEventHandlers\",\n    value: function bindEventHandlers() {\n      var _this3 = this;\n      // Handling window resize\n      this.activeListeners.handleResize = function () {\n        // need to call a refresh to rebuild the labelgrid\n        _this3.scheduleRefresh();\n      };\n      window.addEventListener(\"resize\", this.activeListeners.handleResize);\n\n      // Handling mouse move\n      this.activeListeners.handleMove = function (e) {\n        var event = cleanMouseCoords(e);\n        var baseEvent = {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        };\n        var nodeToHover = _this3.getNodeAtPosition(event);\n        if (nodeToHover && _this3.hoveredNode !== nodeToHover && !_this3.nodeDataCache[nodeToHover].hidden) {\n          // Handling passing from one node to the other directly\n          if (_this3.hoveredNode) _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.hoveredNode = nodeToHover;\n          _this3.emit(\"enterNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: nodeToHover\n          }));\n          _this3.scheduleHighlightedNodesRender();\n          return;\n        }\n\n        // Checking if the hovered node is still hovered\n        if (_this3.hoveredNode) {\n          if (_this3.getNodeAtPosition(event) !== _this3.hoveredNode) {\n            var node = _this3.hoveredNode;\n            _this3.hoveredNode = null;\n            _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              node: node\n            }));\n            _this3.scheduleHighlightedNodesRender();\n            return;\n          }\n        }\n        if (_this3.settings.enableEdgeEvents) {\n          var edgeToHover = _this3.hoveredNode ? null : _this3.getEdgeAtPoint(baseEvent.event.x, baseEvent.event.y);\n          if (edgeToHover !== _this3.hoveredEdge) {\n            if (_this3.hoveredEdge) _this3.emit(\"leaveEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: _this3.hoveredEdge\n            }));\n            if (edgeToHover) _this3.emit(\"enterEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: edgeToHover\n            }));\n            _this3.hoveredEdge = edgeToHover;\n          }\n        }\n      };\n\n      // Handling mouse move over body (only to dispatch the proper event):\n      this.activeListeners.handleMoveBody = function (e) {\n        var event = cleanMouseCoords(e);\n        _this3.emit(\"moveBody\", {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        });\n      };\n\n      // Handling mouse leave stage:\n      this.activeListeners.handleLeave = function (e) {\n        var event = cleanMouseCoords(e);\n        var baseEvent = {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        };\n        if (_this3.hoveredNode) {\n          _this3.emit(\"leaveNode\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        if (_this3.settings.enableEdgeEvents && _this3.hoveredEdge) {\n          _this3.emit(\"leaveEdge\", _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            edge: _this3.hoveredEdge\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        _this3.emit(\"leaveStage\", _objectSpread2({}, baseEvent));\n      };\n\n      // Handling mouse enter stage:\n      this.activeListeners.handleEnter = function (e) {\n        var event = cleanMouseCoords(e);\n        var baseEvent = {\n          event: event,\n          preventSigmaDefault: function preventSigmaDefault() {\n            event.preventSigmaDefault();\n          }\n        };\n        _this3.emit(\"enterStage\", _objectSpread2({}, baseEvent));\n      };\n\n      // Handling click\n      var createInteractionListener = function createInteractionListener(eventType) {\n        return function (e) {\n          var event = cleanMouseCoords(e);\n          var baseEvent = {\n            event: event,\n            preventSigmaDefault: function preventSigmaDefault() {\n              event.preventSigmaDefault();\n            }\n          };\n          var nodeAtPosition = _this3.getNodeAtPosition(event);\n          if (nodeAtPosition) return _this3.emit(\"\".concat(eventType, \"Node\"), _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n            node: nodeAtPosition\n          }));\n          if (_this3.settings.enableEdgeEvents) {\n            var edge = _this3.getEdgeAtPoint(event.x, event.y);\n            if (edge) return _this3.emit(\"\".concat(eventType, \"Edge\"), _objectSpread2(_objectSpread2({}, baseEvent), {}, {\n              edge: edge\n            }));\n          }\n          return _this3.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n        };\n      };\n      this.activeListeners.handleClick = createInteractionListener(\"click\");\n      this.activeListeners.handleRightClick = createInteractionListener(\"rightClick\");\n      this.activeListeners.handleDoubleClick = createInteractionListener(\"doubleClick\");\n      this.activeListeners.handleWheel = createInteractionListener(\"wheel\");\n      this.activeListeners.handleDown = createInteractionListener(\"down\");\n      this.activeListeners.handleUp = createInteractionListener(\"up\");\n      this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n      this.mouseCaptor.on(\"mousemovebody\", this.activeListeners.handleMoveBody);\n      this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n      this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n      this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n      this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n      this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n      this.mouseCaptor.on(\"mouseup\", this.activeListeners.handleUp);\n      this.mouseCaptor.on(\"mouseleave\", this.activeListeners.handleLeave);\n      this.mouseCaptor.on(\"mouseenter\", this.activeListeners.handleEnter);\n      this.touchCaptor.on(\"touchdown\", this.activeListeners.handleDown);\n      this.touchCaptor.on(\"touchdown\", this.activeListeners.handleMove);\n      this.touchCaptor.on(\"touchup\", this.activeListeners.handleUp);\n      this.touchCaptor.on(\"touchmove\", this.activeListeners.handleMove);\n      this.touchCaptor.on(\"tap\", this.activeListeners.handleClick);\n      this.touchCaptor.on(\"doubletap\", this.activeListeners.handleDoubleClick);\n      this.touchCaptor.on(\"touchmove\", this.activeListeners.handleMoveBody);\n      return this;\n    }\n\n    /**\n     * Method binding graph handlers\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindGraphHandlers\",\n    value: function bindGraphHandlers() {\n      var _this4 = this;\n      var graph = this.graph;\n      var LAYOUT_IMPACTING_FIELDS = new Set([\"x\", \"y\", \"zIndex\", \"type\"]);\n      this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints;\n        var updatedFields = (_e$hints = e.hints) === null || _e$hints === void 0 ? void 0 : _e$hints.attributes;\n        // we process all nodes\n        _this4.graph.forEachNode(function (node) {\n          return _this4.updateNode(node);\n        });\n\n        // if coord, type or zIndex have changed, we need to schedule a render\n        // (zIndex for the programIndex)\n        var layoutChanged = !updatedFields || updatedFields.some(function (f) {\n          return LAYOUT_IMPACTING_FIELDS.has(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            nodes: graph.nodes()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n      this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints2;\n        var updatedFields = (_e$hints2 = e.hints) === null || _e$hints2 === void 0 ? void 0 : _e$hints2.attributes;\n        // we process all edges\n        _this4.graph.forEachEdge(function (edge) {\n          return _this4.updateEdge(edge);\n        });\n        var layoutChanged = updatedFields && [\"zIndex\", \"type\"].some(function (f) {\n          return updatedFields === null || updatedFields === void 0 ? void 0 : updatedFields.includes(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            edges: graph.edges()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n\n      // On add node, we add the node in indices and then call for a render\n      this.activeListeners.addNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.addNode(node);\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On update node, we update indices and then call for a render\n      this.activeListeners.updateNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop node, we remove the node from indices and then call for a refresh\n      this.activeListeners.dropNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.removeNode(node);\n        // schedule a render for everything\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On add edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.addEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.addEdge(edge);\n        // schedule a render for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          schedule: true\n        });\n      };\n\n      // On update edge, we update indices and then call for a refresh\n      this.activeListeners.updateEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // schedule a repaint for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.dropEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.removeEdge(edge);\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On clear edges, we clear the edge indices and then call for a refresh\n      this.activeListeners.clearEdgesGraphUpdate = function () {\n        // we clear the edge data structures\n        _this4.clearEdgeState();\n        _this4.clearEdgeIndices();\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On graph clear, we clear indices and then call for a refresh\n      this.activeListeners.clearGraphUpdate = function () {\n        // clear graph state\n        _this4.clearEdgeState();\n        _this4.clearNodeState();\n\n        // clear graph indices\n        _this4.clearEdgeIndices();\n        _this4.clearNodeIndices();\n\n        // schedule a render for all\n        _this4.refresh({\n          schedule: true\n        });\n      };\n      graph.on(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.on(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.on(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n      return this;\n    }\n\n    /**\n     * Method used to unbind handlers from the graph.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"unbindGraphHandlers\",\n    value: function unbindGraphHandlers() {\n      var graph = this.graph;\n      graph.removeListener(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n    }\n\n    /**\n     * Method looking for an edge colliding with a given point at (x, y). Returns\n     * the key of the edge if any, or null else.\n     */\n  }, {\n    key: \"getEdgeAtPoint\",\n    value: function getEdgeAtPoint(x, y) {\n      var color = getPixelColor(this.webGLContexts.edges, this.frameBuffers.edges, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = colorToIndex.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"edge\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method used to process the whole graph's data.\n     *  - extent\n     *  - normalizationFunction\n     *  - compute node's coordinate\n     *  - labelgrid\n     *  - program data allocation\n     * @return {Sigma}\n     */\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this5 = this;\n      this.emit(\"beforeProcess\");\n      var graph = this.graph;\n      var settings = this.settings;\n      var dimensions = this.getDimensions();\n\n      //\n      // NODES\n      //\n      this.nodeExtent = graphExtent(this.graph);\n      if (!this.settings.autoRescale) {\n        var width = dimensions.width,\n          height = dimensions.height;\n        var _this$nodeExtent = this.nodeExtent,\n          x = _this$nodeExtent.x,\n          y = _this$nodeExtent.y;\n        this.nodeExtent = {\n          x: [(x[0] + x[1]) / 2 - width / 2, (x[0] + x[1]) / 2 + width / 2],\n          y: [(y[0] + y[1]) / 2 - height / 2, (y[0] + y[1]) / 2 + height / 2]\n        };\n      }\n      this.normalizationFunction = createNormalizationFunction(this.customBBox || this.nodeExtent);\n\n      // NOTE: it is important to compute this matrix after computing the node's extent\n      // because #.getGraphDimensions relies on it\n      var nullCamera = new Camera();\n      var nullCameraMatrix = matrixFromCamera(nullCamera.getState(), dimensions, this.getGraphDimensions(), this.getStagePadding());\n      // Resetting the label grid\n      // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n      this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n      var nodesPerPrograms = {};\n      var nodeIndices = {};\n      var edgeIndices = {};\n      var itemIDsIndex = {};\n      var incrID = 1;\n      var nodes = graph.nodes();\n\n      // Do some indexation on the whole graph\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n        var data = this.nodeDataCache[node];\n\n        // Get initial coordinates\n        var attrs = graph.getNodeAttributes(node);\n        data.x = attrs.x;\n        data.y = attrs.y;\n        this.normalizationFunction.applyTo(data);\n\n        // labelgrid\n        if (typeof data.label === \"string\" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {\n          matrix: nullCameraMatrix\n        }));\n\n        // update count per program\n        nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n      }\n      this.labelGrid.organize();\n\n      // Allocate memory to programs\n      for (var type in this.nodePrograms) {\n        if (!hasOwnProperty.call(this.nodePrograms, type)) {\n          throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n        }\n        this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        nodesPerPrograms[type] = 0;\n      }\n\n      // Order nodes by zIndex before to add them to program\n      if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1]) nodes = zIndexOrdering(this.nodeZExtent, function (node) {\n        return _this5.nodeDataCache[node].zIndex;\n      }, nodes);\n\n      // Add data to programs\n      for (var _i = 0, _l = nodes.length; _i < _l; _i++) {\n        var _node = nodes[_i];\n        nodeIndices[_node] = incrID;\n        itemIDsIndex[nodeIndices[_node]] = {\n          type: \"node\",\n          id: _node\n        };\n        incrID++;\n        var _data = this.nodeDataCache[_node];\n        this.addNodeToProgram(_node, nodeIndices[_node], nodesPerPrograms[_data.type]++);\n      }\n\n      //\n      // EDGES\n      //\n\n      var edgesPerPrograms = {};\n      var edges = graph.edges();\n\n      // Allocate memory to programs\n      for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {\n        var edge = edges[_i2];\n        var _data2 = this.edgeDataCache[edge];\n        edgesPerPrograms[_data2.type] = (edgesPerPrograms[_data2.type] || 0) + 1;\n      }\n\n      // Order edges by zIndex before to add them to program\n      if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1]) edges = zIndexOrdering(this.edgeZExtent, function (edge) {\n        return _this5.edgeDataCache[edge].zIndex;\n      }, edges);\n      for (var _type2 in this.edgePrograms) {\n        if (!hasOwnProperty.call(this.edgePrograms, _type2)) {\n          throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(_type2, \"\\\"!\"));\n        }\n        this.edgePrograms[_type2].reallocate(edgesPerPrograms[_type2] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        edgesPerPrograms[_type2] = 0;\n      }\n\n      // Add data to programs\n      for (var _i3 = 0, _l3 = edges.length; _i3 < _l3; _i3++) {\n        var _edge = edges[_i3];\n        edgeIndices[_edge] = incrID;\n        itemIDsIndex[edgeIndices[_edge]] = {\n          type: \"edge\",\n          id: _edge\n        };\n        incrID++;\n        var _data3 = this.edgeDataCache[_edge];\n        this.addEdgeToProgram(_edge, edgeIndices[_edge], edgesPerPrograms[_data3.type]++);\n      }\n      this.itemIDsIndex = itemIDsIndex;\n      this.nodeIndices = nodeIndices;\n      this.edgeIndices = edgeIndices;\n      this.emit(\"afterProcess\");\n      return this;\n    }\n\n    /**\n     * Method that backports potential settings updates where it's needed.\n     * @private\n     */\n  }, {\n    key: \"handleSettingsUpdate\",\n    value: function handleSettingsUpdate(oldSettings) {\n      var _this6 = this;\n      var settings = this.settings;\n      this.camera.minRatio = settings.minCameraRatio;\n      this.camera.maxRatio = settings.maxCameraRatio;\n      this.camera.enabledZooming = settings.enableCameraZooming;\n      this.camera.enabledPanning = settings.enableCameraPanning;\n      this.camera.enabledRotation = settings.enableCameraRotation;\n      if (settings.cameraPanBoundaries) {\n        this.camera.clean = function (state) {\n          return _this6.cleanCameraState(state, settings.cameraPanBoundaries && _typeof(settings.cameraPanBoundaries) === \"object\" ? settings.cameraPanBoundaries : {});\n        };\n      } else {\n        this.camera.clean = null;\n      }\n      this.camera.setState(this.camera.validateState(this.camera.getState()));\n      if (oldSettings) {\n        // Check edge programs:\n        if (oldSettings.edgeProgramClasses !== settings.edgeProgramClasses) {\n          for (var type in settings.edgeProgramClasses) {\n            if (settings.edgeProgramClasses[type] !== oldSettings.edgeProgramClasses[type]) {\n              this.registerEdgeProgram(type, settings.edgeProgramClasses[type]);\n            }\n          }\n          for (var _type3 in oldSettings.edgeProgramClasses) {\n            if (!settings.edgeProgramClasses[_type3]) this.unregisterEdgeProgram(_type3);\n          }\n        }\n\n        // Check node programs:\n        if (oldSettings.nodeProgramClasses !== settings.nodeProgramClasses || oldSettings.nodeHoverProgramClasses !== settings.nodeHoverProgramClasses) {\n          for (var _type4 in settings.nodeProgramClasses) {\n            if (settings.nodeProgramClasses[_type4] !== oldSettings.nodeProgramClasses[_type4] || settings.nodeHoverProgramClasses[_type4] !== oldSettings.nodeHoverProgramClasses[_type4]) {\n              this.registerNodeProgram(_type4, settings.nodeProgramClasses[_type4], settings.nodeHoverProgramClasses[_type4]);\n            }\n          }\n          for (var _type5 in oldSettings.nodeProgramClasses) {\n            if (!settings.nodeProgramClasses[_type5]) this.unregisterNodeProgram(_type5);\n          }\n        }\n      }\n\n      // Update captors settings:\n      this.mouseCaptor.setSettings(this.settings);\n      this.touchCaptor.setSettings(this.settings);\n      return this;\n    }\n  }, {\n    key: \"cleanCameraState\",\n    value: function cleanCameraState(state) {\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$tolerance = _ref.tolerance,\n        tolerance = _ref$tolerance === void 0 ? 0 : _ref$tolerance,\n        boundaries = _ref.boundaries;\n      var newState = _objectSpread2({}, state);\n\n      // Extract necessary properties\n      var _ref2 = boundaries || this.nodeExtent,\n        _ref2$x = _slicedToArray(_ref2.x, 2),\n        xMinGraph = _ref2$x[0],\n        xMaxGraph = _ref2$x[1],\n        _ref2$y = _slicedToArray(_ref2.y, 2),\n        yMinGraph = _ref2$y[0],\n        yMaxGraph = _ref2$y[1];\n\n      // Transform the four corners of the graph rectangle using the provided camera state\n      var corners = [this.graphToViewport({\n        x: xMinGraph,\n        y: yMinGraph\n      }, {\n        cameraState: state\n      }), this.graphToViewport({\n        x: xMaxGraph,\n        y: yMinGraph\n      }, {\n        cameraState: state\n      }), this.graphToViewport({\n        x: xMinGraph,\n        y: yMaxGraph\n      }, {\n        cameraState: state\n      }), this.graphToViewport({\n        x: xMaxGraph,\n        y: yMaxGraph\n      }, {\n        cameraState: state\n      })];\n\n      // Look for new extents, based on these four corners\n      var xMin = Infinity,\n        xMax = -Infinity,\n        yMin = Infinity,\n        yMax = -Infinity;\n      corners.forEach(function (_ref3) {\n        var x = _ref3.x,\n          y = _ref3.y;\n        xMin = Math.min(xMin, x);\n        xMax = Math.max(xMax, x);\n        yMin = Math.min(yMin, y);\n        yMax = Math.max(yMax, y);\n      });\n\n      // For each dimension, constraint the smaller element (camera or graph) to fit in the larger one:\n      var graphWidth = xMax - xMin;\n      var graphHeight = yMax - yMin;\n      var _this$getDimensions = this.getDimensions(),\n        width = _this$getDimensions.width,\n        height = _this$getDimensions.height;\n      var dx = 0;\n      var dy = 0;\n      if (graphWidth >= width) {\n        if (xMax < width - tolerance) dx = xMax - (width - tolerance);else if (xMin > tolerance) dx = xMin - tolerance;\n      } else {\n        if (xMax > width + tolerance) dx = xMax - (width + tolerance);else if (xMin < -tolerance) dx = xMin + tolerance;\n      }\n      if (graphHeight >= height) {\n        if (yMax < height - tolerance) dy = yMax - (height - tolerance);else if (yMin > tolerance) dy = yMin - tolerance;\n      } else {\n        if (yMax > height + tolerance) dy = yMax - (height + tolerance);else if (yMin < -tolerance) dy = yMin + tolerance;\n      }\n      if (dx || dy) {\n        // Transform [dx, dy] from viewport to graph (using two different point to transform that vector):\n        var origin = this.viewportToFramedGraph({\n          x: 0,\n          y: 0\n        }, {\n          cameraState: state\n        });\n        var delta = this.viewportToFramedGraph({\n          x: dx,\n          y: dy\n        }, {\n          cameraState: state\n        });\n        dx = delta.x - origin.x;\n        dy = delta.y - origin.y;\n        newState.x += dx;\n        newState.y += dy;\n      }\n      return newState;\n    }\n\n    /**\n     * Method used to render labels.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderLabels\",\n    value: function renderLabels() {\n      if (!this.settings.renderLabels) return this;\n      var cameraState = this.camera.getState();\n\n      // Selecting labels to draw\n      var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n      extend(labelsToDisplay, this.nodesWithForcedLabels);\n      this.displayedNodeLabels = new Set();\n\n      // Drawing labels\n      var context = this.canvasContexts.labels;\n      for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n        var node = labelsToDisplay[i];\n        var data = this.nodeDataCache[node];\n\n        // If the node was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        // NOTE: we can do better probably\n        if (this.displayedNodeLabels.has(node)) continue;\n\n        // If the node is hidden, we don't need to display its label obviously\n        if (data.hidden) continue;\n        var _this$framedGraphToVi = this.framedGraphToViewport(data),\n          x = _this$framedGraphToVi.x,\n          y = _this$framedGraphToVi.y;\n\n        // NOTE: we can cache the labels we need to render until the camera's ratio changes\n        var size = this.scaleSize(data.size);\n\n        // Is node big enough?\n        if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n\n        // Is node actually on screen (with some margin)\n        // NOTE: we used to rely on the quadtree for this, but the coordinates\n        // conversion make it unreliable and at that point we already converted\n        // to viewport coordinates and since the label grid already culls the\n        // number of potential labels to display this looks like a good\n        // performance compromise.\n        // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n        // considering cells obviously outside of the range of the current\n        // view rectangle.\n        if (x < -X_LABEL_MARGIN || x > this.width + X_LABEL_MARGIN || y < -Y_LABEL_MARGIN || y > this.height + Y_LABEL_MARGIN) continue;\n\n        // Because displayed edge labels depend directly on actually rendered node\n        // labels, we need to only add to this.displayedNodeLabels nodes whose label\n        // is rendered.\n        // This makes this.displayedNodeLabels depend on viewport, which might become\n        // an issue once we start memoizing getLabelsToDisplay.\n        this.displayedNodeLabels.add(node);\n        var defaultDrawNodeLabel = this.settings.defaultDrawNodeLabel;\n        var nodeProgram = this.nodePrograms[data.type];\n        var drawLabel = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawLabel) || defaultDrawNodeLabel;\n        drawLabel(context, _objectSpread2(_objectSpread2({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), this.settings);\n      }\n      return this;\n    }\n\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderEdgeLabels\",\n    value: function renderEdgeLabels() {\n      if (!this.settings.renderEdgeLabels) return this;\n      var context = this.canvasContexts.edgeLabels;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n      var edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({\n        graph: this.graph,\n        hoveredNode: this.hoveredNode,\n        displayedNodeLabels: this.displayedNodeLabels,\n        highlightedNodes: this.highlightedNodes\n      });\n      extend(edgeLabelsToDisplay, this.edgesWithForcedLabels);\n      var displayedLabels = new Set();\n      for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n        var edge = edgeLabelsToDisplay[i],\n          extremities = this.graph.extremities(edge),\n          sourceData = this.nodeDataCache[extremities[0]],\n          targetData = this.nodeDataCache[extremities[1]],\n          edgeData = this.edgeDataCache[edge];\n\n        // If the edge was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        if (displayedLabels.has(edge)) continue;\n\n        // If the edge is hidden we don't need to display its label\n        // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n        if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n          continue;\n        }\n        var defaultDrawEdgeLabel = this.settings.defaultDrawEdgeLabel;\n        var edgeProgram = this.edgePrograms[edgeData.type];\n        var drawLabel = (edgeProgram === null || edgeProgram === void 0 ? void 0 : edgeProgram.drawLabel) || defaultDrawEdgeLabel;\n        drawLabel(context, _objectSpread2(_objectSpread2({\n          key: edge\n        }, edgeData), {}, {\n          size: this.scaleSize(edgeData.size)\n        }), _objectSpread2(_objectSpread2(_objectSpread2({\n          key: extremities[0]\n        }, sourceData), this.framedGraphToViewport(sourceData)), {}, {\n          size: this.scaleSize(sourceData.size)\n        }), _objectSpread2(_objectSpread2(_objectSpread2({\n          key: extremities[1]\n        }, targetData), this.framedGraphToViewport(targetData)), {}, {\n          size: this.scaleSize(targetData.size)\n        }), this.settings);\n        displayedLabels.add(edge);\n      }\n      this.displayedEdgeLabels = displayedLabels;\n      return this;\n    }\n\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderHighlightedNodes\",\n    value: function renderHighlightedNodes() {\n      var _this7 = this;\n      var context = this.canvasContexts.hovers;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n\n      // Rendering\n      var render = function render(node) {\n        var data = _this7.nodeDataCache[node];\n        var _this7$framedGraphToV = _this7.framedGraphToViewport(data),\n          x = _this7$framedGraphToV.x,\n          y = _this7$framedGraphToV.y;\n        var size = _this7.scaleSize(data.size);\n        var defaultDrawNodeHover = _this7.settings.defaultDrawNodeHover;\n        var nodeProgram = _this7.nodePrograms[data.type];\n        var drawHover = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawHover) || defaultDrawNodeHover;\n        drawHover(context, _objectSpread2(_objectSpread2({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), _this7.settings);\n      };\n      var nodesToRender = [];\n      if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n        nodesToRender.push(this.hoveredNode);\n      }\n      this.highlightedNodes.forEach(function (node) {\n        // The hovered node has already been highlighted\n        if (node !== _this7.hoveredNode) nodesToRender.push(node);\n      });\n\n      // Draw labels:\n      nodesToRender.forEach(function (node) {\n        return render(node);\n      });\n\n      // Draw WebGL nodes on top of the labels:\n      var nodesPerPrograms = {};\n\n      // 1. Count nodes per type:\n      nodesToRender.forEach(function (node) {\n        var type = _this7.nodeDataCache[node].type;\n        nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n      });\n      // 2. Allocate for each type for the proper number of nodes\n      for (var type in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // Also reset count, to use when rendering:\n        nodesPerPrograms[type] = 0;\n      }\n      // 3. Process all nodes to render:\n      nodesToRender.forEach(function (node) {\n        var data = _this7.nodeDataCache[node];\n        _this7.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);\n      });\n      // 4. Clear hovered nodes layer:\n      this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n      // 5. Render:\n      var renderParams = this.getRenderParams();\n      for (var _type6 in this.nodeHoverPrograms) {\n        var program = this.nodeHoverPrograms[_type6];\n        program.render(renderParams);\n      }\n    }\n\n    /**\n     * Method used to schedule a hover render.\n     *\n     */\n  }, {\n    key: \"scheduleHighlightedNodesRender\",\n    value: function scheduleHighlightedNodesRender() {\n      var _this8 = this;\n      if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n      this.renderHighlightedNodesFrame = requestAnimationFrame(function () {\n        // Resetting state\n        _this8.renderHighlightedNodesFrame = null;\n\n        // Rendering\n        _this8.renderHighlightedNodes();\n        _this8.renderEdgeLabels();\n      });\n    }\n\n    /**\n     * Method used to render.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this9 = this;\n      this.emit(\"beforeRender\");\n      var exitRender = function exitRender() {\n        _this9.emit(\"afterRender\");\n        return _this9;\n      };\n\n      // If a render was scheduled, we cancel it\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n\n      // First we need to resize\n      this.resize();\n\n      // Do we need to reprocess data?\n      if (this.needToProcess) this.process();\n      this.needToProcess = false;\n\n      // Clearing the canvases\n      this.clear();\n\n      // Prepare the textures\n      this.pickingLayers.forEach(function (layer) {\n        return _this9.resetWebGLTexture(layer);\n      });\n\n      // If we have no nodes we can stop right there\n      if (!this.graph.order) return exitRender();\n\n      // TODO: improve this heuristic or move to the captor itself?\n      // TODO: deal with the touch captor here as well\n      var mouseCaptor = this.mouseCaptor;\n      var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;\n\n      // Then we need to extract a matrix from the camera\n      var cameraState = this.camera.getState();\n      var viewportDimensions = this.getDimensions();\n      var graphDimensions = this.getGraphDimensions();\n      var padding = this.getStagePadding();\n      this.matrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding);\n      this.invMatrix = matrixFromCamera(cameraState, viewportDimensions, graphDimensions, padding, true);\n      this.correctionRatio = getMatrixImpact(this.matrix, cameraState, viewportDimensions);\n      this.graphToViewportRatio = this.getGraphToViewportRatio();\n\n      // [jacomyal]\n      // This comment is related to the one above the `getMatrixImpact` definition:\n      // - `this.correctionRatio` is somehow not completely explained\n      // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n      //   graph\n      // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n      // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n      // when I change the graph, the viewport or the camera. It might be useful later, so I prefer to let this comment:\n      // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n\n      var params = this.getRenderParams();\n\n      // Drawing nodes\n      for (var type in this.nodePrograms) {\n        var program = this.nodePrograms[type];\n        program.render(params);\n      }\n\n      // Drawing edges\n      if (!this.settings.hideEdgesOnMove || !moving) {\n        for (var _type7 in this.edgePrograms) {\n          var _program2 = this.edgePrograms[_type7];\n          _program2.render(params);\n        }\n      }\n\n      // Do not display labels on move per setting\n      if (this.settings.hideLabelsOnMove && moving) return exitRender();\n      this.renderLabels();\n      this.renderEdgeLabels();\n      this.renderHighlightedNodes();\n      return exitRender();\n    }\n\n    /**\n     * Add a node in the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"addNode\",\n    value: function addNode(key) {\n      // Node display data resolution:\n      //  1. First we get the node's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //     Note that this function must return a total object and won't be merged\n      //  3. We apply our defaults, while running some vital checks\n      //  4. We apply the normalization function\n      // We shallow copy node data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getNodeAttributes(key));\n      if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);\n      var data = applyNodeDefaults(this.settings, key, attr);\n      this.nodeDataCache[key] = data;\n\n      // Label:\n      // We delete and add if needed because this function is also used from\n      // update\n      this.nodesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);\n\n      // Highlighted:\n      // We remove and re add if needed because this function is also used from\n      // update\n      this.highlightedNodes[\"delete\"](key);\n      if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);\n\n      // zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update a node the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"updateNode\",\n    value: function updateNode(key) {\n      this.addNode(key);\n\n      // Re-apply normalization on the node\n      var data = this.nodeDataCache[key];\n      this.normalizationFunction.applyTo(data);\n    }\n\n    /**\n     * Remove a node from the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(key) {\n      // Remove from node cache\n      delete this.nodeDataCache[key];\n      // Remove from node program index\n      delete this.nodeProgramIndex[key];\n      // Remove from higlighted nodes\n      this.highlightedNodes[\"delete\"](key);\n      // Remove from hovered\n      if (this.hoveredNode === key) this.hoveredNode = null;\n      // Remove from forced label\n      this.nodesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Add an edge into the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(key) {\n      // Edge display data resolution:\n      //  1. First we get the edge's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //  3. Note that this function must return a total object and won't be merged\n      //  4. We apply our defaults, while running some vital checks\n      // We shallow copy edge data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getEdgeAttributes(key));\n      if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);\n      var data = applyEdgeDefaults(this.settings, key, attr);\n      this.edgeDataCache[key] = data;\n\n      // Forced label\n      // we filter and re push if needed because this function is also used from\n      // update\n      this.edgesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);\n\n      // Check zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update an edge in the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"updateEdge\",\n    value: function updateEdge(key) {\n      this.addEdge(key);\n    }\n\n    /**\n     * Remove an edge from the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"removeEdge\",\n    value: function removeEdge(key) {\n      // Remove from edge cache\n      delete this.edgeDataCache[key];\n      // Remove from programId index\n      delete this.edgeProgramIndex[key];\n      // Remove from hovered\n      if (this.hoveredEdge === key) this.hoveredEdge = null;\n      // Remove from forced label\n      this.edgesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Clear all indices related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeIndices\",\n    value: function clearNodeIndices() {\n      // LabelGrid & nodeExtent are only manage/populated in the process function\n      this.labelGrid = new LabelGrid();\n      this.nodeExtent = {\n        x: [0, 1],\n        y: [0, 1]\n      };\n      this.nodeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.nodesWithForcedLabels = new Set();\n      this.nodeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeIndices\",\n    value: function clearEdgeIndices() {\n      this.edgeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.edgesWithForcedLabels = new Set();\n      this.edgeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices.\n     * @private\n     */\n  }, {\n    key: \"clearIndices\",\n    value: function clearIndices() {\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n    }\n\n    /**\n     * Clear all graph state related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeState\",\n    value: function clearNodeState() {\n      this.displayedNodeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredNode = null;\n    }\n\n    /**\n     * Clear all graph state related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeState\",\n    value: function clearEdgeState() {\n      this.displayedEdgeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredEdge = null;\n    }\n\n    /**\n     * Clear all graph state.\n     * @private\n     */\n  }, {\n    key: \"clearState\",\n    value: function clearState() {\n      this.clearEdgeState();\n      this.clearNodeState();\n    }\n\n    /**\n     * Add the node data to its program.\n     * @private\n     * @param node The node's graphology ID\n     * @param fingerprint A fingerprint used to identity the node with picking\n     * @param position The index where to place the node in the program\n     */\n  }, {\n    key: \"addNodeToProgram\",\n    value: function addNodeToProgram(node, fingerprint, position) {\n      var data = this.nodeDataCache[node];\n      var nodeProgram = this.nodePrograms[data.type];\n      if (!nodeProgram) throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(data.type, \"\\\"!\"));\n      nodeProgram.process(fingerprint, position, data);\n      // Saving program index\n      this.nodeProgramIndex[node] = position;\n    }\n\n    /**\n     * Add the edge data to its program.\n     * @private\n     * @param edge The edge's graphology ID\n     * @param fingerprint A fingerprint used to identity the edge with picking\n     * @param position The index where to place the edge in the program\n     */\n  }, {\n    key: \"addEdgeToProgram\",\n    value: function addEdgeToProgram(edge, fingerprint, position) {\n      var data = this.edgeDataCache[edge];\n      var edgeProgram = this.edgePrograms[data.type];\n      if (!edgeProgram) throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(data.type, \"\\\"!\"));\n      var extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]];\n      edgeProgram.process(fingerprint, position, sourceData, targetData, data);\n      // Saving program index\n      this.edgeProgramIndex[edge] = position;\n    }\n\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n\n    /**\n     * Function used to get the render params.\n     *\n     * @return {RenderParams}\n     */\n  }, {\n    key: \"getRenderParams\",\n    value: function getRenderParams() {\n      return {\n        matrix: this.matrix,\n        invMatrix: this.invMatrix,\n        width: this.width,\n        height: this.height,\n        pixelRatio: this.pixelRatio,\n        zoomRatio: this.camera.ratio,\n        cameraAngle: this.camera.angle,\n        sizeRatio: 1 / this.scaleSize(),\n        correctionRatio: this.correctionRatio,\n        downSizingRatio: this.pickingDownSizingRatio,\n        minEdgeThickness: this.settings.minEdgeThickness,\n        antiAliasingFeather: this.settings.antiAliasingFeather\n      };\n    }\n\n    /**\n     * Function used to retrieve the actual stage padding value.\n     *\n     * @return {number}\n     */\n  }, {\n    key: \"getStagePadding\",\n    value: function getStagePadding() {\n      var _this$settings = this.settings,\n        stagePadding = _this$settings.stagePadding,\n        autoRescale = _this$settings.autoRescale;\n      return autoRescale ? stagePadding || 0 : 0;\n    }\n\n    /**\n     * Function used to create a layer element.\n     *\n     * @param {string} id - Context's id.\n     * @param {string} tag - The HTML tag to use.\n     * @param options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createLayer\",\n    value: function createLayer(id, tag) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (this.elements[id]) throw new Error(\"Sigma: a layer named \\\"\".concat(id, \"\\\" already exists\"));\n      var element = createElement(tag, {\n        position: \"absolute\"\n      }, {\n        \"class\": \"sigma-\".concat(id)\n      });\n      if (options.style) Object.assign(element.style, options.style);\n      this.elements[id] = element;\n      if (\"beforeLayer\" in options && options.beforeLayer) {\n        this.elements[options.beforeLayer].before(element);\n      } else if (\"afterLayer\" in options && options.afterLayer) {\n        this.elements[options.afterLayer].after(element);\n      } else {\n        this.container.appendChild(element);\n      }\n      return element;\n    }\n\n    /**\n     * Function used to create a canvas element.\n     *\n     * @param {string} id - Context's id.\n     * @param options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvas\",\n    value: function createCanvas(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.createLayer(id, \"canvas\", options);\n    }\n\n    /**\n     * Function used to create a canvas context and add the relevant DOM elements.\n     *\n     * @param  {string} id - Context's id.\n     * @param  options\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvasContext\",\n    value: function createCanvasContext(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var canvas = this.createCanvas(id, options);\n      var contextOptions = {\n        preserveDrawingBuffer: false,\n        antialias: false\n      };\n      this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n      return this;\n    }\n\n    /**\n     * Function used to create a WebGL context and add the relevant DOM\n     * elements.\n     *\n     * @param  {string}  id      - Context's id.\n     * @param  {object?} options - #getContext params to override (optional)\n     * @return {WebGLRenderingContext}\n     */\n  }, {\n    key: \"createWebGLContext\",\n    value: function createWebGLContext(id) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var canvas = (options === null || options === void 0 ? void 0 : options.canvas) || this.createCanvas(id, options);\n      if (options.hidden) canvas.remove();\n      var contextOptions = _objectSpread2({\n        preserveDrawingBuffer: false,\n        antialias: false\n      }, options);\n      var context;\n\n      // First we try webgl2 for an easy performance boost\n      context = canvas.getContext(\"webgl2\", contextOptions);\n\n      // Else we fall back to webgl\n      if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n\n      // Edge, I am looking right at you...\n      if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n      var gl = context;\n      this.webGLContexts[id] = gl;\n\n      // Blending:\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Prepare frame buffer for picking layers:\n      if (options.picking) {\n        this.pickingLayers.add(id);\n        var newFrameBuffer = gl.createFramebuffer();\n        if (!newFrameBuffer) throw new Error(\"Sigma: cannot create a new frame buffer for layer \".concat(id));\n        this.frameBuffers[id] = newFrameBuffer;\n      }\n      return gl;\n    }\n\n    /**\n     * Function used to properly kill a layer.\n     *\n     * @param  {string} id - Layer id.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"killLayer\",\n    value: function killLayer(id) {\n      var element = this.elements[id];\n      if (!element) throw new Error(\"Sigma: cannot kill layer \".concat(id, \", which does not exist\"));\n      if (this.webGLContexts[id]) {\n        var _gl$getExtension;\n        var gl = this.webGLContexts[id];\n        (_gl$getExtension = gl.getExtension(\"WEBGL_lose_context\")) === null || _gl$getExtension === void 0 || _gl$getExtension.loseContext();\n        delete this.webGLContexts[id];\n      } else if (this.canvasContexts[id]) {\n        delete this.canvasContexts[id];\n      }\n\n      // Delete layer element\n      element.remove();\n      delete this.elements[id];\n      return this;\n    }\n\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"getCamera\",\n    value: function getCamera() {\n      return this.camera;\n    }\n\n    /**\n     * Method setting the renderer's camera.\n     *\n     * @param  {Camera} camera - New camera.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCamera\",\n    value: function setCamera(camera) {\n      this.unbindCameraHandlers();\n      this.camera = camera;\n      this.bindCameraHandlers();\n    }\n\n    /**\n     * Method returning the container DOM element.\n     *\n     * @return {HTMLElement}\n     */\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.container;\n    }\n\n    /**\n     * Method returning the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"getGraph\",\n    value: function getGraph() {\n      return this.graph;\n    }\n\n    /**\n     * Method used to set the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"setGraph\",\n    value: function setGraph(graph) {\n      if (graph === this.graph) return;\n\n      // Check hoveredNode and hoveredEdge\n      if (this.hoveredNode && !graph.hasNode(this.hoveredNode)) this.hoveredNode = null;\n      if (this.hoveredEdge && !graph.hasEdge(this.hoveredEdge)) this.hoveredEdge = null;\n\n      // Unbinding handlers on the current graph\n      this.unbindGraphHandlers();\n      if (this.checkEdgesEventsFrame !== null) {\n        cancelAnimationFrame(this.checkEdgesEventsFrame);\n        this.checkEdgesEventsFrame = null;\n      }\n\n      // Installing new graph\n      this.graph = graph;\n\n      // Binding new handlers\n      this.bindGraphHandlers();\n\n      // Re-rendering now to avoid discrepancies from now to next frame\n      this.refresh();\n    }\n\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {MouseCaptor}\n     */\n  }, {\n    key: \"getMouseCaptor\",\n    value: function getMouseCaptor() {\n      return this.mouseCaptor;\n    }\n\n    /**\n     * Method returning the touch captor.\n     *\n     * @return {TouchCaptor}\n     */\n  }, {\n    key: \"getTouchCaptor\",\n    value: function getTouchCaptor() {\n      return this.touchCaptor;\n    }\n\n    /**\n     * Method returning the current renderer's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n\n    /**\n     * Method returning the current graph's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getGraphDimensions\",\n    value: function getGraphDimensions() {\n      var extent = this.customBBox || this.nodeExtent;\n      return {\n        width: extent.x[1] - extent.x[0] || 1,\n        height: extent.y[1] - extent.y[0] || 1\n      };\n    }\n\n    /**\n     * Method used to get all the sigma node attributes.\n     * It's useful for example to get the position of a node\n     * and to get values that are set by the nodeReducer\n     *\n     * @param  {string} key - The node's key.\n     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n     */\n  }, {\n    key: \"getNodeDisplayData\",\n    value: function getNodeDisplayData(key) {\n      var node = this.nodeDataCache[key];\n      return node ? Object.assign({}, node) : undefined;\n    }\n\n    /**\n     * Method used to get all the sigma edge attributes.\n     * It's useful for example to get values that are set by the edgeReducer.\n     *\n     * @param  {string} key - The edge's key.\n     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n     */\n  }, {\n    key: \"getEdgeDisplayData\",\n    value: function getEdgeDisplayData(key) {\n      var edge = this.edgeDataCache[key];\n      return edge ? Object.assign({}, edge) : undefined;\n    }\n\n    /**\n     * Method used to get the set of currently displayed node labels.\n     *\n     * @return {Set<string>} A set of node keys whose label is displayed.\n     */\n  }, {\n    key: \"getNodeDisplayedLabels\",\n    value: function getNodeDisplayedLabels() {\n      return new Set(this.displayedNodeLabels);\n    }\n\n    /**\n     * Method used to get the set of currently displayed edge labels.\n     *\n     * @return {Set<string>} A set of edge keys whose label is displayed.\n     */\n  }, {\n    key: \"getEdgeDisplayedLabels\",\n    value: function getEdgeDisplayedLabels() {\n      return new Set(this.displayedEdgeLabels);\n    }\n\n    /**\n     * Method returning a copy of the settings collection.\n     *\n     * @return {Settings} A copy of the settings collection.\n     */\n  }, {\n    key: \"getSettings\",\n    value: function getSettings() {\n      return _objectSpread2({}, this.settings);\n    }\n\n    /**\n     * Method returning the current value for a given setting key.\n     *\n     * @param  {string} key - The setting key to get.\n     * @return {any} The value attached to this setting key or undefined if not found\n     */\n  }, {\n    key: \"getSetting\",\n    value: function getSetting(key) {\n      return this.settings[key];\n    }\n\n    /**\n     * Method setting the value of a given setting key. Note that this will schedule\n     * a new render next frame.\n     *\n     * @param  {string} key - The setting key to set.\n     * @param  {any}    value - The value to set.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setSetting\",\n    value: function setSetting(key, value) {\n      var oldValues = _objectSpread2({}, this.settings);\n      this.settings[key] = value;\n      validateSettings(this.settings);\n      this.handleSettingsUpdate(oldValues);\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method updating the value of a given setting key using the provided function.\n     * Note that this will schedule a new render next frame.\n     *\n     * @param  {string}   key     - The setting key to set.\n     * @param  {function} updater - The update function.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"updateSetting\",\n    value: function updateSetting(key, updater) {\n      this.setSetting(key, updater(this.settings[key]));\n      return this;\n    }\n\n    /**\n     * Method setting multiple settings at once.\n     *\n     * @param  {Partial<Settings>} settings - The settings to set.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setSettings\",\n    value: function setSettings(settings) {\n      var oldValues = _objectSpread2({}, this.settings);\n      this.settings = _objectSpread2(_objectSpread2({}, this.settings), settings);\n      validateSettings(this.settings);\n      this.handleSettingsUpdate(oldValues);\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method used to resize the renderer.\n     *\n     * @param  {boolean} force - If true, then resize is processed even if size is unchanged (optional).\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resize\",\n    value: function resize(force) {\n      var previousWidth = this.width,\n        previousHeight = this.height;\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n      this.pixelRatio = getPixelRatio();\n      if (this.width === 0) {\n        if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n      if (this.height === 0) {\n        if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n\n      // If nothing has changed, we can stop right here\n      if (!force && previousWidth === this.width && previousHeight === this.height) return this;\n\n      // Sizing dom elements\n      for (var id in this.elements) {\n        var element = this.elements[id];\n        element.style.width = this.width + \"px\";\n        element.style.height = this.height + \"px\";\n      }\n\n      // Sizing canvas contexts\n      for (var _id in this.canvasContexts) {\n        this.elements[_id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        if (this.pixelRatio !== 1) this.canvasContexts[_id].scale(this.pixelRatio, this.pixelRatio);\n      }\n\n      // Sizing WebGL contexts\n      for (var _id2 in this.webGLContexts) {\n        this.elements[_id2].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id2].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        var gl = this.webGLContexts[_id2];\n        gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n\n        // Clear picking texture if needed\n        if (this.pickingLayers.has(_id2)) {\n          var currentTexture = this.textures[_id2];\n          if (currentTexture) gl.deleteTexture(currentTexture);\n        }\n      }\n      this.emit(\"resize\");\n      return this;\n    }\n\n    /**\n     * Method used to clear all the canvases.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.emit(\"beforeClear\");\n      this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n      this.emit(\"afterClear\");\n      return this;\n    }\n\n    /**\n     * Method used to refresh, i.e. force the renderer to reprocess graph\n     * data and render, but keep the state.\n     * - if a partialGraph is provided, we only reprocess those nodes & edges.\n     * - if schedule is TRUE, we schedule a render instead of sync render\n     * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh(opts) {\n      var _this10 = this;\n      var skipIndexation = (opts === null || opts === void 0 ? void 0 : opts.skipIndexation) !== undefined ? opts === null || opts === void 0 ? void 0 : opts.skipIndexation : false;\n      var schedule = (opts === null || opts === void 0 ? void 0 : opts.schedule) !== undefined ? opts.schedule : false;\n      var fullRefresh = !opts || !opts.partialGraph;\n      if (fullRefresh) {\n        // Re-index graph data\n        this.clearEdgeIndices();\n        this.clearNodeIndices();\n        this.graph.forEachNode(function (node) {\n          return _this10.addNode(node);\n        });\n        this.graph.forEachEdge(function (edge) {\n          return _this10.addEdge(edge);\n        });\n      } else {\n        var _opts$partialGraph, _opts$partialGraph2;\n        var nodes = ((_opts$partialGraph = opts.partialGraph) === null || _opts$partialGraph === void 0 ? void 0 : _opts$partialGraph.nodes) || [];\n        for (var i = 0, l = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0; i < l; i++) {\n          var node = nodes[i];\n          // Recompute node's data (ie. apply reducer)\n          this.updateNode(node);\n          // Add node to the program if layout is unchanged.\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var programIndex = this.nodeProgramIndex[node];\n            if (programIndex === undefined) throw new Error(\"Sigma: node \\\"\".concat(node, \"\\\" can't be repaint\"));\n            this.addNodeToProgram(node, this.nodeIndices[node], programIndex);\n          }\n        }\n        var edges = (opts === null || opts === void 0 || (_opts$partialGraph2 = opts.partialGraph) === null || _opts$partialGraph2 === void 0 ? void 0 : _opts$partialGraph2.edges) || [];\n        for (var _i4 = 0, _l4 = edges.length; _i4 < _l4; _i4++) {\n          var edge = edges[_i4];\n          // Recompute edge's data (ie. apply reducer)\n          this.updateEdge(edge);\n          // Add edge to the program\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var _programIndex = this.edgeProgramIndex[edge];\n            if (_programIndex === undefined) throw new Error(\"Sigma: edge \\\"\".concat(edge, \"\\\" can't be repaint\"));\n            this.addEdgeToProgram(edge, this.edgeIndices[edge], _programIndex);\n          }\n        }\n      }\n\n      // Do we need to call the process function ?\n      if (fullRefresh || !skipIndexation) this.needToProcess = true;\n      if (schedule) this.scheduleRender();else this.render();\n      return this;\n    }\n\n    /**\n     * Method used to schedule a render at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRender\",\n    value: function scheduleRender() {\n      var _this11 = this;\n      if (!this.renderFrame) {\n        this.renderFrame = requestAnimationFrame(function () {\n          _this11.render();\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n     * at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRefresh\",\n    value: function scheduleRefresh(opts) {\n      return this.refresh(_objectSpread2(_objectSpread2({}, opts), {}, {\n        schedule: true\n      }));\n    }\n\n    /**\n     * Method used to (un)zoom, while preserving the position of a viewport point.\n     * Used for instance to zoom \"on the mouse cursor\".\n     *\n     * @param viewportTarget\n     * @param newRatio\n     * @return {CameraState}\n     */\n  }, {\n    key: \"getViewportZoomedState\",\n    value: function getViewportZoomedState(viewportTarget, newRatio) {\n      var _this$camera$getState = this.camera.getState(),\n        ratio = _this$camera$getState.ratio,\n        angle = _this$camera$getState.angle,\n        x = _this$camera$getState.x,\n        y = _this$camera$getState.y;\n      var _this$settings2 = this.settings,\n        minCameraRatio = _this$settings2.minCameraRatio,\n        maxCameraRatio = _this$settings2.maxCameraRatio;\n      if (typeof maxCameraRatio === \"number\") newRatio = Math.min(newRatio, maxCameraRatio);\n      if (typeof minCameraRatio === \"number\") newRatio = Math.max(newRatio, minCameraRatio);\n      var ratioDiff = newRatio / ratio;\n      var center = {\n        x: this.width / 2,\n        y: this.height / 2\n      };\n      var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n      var graphCenterPosition = this.viewportToFramedGraph(center);\n      return {\n        angle: angle,\n        x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n        y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n        ratio: newRatio\n      };\n    }\n\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n  }, {\n    key: \"viewRectangle\",\n    value: function viewRectangle() {\n      var p1 = this.viewportToFramedGraph({\n          x: 0,\n          y: 0\n        }),\n        p2 = this.viewportToFramedGraph({\n          x: this.width,\n          y: 0\n        }),\n        h = this.viewportToFramedGraph({\n          x: 0,\n          y: this.height\n        });\n      return {\n        x1: p1.x,\n        y1: p1.y,\n        x2: p2.x,\n        y2: p2.y,\n        height: p2.y - h.y\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"framedGraphToViewport\",\n    value: function framedGraphToViewport(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n      var matrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding()) : this.matrix;\n      var viewportPos = multiplyVec2(matrix, coordinates);\n      return {\n        x: (1 + viewportPos.x) * this.width / 2,\n        y: (1 - viewportPos.y) * this.height / 2\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"viewportToFramedGraph\",\n    value: function viewportToFramedGraph(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n      var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? matrixFromCamera(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getStagePadding(), true) : this.invMatrix;\n      var res = multiplyVec2(invMatrix, {\n        x: coordinates.x / this.width * 2 - 1,\n        y: 1 - coordinates.y / this.height * 2\n      });\n      if (isNaN(res.x)) res.x = 0;\n      if (isNaN(res.y)) res.y = 0;\n      return res;\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n     * stage) to the graph system (the reference system of data as they are in the given graph instance).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  viewportPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"viewportToGraph\",\n    value: function viewportToGraph(viewportPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  graphPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"graphToViewport\",\n    value: function graphToViewport(graphPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n    }\n\n    /**\n     * Method returning the distance multiplier between the graph system and the\n     * viewport system.\n     */\n  }, {\n    key: \"getGraphToViewportRatio\",\n    value: function getGraphToViewportRatio() {\n      var graphP1 = {\n        x: 0,\n        y: 0\n      };\n      var graphP2 = {\n        x: 1,\n        y: 1\n      };\n      var graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n      var viewportP1 = this.graphToViewport(graphP1);\n      var viewportP2 = this.graphToViewport(graphP2);\n      var viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n      return viewportD / graphD;\n    }\n\n    /**\n     * Method returning the graph's bounding box.\n     *\n     * @return {{ x: Extent, y: Extent }}\n     */\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      return this.nodeExtent;\n    }\n\n    /**\n     * Method returning the graph's custom bounding box, if any.\n     *\n     * @return {{ x: Extent, y: Extent } | null}\n     */\n  }, {\n    key: \"getCustomBBox\",\n    value: function getCustomBBox() {\n      return this.customBBox;\n    }\n\n    /**\n     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCustomBBox\",\n    value: function setCustomBBox(customBBox) {\n      this.customBBox = customBBox;\n      this.scheduleRender();\n      return this;\n    }\n\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      // Emitting \"kill\" events so that plugins and such can cleanup\n      this.emit(\"kill\");\n\n      // Releasing events\n      this.removeAllListeners();\n\n      // Releasing camera handlers\n      this.unbindCameraHandlers();\n\n      // Releasing DOM events & captors\n      window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n      this.mouseCaptor.kill();\n      this.touchCaptor.kill();\n\n      // Releasing graph handlers\n      this.unbindGraphHandlers();\n\n      // Releasing cache & state\n      this.clearIndices();\n      this.clearState();\n      this.nodeDataCache = {};\n      this.edgeDataCache = {};\n      this.highlightedNodes.clear();\n\n      // Clearing frames\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n      if (this.renderHighlightedNodesFrame) {\n        cancelAnimationFrame(this.renderHighlightedNodesFrame);\n        this.renderHighlightedNodesFrame = null;\n      }\n\n      // Destroying canvases\n      var container = this.container;\n      while (container.firstChild) container.removeChild(container.firstChild);\n\n      // Destroying remaining collections\n      this.canvasContexts = {};\n      this.webGLContexts = {};\n      this.elements = {};\n\n      // Kill programs:\n      for (var type in this.nodePrograms) {\n        this.nodePrograms[type].kill();\n      }\n      for (var _type8 in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[_type8].kill();\n      }\n      for (var _type9 in this.edgePrograms) {\n        this.edgePrograms[_type9].kill();\n      }\n      this.nodePrograms = {};\n      this.nodeHoverPrograms = {};\n      this.edgePrograms = {};\n\n      // Kill all canvas/WebGL contexts\n      for (var id in this.elements) {\n        this.killLayer(id);\n      }\n    }\n\n    /**\n     * Method used to scale the given size according to the camera's ratio, i.e.\n     * zooming state.\n     *\n     * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n     * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n     * @return {number}              - The scaled size.\n     */\n  }, {\n    key: \"scaleSize\",\n    value: function scaleSize() {\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var cameraRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.camera.ratio;\n      return size / this.settings.zoomToSizeRatioFunction(cameraRatio) * (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1);\n    }\n\n    /**\n     * Method that returns the collection of all used canvases.\n     * At the moment, the instantiated canvases are the following, and in the\n     * following order in the DOM:\n     * - `edges`\n     * - `nodes`\n     * - `edgeLabels`\n     * - `labels`\n     * - `hovers`\n     * - `hoverNodes`\n     * - `mouse`\n     *\n     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n     */\n  }, {\n    key: \"getCanvases\",\n    value: function getCanvases() {\n      var res = {};\n      for (var layer in this.elements) if (this.elements[layer] instanceof HTMLCanvasElement) res[layer] = this.elements[layer];\n      return res;\n    }\n  }]);\n}(TypedEventEmitter);\n\n/**\n * Sigma.js Library Endpoint\n * =========================\n *\n * The library endpoint.\n * @module\n */\nvar Sigma = Sigma$1;\n\nexport { Camera, MouseCaptor, Sigma$1 as Sigma, TouchCaptor, Sigma as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
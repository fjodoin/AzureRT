{"ast":null,"code":"/**\n * Graphology Components\n * ======================\n *\n * Basic connected components-related functions.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar copyNode = require('graphology-utils/add-node').copyNode;\nvar copyEdge = require('graphology-utils/add-edge').copyEdge;\nvar DFSStack = require('graphology-indices/dfs-stack');\n\n/**\n * Function iterating over a graph's connected component using a callback.\n *\n * @param {Graph}    graph    - Target graph.\n * @param {function} callback - Iteration callback.\n */\nfunction forEachConnectedComponent(graph, callback) {\n  if (!isGraph(graph)) throw new Error('graphology-components: the given graph is not a valid graphology instance.');\n\n  // A null graph has no connected components by definition\n  if (!graph.order) return;\n  var stack = new DFSStack(graph);\n  var push = stack.push.bind(stack);\n  stack.forEachNodeYetUnseen(function (node) {\n    var component = [];\n    stack.push(node);\n    var source;\n    while (stack.size !== 0) {\n      source = stack.pop();\n      component.push(source);\n      graph.forEachNeighbor(source, push);\n    }\n    callback(component);\n  });\n}\nfunction forEachConnectedComponentOrder(graph, callback) {\n  if (!isGraph(graph)) throw new Error('graphology-components: the given graph is not a valid graphology instance.');\n\n  // A null graph has no connected components by definition\n  if (!graph.order) return;\n  var stack = new DFSStack(graph);\n  var push = stack.push.bind(stack);\n  stack.forEachNodeYetUnseen(function (node) {\n    var order = 0;\n    stack.push(node);\n    var source;\n    while (stack.size !== 0) {\n      source = stack.pop();\n      order++;\n      graph.forEachNeighbor(source, push);\n    }\n    callback(order);\n  });\n}\nfunction forEachConnectedComponentOrderWithEdgeFilter(graph, edgeFilter, callback) {\n  if (!isGraph(graph)) throw new Error('graphology-components: the given graph is not a valid graphology instance.');\n\n  // A null graph has no connected components by definition\n  if (!graph.order) return;\n  var stack = new DFSStack(graph);\n  var source;\n  function push(e, a, s, t, sa, ta, u) {\n    if (source === t) t = s;\n    if (!edgeFilter(e, a, s, t, sa, ta, u)) return;\n    stack.push(t);\n  }\n  stack.forEachNodeYetUnseen(function (node) {\n    var order = 0;\n    stack.push(node);\n    while (stack.size !== 0) {\n      source = stack.pop();\n      order++;\n      graph.forEachEdge(source, push);\n    }\n    callback(order);\n  });\n}\nfunction countConnectedComponents(graph) {\n  var n = 0;\n  forEachConnectedComponentOrder(graph, function () {\n    n++;\n  });\n  return n;\n}\n\n/**\n * Function returning a list of a graph's connected components as arrays\n * of node keys.\n *\n * @param  {Graph} graph - Target graph.\n * @return {array}\n */\nfunction connectedComponents(graph) {\n  var components = [];\n  forEachConnectedComponent(graph, function (component) {\n    components.push(component);\n  });\n  return components;\n}\n\n/**\n * Function returning the largest component of the given graph.\n *\n * @param  {Graph} graph - Target graph.\n * @return {array}\n */\nfunction largestConnectedComponent(graph) {\n  if (!isGraph(graph)) throw new Error('graphology-components: the given graph is not a valid graphology instance.');\n  if (!graph.order) return [];\n  var stack = new DFSStack(graph);\n  var push = stack.push.bind(stack);\n  var largestComponent = [];\n  var component;\n  stack.forEachNodeYetUnseen(function (node) {\n    component = [];\n    stack.push(node);\n    var source;\n    while (stack.size !== 0) {\n      source = stack.pop();\n      component.push(source);\n      graph.forEachNeighbor(source, push);\n    }\n    if (component.length > largestComponent.length) largestComponent = component;\n\n    // Early exit condition:\n    // If current largest component's size is larger than the number of\n    // remaining nodes to visit, we can safely assert we found the\n    // overall largest component already.\n    if (largestComponent.length > stack.countUnseenNodes()) return true;\n    return false;\n  });\n  return largestComponent;\n}\n\n/**\n * Function returning a subgraph composed of the largest component of the given graph.\n *\n * @param  {Graph} graph - Target graph.\n * @return {Graph}\n */\nfunction largestConnectedComponentSubgraph(graph) {\n  var component = largestConnectedComponent(graph);\n  var S = graph.nullCopy();\n  component.forEach(function (key) {\n    copyNode(S, key, graph.getNodeAttributes(key));\n  });\n  graph.forEachEdge(function (key, attr, source, target, sourceAttr, targetAttr, undirected) {\n    if (S.hasNode(source)) {\n      copyEdge(S, undirected, key, source, target, attr);\n    }\n  });\n  return S;\n}\n\n/**\n * Function mutating a graph in order to drop every node and edge that does\n * not belong to its largest connected component.\n *\n * @param  {Graph} graph - Target graph.\n */\nfunction cropToLargestConnectedComponent(graph) {\n  var component = new Set(largestConnectedComponent(graph));\n  graph.forEachNode(function (key) {\n    if (!component.has(key)) {\n      graph.dropNode(key);\n    }\n  });\n}\n\n/**\n * Function returning a list of strongly connected components.\n *\n * @param  {Graph} graph - Target directed graph.\n * @return {array}\n */\nfunction stronglyConnectedComponents(graph) {\n  if (!isGraph(graph)) throw new Error('graphology-components: the given graph is not a valid graphology instance.');\n  if (!graph.order) return [];\n  if (graph.type === 'undirected') throw new Error('graphology-components: the given graph is undirected');\n  var nodes = graph.nodes(),\n    components = [],\n    i,\n    l;\n  if (!graph.size) {\n    for (i = 0, l = nodes.length; i < l; i++) components.push([nodes[i]]);\n    return components;\n  }\n  var count = 1,\n    P = [],\n    S = [],\n    preorder = new Map(),\n    assigned = new Set(),\n    component,\n    pop,\n    vertex;\n  var DFS = function (node) {\n    var neighbor;\n    var neighbors = graph.outboundNeighbors(node);\n    var neighborOrder;\n    preorder.set(node, count++);\n    P.push(node);\n    S.push(node);\n    for (var k = 0, n = neighbors.length; k < n; k++) {\n      neighbor = neighbors[k];\n      if (preorder.has(neighbor)) {\n        neighborOrder = preorder.get(neighbor);\n        if (!assigned.has(neighbor)) while (preorder.get(P[P.length - 1]) > neighborOrder) P.pop();\n      } else {\n        DFS(neighbor);\n      }\n    }\n    if (preorder.get(P[P.length - 1]) === preorder.get(node)) {\n      component = [];\n      do {\n        pop = S.pop();\n        component.push(pop);\n        assigned.add(pop);\n      } while (pop !== node);\n      components.push(component);\n      P.pop();\n    }\n  };\n  for (i = 0, l = nodes.length; i < l; i++) {\n    vertex = nodes[i];\n    if (!assigned.has(vertex)) DFS(vertex);\n  }\n  return components;\n}\n\n/**\n * Exporting.\n */\nexports.forEachConnectedComponent = forEachConnectedComponent;\nexports.forEachConnectedComponentOrder = forEachConnectedComponentOrder;\nexports.forEachConnectedComponentOrderWithEdgeFilter = forEachConnectedComponentOrderWithEdgeFilter;\nexports.countConnectedComponents = countConnectedComponents;\nexports.connectedComponents = connectedComponents;\nexports.largestConnectedComponent = largestConnectedComponent;\nexports.largestConnectedComponentSubgraph = largestConnectedComponentSubgraph;\nexports.cropToLargestConnectedComponent = cropToLargestConnectedComponent;\nexports.stronglyConnectedComponents = stronglyConnectedComponents;","map":{"version":3,"names":["isGraph","require","copyNode","copyEdge","DFSStack","forEachConnectedComponent","graph","callback","Error","order","stack","push","bind","forEachNodeYetUnseen","node","component","source","size","pop","forEachNeighbor","forEachConnectedComponentOrder","forEachConnectedComponentOrderWithEdgeFilter","edgeFilter","e","a","s","t","sa","ta","u","forEachEdge","countConnectedComponents","n","connectedComponents","components","largestConnectedComponent","largestComponent","length","countUnseenNodes","largestConnectedComponentSubgraph","S","nullCopy","forEach","key","getNodeAttributes","attr","target","sourceAttr","targetAttr","undirected","hasNode","cropToLargestConnectedComponent","Set","forEachNode","has","dropNode","stronglyConnectedComponents","type","nodes","i","l","count","P","preorder","Map","assigned","vertex","DFS","neighbor","neighbors","outboundNeighbors","neighborOrder","set","k","get","add","exports"],"sources":["/Users/fjodoin/Desktop/Research/AzureRT/azure_resource_graph/training/graphing/sigma-graph/node_modules/graphology-components/index.js"],"sourcesContent":["/**\n * Graphology Components\n * ======================\n *\n * Basic connected components-related functions.\n */\nvar isGraph = require('graphology-utils/is-graph');\nvar copyNode = require('graphology-utils/add-node').copyNode;\nvar copyEdge = require('graphology-utils/add-edge').copyEdge;\nvar DFSStack = require('graphology-indices/dfs-stack');\n\n/**\n * Function iterating over a graph's connected component using a callback.\n *\n * @param {Graph}    graph    - Target graph.\n * @param {function} callback - Iteration callback.\n */\nfunction forEachConnectedComponent(graph, callback) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-components: the given graph is not a valid graphology instance.'\n    );\n\n  // A null graph has no connected components by definition\n  if (!graph.order) return;\n\n  var stack = new DFSStack(graph);\n  var push = stack.push.bind(stack);\n\n  stack.forEachNodeYetUnseen(function (node) {\n    var component = [];\n\n    stack.push(node);\n\n    var source;\n\n    while (stack.size !== 0) {\n      source = stack.pop();\n\n      component.push(source);\n\n      graph.forEachNeighbor(source, push);\n    }\n\n    callback(component);\n  });\n}\n\nfunction forEachConnectedComponentOrder(graph, callback) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-components: the given graph is not a valid graphology instance.'\n    );\n\n  // A null graph has no connected components by definition\n  if (!graph.order) return;\n\n  var stack = new DFSStack(graph);\n  var push = stack.push.bind(stack);\n\n  stack.forEachNodeYetUnseen(function (node) {\n    var order = 0;\n\n    stack.push(node);\n\n    var source;\n\n    while (stack.size !== 0) {\n      source = stack.pop();\n\n      order++;\n\n      graph.forEachNeighbor(source, push);\n    }\n\n    callback(order);\n  });\n}\n\nfunction forEachConnectedComponentOrderWithEdgeFilter(\n  graph,\n  edgeFilter,\n  callback\n) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-components: the given graph is not a valid graphology instance.'\n    );\n\n  // A null graph has no connected components by definition\n  if (!graph.order) return;\n\n  var stack = new DFSStack(graph);\n\n  var source;\n\n  function push(e, a, s, t, sa, ta, u) {\n    if (source === t) t = s;\n\n    if (!edgeFilter(e, a, s, t, sa, ta, u)) return;\n\n    stack.push(t);\n  }\n\n  stack.forEachNodeYetUnseen(function (node) {\n    var order = 0;\n\n    stack.push(node);\n\n    while (stack.size !== 0) {\n      source = stack.pop();\n\n      order++;\n\n      graph.forEachEdge(source, push);\n    }\n\n    callback(order);\n  });\n}\n\nfunction countConnectedComponents(graph) {\n  var n = 0;\n\n  forEachConnectedComponentOrder(graph, function () {\n    n++;\n  });\n\n  return n;\n}\n\n/**\n * Function returning a list of a graph's connected components as arrays\n * of node keys.\n *\n * @param  {Graph} graph - Target graph.\n * @return {array}\n */\nfunction connectedComponents(graph) {\n  var components = [];\n\n  forEachConnectedComponent(graph, function (component) {\n    components.push(component);\n  });\n\n  return components;\n}\n\n/**\n * Function returning the largest component of the given graph.\n *\n * @param  {Graph} graph - Target graph.\n * @return {array}\n */\nfunction largestConnectedComponent(graph) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-components: the given graph is not a valid graphology instance.'\n    );\n\n  if (!graph.order) return [];\n\n  var stack = new DFSStack(graph);\n  var push = stack.push.bind(stack);\n\n  var largestComponent = [];\n  var component;\n\n  stack.forEachNodeYetUnseen(function (node) {\n    component = [];\n\n    stack.push(node);\n\n    var source;\n\n    while (stack.size !== 0) {\n      source = stack.pop();\n\n      component.push(source);\n\n      graph.forEachNeighbor(source, push);\n    }\n\n    if (component.length > largestComponent.length)\n      largestComponent = component;\n\n    // Early exit condition:\n    // If current largest component's size is larger than the number of\n    // remaining nodes to visit, we can safely assert we found the\n    // overall largest component already.\n    if (largestComponent.length > stack.countUnseenNodes()) return true;\n\n    return false;\n  });\n\n  return largestComponent;\n}\n\n/**\n * Function returning a subgraph composed of the largest component of the given graph.\n *\n * @param  {Graph} graph - Target graph.\n * @return {Graph}\n */\nfunction largestConnectedComponentSubgraph(graph) {\n  var component = largestConnectedComponent(graph);\n\n  var S = graph.nullCopy();\n\n  component.forEach(function (key) {\n    copyNode(S, key, graph.getNodeAttributes(key));\n  });\n\n  graph.forEachEdge(function (\n    key,\n    attr,\n    source,\n    target,\n    sourceAttr,\n    targetAttr,\n    undirected\n  ) {\n    if (S.hasNode(source)) {\n      copyEdge(S, undirected, key, source, target, attr);\n    }\n  });\n\n  return S;\n}\n\n/**\n * Function mutating a graph in order to drop every node and edge that does\n * not belong to its largest connected component.\n *\n * @param  {Graph} graph - Target graph.\n */\nfunction cropToLargestConnectedComponent(graph) {\n  var component = new Set(largestConnectedComponent(graph));\n\n  graph.forEachNode(function (key) {\n    if (!component.has(key)) {\n      graph.dropNode(key);\n    }\n  });\n}\n\n/**\n * Function returning a list of strongly connected components.\n *\n * @param  {Graph} graph - Target directed graph.\n * @return {array}\n */\nfunction stronglyConnectedComponents(graph) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-components: the given graph is not a valid graphology instance.'\n    );\n\n  if (!graph.order) return [];\n\n  if (graph.type === 'undirected')\n    throw new Error('graphology-components: the given graph is undirected');\n\n  var nodes = graph.nodes(),\n    components = [],\n    i,\n    l;\n\n  if (!graph.size) {\n    for (i = 0, l = nodes.length; i < l; i++) components.push([nodes[i]]);\n    return components;\n  }\n\n  var count = 1,\n    P = [],\n    S = [],\n    preorder = new Map(),\n    assigned = new Set(),\n    component,\n    pop,\n    vertex;\n\n  var DFS = function (node) {\n    var neighbor;\n    var neighbors = graph.outboundNeighbors(node);\n    var neighborOrder;\n\n    preorder.set(node, count++);\n    P.push(node);\n    S.push(node);\n\n    for (var k = 0, n = neighbors.length; k < n; k++) {\n      neighbor = neighbors[k];\n\n      if (preorder.has(neighbor)) {\n        neighborOrder = preorder.get(neighbor);\n        if (!assigned.has(neighbor))\n          while (preorder.get(P[P.length - 1]) > neighborOrder) P.pop();\n      } else {\n        DFS(neighbor);\n      }\n    }\n\n    if (preorder.get(P[P.length - 1]) === preorder.get(node)) {\n      component = [];\n      do {\n        pop = S.pop();\n        component.push(pop);\n        assigned.add(pop);\n      } while (pop !== node);\n      components.push(component);\n      P.pop();\n    }\n  };\n\n  for (i = 0, l = nodes.length; i < l; i++) {\n    vertex = nodes[i];\n    if (!assigned.has(vertex)) DFS(vertex);\n  }\n\n  return components;\n}\n\n/**\n * Exporting.\n */\nexports.forEachConnectedComponent = forEachConnectedComponent;\nexports.forEachConnectedComponentOrder = forEachConnectedComponentOrder;\nexports.forEachConnectedComponentOrderWithEdgeFilter =\n  forEachConnectedComponentOrderWithEdgeFilter;\nexports.countConnectedComponents = countConnectedComponents;\nexports.connectedComponents = connectedComponents;\nexports.largestConnectedComponent = largestConnectedComponent;\nexports.largestConnectedComponentSubgraph = largestConnectedComponentSubgraph;\nexports.cropToLargestConnectedComponent = cropToLargestConnectedComponent;\nexports.stronglyConnectedComponents = stronglyConnectedComponents;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
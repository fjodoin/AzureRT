{"ast":null,"code":"/**\n * Graphology Force Layout Iteration\n * ==================================\n *\n * Function describing a single iteration of the force layout.\n */\nconst {\n  createNodeValueGetter,\n  createEdgeValueGetter\n} = require('graphology-utils/getters');\n\n// const EPSILON = -Infinity;\n\n// function isVeryCloseToZero(x) {\n//   return Math.abs(x) < EPSILON;\n// }\n\nmodule.exports = function iterate(graph, nodeStates, params) {\n  const {\n    nodeXAttribute: xKey,\n    nodeYAttribute: yKey\n  } = params;\n  const {\n    attraction,\n    repulsion,\n    gravity,\n    inertia,\n    maxMove\n  } = params.settings;\n  let {\n    shouldSkipNode,\n    shouldSkipEdge,\n    isNodeFixed\n  } = params;\n  isNodeFixed = createNodeValueGetter(isNodeFixed);\n  shouldSkipNode = createNodeValueGetter(shouldSkipNode, false);\n  shouldSkipEdge = createEdgeValueGetter(shouldSkipEdge, false);\n  const nodes = graph.filterNodes((n, attr) => {\n    return !shouldSkipNode.fromEntry(n, attr);\n  });\n  const adjustedOrder = nodes.length;\n\n  // Check nodeStatess and inertia\n  for (let i = 0; i < adjustedOrder; i++) {\n    const n = nodes[i];\n    const attr = graph.getNodeAttributes(n);\n    const nodeState = nodeStates[n];\n    if (!nodeState) nodeStates[n] = {\n      dx: 0,\n      dy: 0,\n      x: attr[xKey] || 0,\n      y: attr[yKey] || 0\n    };else nodeStates[n] = {\n      dx: nodeState.dx * inertia,\n      dy: nodeState.dy * inertia,\n      x: attr[xKey] || 0,\n      y: attr[yKey] || 0\n    };\n  }\n\n  // Repulsion\n  if (repulsion) for (let i = 0; i < adjustedOrder; i++) {\n    const n1 = nodes[i];\n    const n1State = nodeStates[n1];\n    for (let j = i + 1; j < adjustedOrder; j++) {\n      const n2 = nodes[j];\n      const n2State = nodeStates[n2];\n\n      // Compute distance:\n      const dx = n2State.x - n1State.x;\n      const dy = n2State.y - n1State.y;\n      const distance = Math.sqrt(dx * dx + dy * dy) || 1;\n\n      // Repulse nodes relatively to 1 / distance:\n      const repulsionX = repulsion / distance * dx;\n      const repulsionY = repulsion / distance * dy;\n      n1State.dx -= repulsionX;\n      n1State.dy -= repulsionY;\n      n2State.dx += repulsionX;\n      n2State.dy += repulsionY;\n    }\n  }\n\n  // Attraction\n  if (attraction) graph.forEachEdge((edge, attr, source, target, sourceAttr, targetAttr, undirected) => {\n    if (source === target) return;\n    if (shouldSkipNode.fromEntry(source, sourceAttr) || shouldSkipNode.fromEntry(target, targetAttr)) return;\n    if (shouldSkipEdge.fromEntry(edge, attr, source, target, sourceAttr, targetAttr, undirected)) return;\n    const n1State = nodeStates[source];\n    const n2State = nodeStates[target];\n\n    // Compute distance:\n    const dx = n2State.x - n1State.x;\n    const dy = n2State.y - n1State.y;\n    const distance = Math.sqrt(dx * dx + dy * dy) || 1;\n\n    // Attract nodes relatively to their distance:\n    const attractionX = attraction * distance * dx;\n    const attractionY = attraction * distance * dy;\n    n1State.dx += attractionX;\n    n1State.dy += attractionY;\n    n2State.dx -= attractionX;\n    n2State.dy -= attractionY;\n  });\n\n  // Gravity\n  if (gravity) for (let i = 0; i < adjustedOrder; i++) {\n    const n = nodes[i];\n    const nodeState = nodeStates[n];\n\n    // Attract nodes to [0, 0] relatively to the distance:\n    const {\n      x,\n      y\n    } = nodeState;\n    const distance = Math.sqrt(x * x + y * y) || 1;\n    nodeStates[n].dx -= x * gravity * distance;\n    nodeStates[n].dy -= y * gravity * distance;\n  }\n\n  // Apply forces\n  const converged = false;\n  for (let i = 0; i < adjustedOrder; i++) {\n    const n = nodes[i];\n    const nodeState = nodeStates[n];\n    const distance = Math.sqrt(nodeState.dx * nodeState.dx + nodeState.dy * nodeState.dy);\n    if (distance > maxMove) {\n      nodeState.dx *= maxMove / distance;\n      nodeState.dy *= maxMove / distance;\n    }\n\n    // if (!isVeryCloseToZero(nodeState.dx) || !isVeryCloseToZero(nodeState.dy)) {\n    //   converged = false;\n    // }\n\n    if (!isNodeFixed.fromGraph(graph, n)) {\n      nodeState.x += nodeState.dx;\n      nodeState.y += nodeState.dy;\n      nodeState.fixed = false;\n    } else {\n      nodeState.fixed = true;\n    }\n\n    // NOTE: possibility to assign here to save one loop in the future\n  }\n  return {\n    converged\n  };\n};","map":{"version":3,"names":["createNodeValueGetter","createEdgeValueGetter","require","module","exports","iterate","graph","nodeStates","params","nodeXAttribute","xKey","nodeYAttribute","yKey","attraction","repulsion","gravity","inertia","maxMove","settings","shouldSkipNode","shouldSkipEdge","isNodeFixed","nodes","filterNodes","n","attr","fromEntry","adjustedOrder","length","i","getNodeAttributes","nodeState","dx","dy","x","y","n1","n1State","j","n2","n2State","distance","Math","sqrt","repulsionX","repulsionY","forEachEdge","edge","source","target","sourceAttr","targetAttr","undirected","attractionX","attractionY","converged","fromGraph","fixed"],"sources":["/Users/fjodoin/Desktop/Research/AzureRT/azure_resource_graph/training/graphing/sigma-graph/node_modules/graphology-layout-force/iterate.js"],"sourcesContent":["/**\n * Graphology Force Layout Iteration\n * ==================================\n *\n * Function describing a single iteration of the force layout.\n */\nconst {\n  createNodeValueGetter,\n  createEdgeValueGetter\n} = require('graphology-utils/getters');\n\n// const EPSILON = -Infinity;\n\n// function isVeryCloseToZero(x) {\n//   return Math.abs(x) < EPSILON;\n// }\n\nmodule.exports = function iterate(graph, nodeStates, params) {\n  const {nodeXAttribute: xKey, nodeYAttribute: yKey} = params;\n  const {attraction, repulsion, gravity, inertia, maxMove} = params.settings;\n\n  let {shouldSkipNode, shouldSkipEdge, isNodeFixed} = params;\n\n  isNodeFixed = createNodeValueGetter(isNodeFixed);\n  shouldSkipNode = createNodeValueGetter(shouldSkipNode, false);\n  shouldSkipEdge = createEdgeValueGetter(shouldSkipEdge, false);\n\n  const nodes = graph.filterNodes((n, attr) => {\n    return !shouldSkipNode.fromEntry(n, attr);\n  });\n\n  const adjustedOrder = nodes.length;\n\n  // Check nodeStatess and inertia\n  for (let i = 0; i < adjustedOrder; i++) {\n    const n = nodes[i];\n    const attr = graph.getNodeAttributes(n);\n    const nodeState = nodeStates[n];\n\n    if (!nodeState)\n      nodeStates[n] = {\n        dx: 0,\n        dy: 0,\n        x: attr[xKey] || 0,\n        y: attr[yKey] || 0\n      };\n    else\n      nodeStates[n] = {\n        dx: nodeState.dx * inertia,\n        dy: nodeState.dy * inertia,\n        x: attr[xKey] || 0,\n        y: attr[yKey] || 0\n      };\n  }\n\n  // Repulsion\n  if (repulsion)\n    for (let i = 0; i < adjustedOrder; i++) {\n      const n1 = nodes[i];\n      const n1State = nodeStates[n1];\n\n      for (let j = i + 1; j < adjustedOrder; j++) {\n        const n2 = nodes[j];\n        const n2State = nodeStates[n2];\n\n        // Compute distance:\n        const dx = n2State.x - n1State.x;\n        const dy = n2State.y - n1State.y;\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\n\n        // Repulse nodes relatively to 1 / distance:\n        const repulsionX = (repulsion / distance) * dx;\n        const repulsionY = (repulsion / distance) * dy;\n        n1State.dx -= repulsionX;\n        n1State.dy -= repulsionY;\n        n2State.dx += repulsionX;\n        n2State.dy += repulsionY;\n      }\n    }\n\n  // Attraction\n  if (attraction)\n    graph.forEachEdge(\n      (edge, attr, source, target, sourceAttr, targetAttr, undirected) => {\n        if (source === target) return;\n\n        if (\n          shouldSkipNode.fromEntry(source, sourceAttr) ||\n          shouldSkipNode.fromEntry(target, targetAttr)\n        )\n          return;\n\n        if (\n          shouldSkipEdge.fromEntry(\n            edge,\n            attr,\n            source,\n            target,\n            sourceAttr,\n            targetAttr,\n            undirected\n          )\n        )\n          return;\n\n        const n1State = nodeStates[source];\n        const n2State = nodeStates[target];\n\n        // Compute distance:\n        const dx = n2State.x - n1State.x;\n        const dy = n2State.y - n1State.y;\n\n        const distance = Math.sqrt(dx * dx + dy * dy) || 1;\n\n        // Attract nodes relatively to their distance:\n        const attractionX = attraction * distance * dx;\n        const attractionY = attraction * distance * dy;\n        n1State.dx += attractionX;\n        n1State.dy += attractionY;\n        n2State.dx -= attractionX;\n        n2State.dy -= attractionY;\n      }\n    );\n\n  // Gravity\n  if (gravity)\n    for (let i = 0; i < adjustedOrder; i++) {\n      const n = nodes[i];\n      const nodeState = nodeStates[n];\n\n      // Attract nodes to [0, 0] relatively to the distance:\n      const {x, y} = nodeState;\n      const distance = Math.sqrt(x * x + y * y) || 1;\n      nodeStates[n].dx -= x * gravity * distance;\n      nodeStates[n].dy -= y * gravity * distance;\n    }\n\n  // Apply forces\n  const converged = false;\n\n  for (let i = 0; i < adjustedOrder; i++) {\n    const n = nodes[i];\n    const nodeState = nodeStates[n];\n\n    const distance = Math.sqrt(\n      nodeState.dx * nodeState.dx + nodeState.dy * nodeState.dy\n    );\n\n    if (distance > maxMove) {\n      nodeState.dx *= maxMove / distance;\n      nodeState.dy *= maxMove / distance;\n    }\n\n    // if (!isVeryCloseToZero(nodeState.dx) || !isVeryCloseToZero(nodeState.dy)) {\n    //   converged = false;\n    // }\n\n    if (!isNodeFixed.fromGraph(graph, n)) {\n      nodeState.x += nodeState.dx;\n      nodeState.y += nodeState.dy;\n      nodeState.fixed = false;\n    } else {\n      nodeState.fixed = true;\n    }\n\n    // NOTE: possibility to assign here to save one loop in the future\n  }\n\n  return {converged};\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}
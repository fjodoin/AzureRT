{"ast":null,"code":"import { EdgeProgram, DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS } from 'sigma/rendering';\nimport { floatColor } from 'sigma/utils';\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction getCurvePoint(t, p0, p1, p2) {\n  var x = Math.pow(1 - t, 2) * p0.x + 2 * (1 - t) * t * p1.x + Math.pow(t, 2) * p2.x;\n  var y = Math.pow(1 - t, 2) * p0.y + 2 * (1 - t) * t * p1.y + Math.pow(t, 2) * p2.y;\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction getCurveLength(p0, p1, p2) {\n  var steps = 20;\n  var length = 0;\n  var lastPoint = p0;\n  for (var i = 0; i < steps; i++) {\n    var point = getCurvePoint((i + 1) / steps, p0, p1, p2);\n    length += Math.sqrt(Math.pow(lastPoint.x - point.x, 2) + Math.pow(lastPoint.y - point.y, 2));\n    lastPoint = point;\n  }\n  return length;\n}\nfunction createDrawCurvedEdgeLabel(_ref) {\n  var curvatureAttribute = _ref.curvatureAttribute,\n    defaultCurvature = _ref.defaultCurvature,\n    _ref$keepLabelUpright = _ref.keepLabelUpright,\n    keepLabelUpright = _ref$keepLabelUpright === void 0 ? true : _ref$keepLabelUpright;\n  return function (context, edgeData, sourceData, targetData, settings) {\n    var size = settings.edgeLabelSize,\n      curvature = edgeData[curvatureAttribute] || defaultCurvature,\n      font = settings.edgeLabelFont,\n      weight = settings.edgeLabelWeight,\n      color = settings.edgeLabelColor.attribute ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\" : settings.edgeLabelColor.color;\n    var label = edgeData.label;\n    if (!label) return;\n    context.fillStyle = color;\n    context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n\n    // Computing positions without considering nodes sizes:\n    var ltr = !keepLabelUpright || sourceData.x < targetData.x;\n    var sourceX = ltr ? sourceData.x : targetData.x;\n    var sourceY = ltr ? sourceData.y : targetData.y;\n    var targetX = ltr ? targetData.x : sourceData.x;\n    var targetY = ltr ? targetData.y : sourceData.y;\n    var centerX = (sourceX + targetX) / 2;\n    var centerY = (sourceY + targetY) / 2;\n    var diffX = targetX - sourceX;\n    var diffY = targetY - sourceY;\n    var diff = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));\n    // Anchor point:\n    var orientation = ltr ? 1 : -1;\n    var anchorX = centerX + diffY * curvature * orientation;\n    var anchorY = centerY - diffX * curvature * orientation;\n\n    // Adapt curve points to edge thickness:\n    var offset = edgeData.size * 0.7 + 5;\n    var sourceOffsetVector = {\n      x: anchorY - sourceY,\n      y: -(anchorX - sourceX)\n    };\n    var sourceOffsetVectorLength = Math.sqrt(Math.pow(sourceOffsetVector.x, 2) + Math.pow(sourceOffsetVector.y, 2));\n    var targetOffsetVector = {\n      x: targetY - anchorY,\n      y: -(targetX - anchorX)\n    };\n    var targetOffsetVectorLength = Math.sqrt(Math.pow(targetOffsetVector.x, 2) + Math.pow(targetOffsetVector.y, 2));\n    sourceX += offset * sourceOffsetVector.x / sourceOffsetVectorLength;\n    sourceY += offset * sourceOffsetVector.y / sourceOffsetVectorLength;\n    targetX += offset * targetOffsetVector.x / targetOffsetVectorLength;\n    targetY += offset * targetOffsetVector.y / targetOffsetVectorLength;\n    // For anchor, the vector is simpler, so it is inlined:\n    anchorX += offset * diffY / diff;\n    anchorY -= offset * diffX / diff;\n\n    // Compute curve length:\n    var anchorPoint = {\n      x: anchorX,\n      y: anchorY\n    };\n    var sourcePoint = {\n      x: sourceX,\n      y: sourceY\n    };\n    var targetPoint = {\n      x: targetX,\n      y: targetY\n    };\n    var curveLength = getCurveLength(sourcePoint, anchorPoint, targetPoint);\n    if (curveLength < sourceData.size + targetData.size) return;\n\n    // Handling ellipsis\n    var textLength = context.measureText(label).width;\n    var availableTextLength = curveLength - sourceData.size - targetData.size;\n    if (textLength > availableTextLength) {\n      var ellipsis = \"â€¦\";\n      label = label + ellipsis;\n      textLength = context.measureText(label).width;\n      while (textLength > availableTextLength && label.length > 1) {\n        label = label.slice(0, -2) + ellipsis;\n        textLength = context.measureText(label).width;\n      }\n      if (label.length < 4) return;\n    }\n\n    // Measure each character:\n    var charactersLengthCache = {};\n    for (var i = 0, length = label.length; i < length; i++) {\n      var character = label[i];\n      if (!charactersLengthCache[character]) {\n        charactersLengthCache[character] = context.measureText(character).width * (1 + curvature * 0.35);\n      }\n    }\n\n    // Draw each character:\n    var t = 0.5 - textLength / curveLength / 2;\n    for (var _i = 0, _length = label.length; _i < _length; _i++) {\n      var _character = label[_i];\n      var point = getCurvePoint(t, sourcePoint, anchorPoint, targetPoint);\n      var tangentX = 2 * (1 - t) * (anchorX - sourceX) + 2 * t * (targetX - anchorX);\n      var tangentY = 2 * (1 - t) * (anchorY - sourceY) + 2 * t * (targetY - anchorY);\n      var angle = Math.atan2(tangentY, tangentX);\n      context.save();\n      context.translate(point.x, point.y);\n      context.rotate(angle);\n\n      // Dessiner le caractÃ¨re\n      context.fillText(_character, 0, 0);\n      context.restore();\n      t += charactersLengthCache[_character] / curveLength;\n    }\n  };\n}\nfunction getFragmentShader(_ref) {\n  var arrowHead = _ref.arrowHead;\n  var hasTargetArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"target\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n  var hasSourceArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"source\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n\n  // language=GLSL\n  var SHADER = /*glsl*/\"\\nprecision highp float;\\n\\nvarying vec4 v_color;\\nvarying float v_thickness;\\nvarying float v_feather;\\nvarying vec2 v_cpA;\\nvarying vec2 v_cpB;\\nvarying vec2 v_cpC;\\n\".concat(hasTargetArrowHead ? \"\\nvarying float v_targetSize;\\nvarying vec2 v_targetPoint;\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"\\nvarying float v_sourceSize;\\nvarying vec2 v_sourcePoint;\" : \"\", \"\\n\").concat(arrowHead ? \"\\nuniform float u_lengthToThicknessRatio;\\nuniform float u_widenessToThicknessRatio;\" : \"\", \"\\n\\nfloat det(vec2 a, vec2 b) {\\n  return a.x * b.y - b.x * a.y;\\n}\\n\\nvec2 getDistanceVector(vec2 b0, vec2 b1, vec2 b2) {\\n  float a = det(b0, b2), b = 2.0 * det(b1, b0), d = 2.0 * det(b2, b1);\\n  float f = b * d - a * a;\\n  vec2 d21 = b2 - b1, d10 = b1 - b0, d20 = b2 - b0;\\n  vec2 gf = 2.0 * (b * d21 + d * d10 + a * d20);\\n  gf = vec2(gf.y, -gf.x);\\n  vec2 pp = -f * gf / dot(gf, gf);\\n  vec2 d0p = b0 - pp;\\n  float ap = det(d0p, d20), bp = 2.0 * det(d10, d0p);\\n  float t = clamp((ap + bp) / (2.0 * a + b + d), 0.0, 1.0);\\n  return mix(mix(b0, b1, t), mix(b1, b2, t), t);\\n}\\n\\nfloat distToQuadraticBezierCurve(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\\n  return length(getDistanceVector(b0 - p, b1 - p, b2 - p));\\n}\\n\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  float dist = distToQuadraticBezierCurve(gl_FragCoord.xy, v_cpA, v_cpB, v_cpC);\\n  float thickness = v_thickness;\\n\").concat(hasTargetArrowHead ? \"\\n  float distToTarget = length(gl_FragCoord.xy - v_targetPoint);\\n  float targetArrowLength = v_targetSize + thickness * u_lengthToThicknessRatio;\\n  if (distToTarget < targetArrowLength) {\\n    thickness = (distToTarget - v_targetSize) / (targetArrowLength - v_targetSize) * u_widenessToThicknessRatio * thickness;\\n  }\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"\\n  float distToSource = length(gl_FragCoord.xy - v_sourcePoint);\\n  float sourceArrowLength = v_sourceSize + thickness * u_lengthToThicknessRatio;\\n  if (distToSource < sourceArrowLength) {\\n    thickness = (distToSource - v_sourceSize) / (sourceArrowLength - v_sourceSize) * u_widenessToThicknessRatio * thickness;\\n  }\" : \"\", \"\\n\\n  float halfThickness = thickness / 2.0;\\n  if (dist < halfThickness) {\\n    #ifdef PICKING_MODE\\n    gl_FragColor = v_color;\\n    #else\\n    float t = smoothstep(\\n      halfThickness - v_feather,\\n      halfThickness,\\n      dist\\n    );\\n\\n    gl_FragColor = mix(v_color, transparent, t);\\n    #endif\\n  } else {\\n    gl_FragColor = transparent;\\n  }\\n}\\n\");\n  return SHADER;\n}\nfunction getVertexShader(_ref) {\n  var arrowHead = _ref.arrowHead;\n  var hasTargetArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"target\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n  var hasSourceArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"source\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n\n  // language=GLSL\n  var SHADER = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute float a_direction;\\nattribute float a_thickness;\\nattribute vec2 a_source;\\nattribute vec2 a_target;\\nattribute float a_current;\\nattribute float a_curvature;\\n\".concat(hasTargetArrowHead ? \"attribute float a_targetSize;\\n\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"attribute float a_sourceSize;\\n\" : \"\", \"\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform vec2 u_dimensions;\\nuniform float u_minEdgeThickness;\\nuniform float u_feather;\\n\\nvarying vec4 v_color;\\nvarying float v_thickness;\\nvarying float v_feather;\\nvarying vec2 v_cpA;\\nvarying vec2 v_cpB;\\nvarying vec2 v_cpC;\\n\").concat(hasTargetArrowHead ? \"\\nvarying float v_targetSize;\\nvarying vec2 v_targetPoint;\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"\\nvarying float v_sourceSize;\\nvarying vec2 v_sourcePoint;\" : \"\", \"\\n\").concat(arrowHead ? \"\\nuniform float u_widenessToThicknessRatio;\" : \"\", \"\\n\\nconst float bias = 255.0 / 254.0;\\nconst float epsilon = 0.7;\\n\\nvec2 clipspaceToViewport(vec2 pos, vec2 dimensions) {\\n  return vec2(\\n    (pos.x + 1.0) * dimensions.x / 2.0,\\n    (pos.y + 1.0) * dimensions.y / 2.0\\n  );\\n}\\n\\nvec2 viewportToClipspace(vec2 pos, vec2 dimensions) {\\n  return vec2(\\n    pos.x / dimensions.x * 2.0 - 1.0,\\n    pos.y / dimensions.y * 2.0 - 1.0\\n  );\\n}\\n\\nvoid main() {\\n  float minThickness = u_minEdgeThickness;\\n\\n  // Selecting the correct position\\n  // Branchless \\\"position = a_source if a_current == 1.0 else a_target\\\"\\n  vec2 position = a_source * max(0.0, a_current) + a_target * max(0.0, 1.0 - a_current);\\n  position = (u_matrix * vec3(position, 1)).xy;\\n\\n  vec2 source = (u_matrix * vec3(a_source, 1)).xy;\\n  vec2 target = (u_matrix * vec3(a_target, 1)).xy;\\n\\n  vec2 viewportPosition = clipspaceToViewport(position, u_dimensions);\\n  vec2 viewportSource = clipspaceToViewport(source, u_dimensions);\\n  vec2 viewportTarget = clipspaceToViewport(target, u_dimensions);\\n\\n  vec2 delta = viewportTarget.xy - viewportSource.xy;\\n  float len = length(delta);\\n  vec2 normal = vec2(-delta.y, delta.x) * a_direction;\\n  vec2 unitNormal = normal / len;\\n  float boundingBoxThickness = len * a_curvature;\\n\\n  float curveThickness = max(minThickness, a_thickness / u_sizeRatio);\\n  v_thickness = curveThickness * u_pixelRatio;\\n  v_feather = u_feather;\\n\\n  v_cpA = viewportSource;\\n  v_cpB = 0.5 * (viewportSource + viewportTarget) + unitNormal * a_direction * boundingBoxThickness;\\n  v_cpC = viewportTarget;\\n\\n  vec2 viewportOffsetPosition = (\\n    viewportPosition +\\n    unitNormal * (boundingBoxThickness / 2.0 + sign(boundingBoxThickness) * (\").concat(arrowHead ? \"curveThickness * u_widenessToThicknessRatio\" : \"curveThickness\", \" + epsilon)) *\\n    max(0.0, a_direction) // NOTE: cutting the bounding box in half to avoid overdraw\\n  );\\n\\n  position = viewportToClipspace(viewportOffsetPosition, u_dimensions);\\n  gl_Position = vec4(position, 0, 1);\\n    \\n\").concat(hasTargetArrowHead ? \"\\n  v_targetSize = a_targetSize * u_pixelRatio / u_sizeRatio;\\n  v_targetPoint = viewportTarget;\\n\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"\\n  v_sourceSize = a_sourceSize * u_pixelRatio / u_sizeRatio;\\n  v_sourcePoint = viewportSource;\\n\" : \"\", \"\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\");\n  return SHADER;\n}\nvar DEFAULT_EDGE_CURVATURE = 0.25;\nvar DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS = {\n  arrowHead: null,\n  curvatureAttribute: \"curvature\",\n  defaultCurvature: DEFAULT_EDGE_CURVATURE\n};\n\n/**\n * This function helps to identify parallel edges, to adjust their curvatures.\n */\nvar DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS = {\n  edgeIndexAttribute: \"parallelIndex\",\n  edgeMinIndexAttribute: \"parallelMinIndex\",\n  edgeMaxIndexAttribute: \"parallelMaxIndex\"\n};\nfunction indexParallelEdgesIndex(graph, options) {\n  var opts = _objectSpread2(_objectSpread2({}, DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS), options || {});\n  var nodeIDsMapping = {};\n  var edgeDirectedIDsMapping = {};\n  var edgeUndirectedIDsMapping = {};\n\n  // Normalize IDs:\n  var incr = 0;\n  graph.forEachNode(function (node) {\n    nodeIDsMapping[node] = ++incr + \"\";\n  });\n  graph.forEachEdge(function (edge, _attrs, source, target) {\n    var sourceId = nodeIDsMapping[source];\n    var targetId = nodeIDsMapping[target];\n    var directedId = [sourceId, targetId].join(\"-\");\n    edgeDirectedIDsMapping[edge] = directedId;\n    edgeUndirectedIDsMapping[directedId] = [sourceId, targetId].sort().join(\"-\");\n  });\n\n  // Index edge unique IDs, only based on their extremities:\n  var directedIndex = {};\n  var undirectedIndex = {};\n  graph.forEachEdge(function (edge) {\n    var directedId = edgeDirectedIDsMapping[edge];\n    var undirectedId = edgeUndirectedIDsMapping[directedId];\n    directedIndex[directedId] = directedIndex[directedId] || [];\n    directedIndex[directedId].push(edge);\n    undirectedIndex[undirectedId] = undirectedIndex[undirectedId] || [];\n    undirectedIndex[undirectedId].push(edge);\n  });\n\n  // Store index attributes:\n  for (var directedId in directedIndex) {\n    var edges = directedIndex[directedId];\n    var directedCount = edges.length;\n    var undirectedCount = undirectedIndex[edgeUndirectedIDsMapping[directedId]].length;\n\n    // If the edge is alone, in both side:\n    if (directedCount === 1 && undirectedCount === 1) {\n      var edge = edges[0];\n      graph.setEdgeAttribute(edge, opts.edgeIndexAttribute, null);\n      graph.setEdgeAttribute(edge, opts.edgeMaxIndexAttribute, null);\n    }\n\n    // If the edge is alone, but there is at least one edge in the opposite direction:\n    else if (directedCount === 1) {\n      var _edge = edges[0];\n      graph.setEdgeAttribute(_edge, opts.edgeIndexAttribute, 1);\n      graph.setEdgeAttribute(_edge, opts.edgeMaxIndexAttribute, 1);\n    }\n\n    // If the edge is not alone, and all edges are in the same direction:\n    else if (directedCount === undirectedCount) {\n      var max = (directedCount - 1) / 2;\n      var min = -max;\n      for (var i = 0; i < directedCount; i++) {\n        var _edge2 = edges[i];\n        var edgeIndex = -(directedCount - 1) / 2 + i;\n        graph.setEdgeAttribute(_edge2, opts.edgeIndexAttribute, edgeIndex);\n        graph.setEdgeAttribute(_edge2, opts.edgeMinIndexAttribute, min);\n        graph.setEdgeAttribute(_edge2, opts.edgeMaxIndexAttribute, max);\n      }\n    }\n\n    // If the edge is not alone, and there are edges in both directions:\n    else {\n      for (var _i = 0; _i < directedCount; _i++) {\n        var _edge3 = edges[_i];\n        graph.setEdgeAttribute(_edge3, opts.edgeIndexAttribute, _i + 1);\n        graph.setEdgeAttribute(_edge3, opts.edgeMaxIndexAttribute, directedCount);\n      }\n    }\n  }\n}\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nfunction createEdgeCurveProgram(inputOptions) {\n  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS), inputOptions || {});\n  var _ref = options,\n    arrowHead = _ref.arrowHead,\n    curvatureAttribute = _ref.curvatureAttribute,\n    drawLabel = _ref.drawLabel;\n  var hasTargetArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"target\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n  var hasSourceArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"source\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n  var UNIFORMS = [\"u_matrix\", \"u_sizeRatio\", \"u_dimensions\", \"u_pixelRatio\", \"u_feather\", \"u_minEdgeThickness\"].concat(_toConsumableArray(arrowHead ? [\"u_lengthToThicknessRatio\", \"u_widenessToThicknessRatio\"] : []));\n  return /*#__PURE__*/function (_EdgeProgram) {\n    _inherits(EdgeCurveProgram, _EdgeProgram);\n    function EdgeCurveProgram() {\n      var _this;\n      _classCallCheck(this, EdgeCurveProgram);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _callSuper(this, EdgeCurveProgram, [].concat(args));\n      _defineProperty(_assertThisInitialized(_this), \"drawLabel\", drawLabel || createDrawCurvedEdgeLabel(options));\n      return _this;\n    }\n    _createClass(EdgeCurveProgram, [{\n      key: \"getDefinition\",\n      value: function getDefinition() {\n        return {\n          VERTICES: 6,\n          VERTEX_SHADER_SOURCE: getVertexShader(options),\n          FRAGMENT_SHADER_SOURCE: getFragmentShader(options),\n          METHOD: WebGLRenderingContext.TRIANGLES,\n          UNIFORMS: UNIFORMS,\n          ATTRIBUTES: [{\n            name: \"a_source\",\n            size: 2,\n            type: FLOAT\n          }, {\n            name: \"a_target\",\n            size: 2,\n            type: FLOAT\n          }].concat(_toConsumableArray(hasTargetArrowHead ? [{\n            name: \"a_targetSize\",\n            size: 1,\n            type: FLOAT\n          }] : []), _toConsumableArray(hasSourceArrowHead ? [{\n            name: \"a_sourceSize\",\n            size: 1,\n            type: FLOAT\n          }] : []), [{\n            name: \"a_thickness\",\n            size: 1,\n            type: FLOAT\n          }, {\n            name: \"a_curvature\",\n            size: 1,\n            type: FLOAT\n          }, {\n            name: \"a_color\",\n            size: 4,\n            type: UNSIGNED_BYTE,\n            normalized: true\n          }, {\n            name: \"a_id\",\n            size: 4,\n            type: UNSIGNED_BYTE,\n            normalized: true\n          }]),\n          CONSTANT_ATTRIBUTES: [{\n            name: \"a_current\",\n            size: 1,\n            type: FLOAT\n          },\n          // TODO: could optimize to bool\n          {\n            name: \"a_direction\",\n            size: 1,\n            type: FLOAT\n          } // TODO: could optimize to byte\n          ],\n          CONSTANT_DATA: [[0, 1], [0, -1], [1, 1], [0, -1], [1, 1], [1, -1]]\n        };\n      }\n    }, {\n      key: \"processVisibleItem\",\n      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n        var _data;\n        var thickness = data.size || 1;\n        var x1 = sourceData.x;\n        var y1 = sourceData.y;\n        var x2 = targetData.x;\n        var y2 = targetData.y;\n        var color = floatColor(data.color);\n        var curvature = (_data = data[curvatureAttribute]) !== null && _data !== void 0 ? _data : DEFAULT_EDGE_CURVATURE;\n        var array = this.array;\n\n        // First point\n        array[startIndex++] = x1;\n        array[startIndex++] = y1;\n        array[startIndex++] = x2;\n        array[startIndex++] = y2;\n        if (hasTargetArrowHead) array[startIndex++] = targetData.size;\n        if (hasSourceArrowHead) array[startIndex++] = sourceData.size;\n        array[startIndex++] = thickness;\n        array[startIndex++] = curvature;\n        array[startIndex++] = color;\n        array[startIndex++] = edgeIndex;\n      }\n    }, {\n      key: \"setUniforms\",\n      value: function setUniforms(params, _ref2) {\n        var gl = _ref2.gl,\n          uniformLocations = _ref2.uniformLocations;\n        var u_matrix = uniformLocations.u_matrix,\n          u_pixelRatio = uniformLocations.u_pixelRatio,\n          u_feather = uniformLocations.u_feather,\n          u_sizeRatio = uniformLocations.u_sizeRatio,\n          u_dimensions = uniformLocations.u_dimensions,\n          u_minEdgeThickness = uniformLocations.u_minEdgeThickness;\n        gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n        gl.uniform1f(u_pixelRatio, params.pixelRatio);\n        gl.uniform1f(u_sizeRatio, params.sizeRatio);\n        gl.uniform1f(u_feather, params.antiAliasingFeather);\n        gl.uniform2f(u_dimensions, params.width * params.pixelRatio, params.height * params.pixelRatio);\n        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n        if (arrowHead) {\n          var u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio,\n            u_widenessToThicknessRatio = uniformLocations.u_widenessToThicknessRatio;\n          gl.uniform1f(u_lengthToThicknessRatio, arrowHead.lengthToThicknessRatio);\n          gl.uniform1f(u_widenessToThicknessRatio, arrowHead.widenessToThicknessRatio);\n        }\n      }\n    }]);\n    return EdgeCurveProgram;\n  }(EdgeProgram);\n}\nvar EdgeCurveProgram = createEdgeCurveProgram();\nvar EdgeCurvedArrowProgram = createEdgeCurveProgram({\n  arrowHead: DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS\n});\nvar EdgeCurvedDoubleArrowProgram = createEdgeCurveProgram({\n  arrowHead: _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS), {}, {\n    extremity: \"both\"\n  })\n});\nexport { DEFAULT_EDGE_CURVATURE, DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS, DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS, EdgeCurvedArrowProgram, EdgeCurvedDoubleArrowProgram, createDrawCurvedEdgeLabel, createEdgeCurveProgram, EdgeCurveProgram as default, indexParallelEdgesIndex };","map":{"version":3,"names":["EdgeProgram","DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS","floatColor","_toPrimitive","t","r","e","Symbol","toPrimitive","i","call","TypeError","String","Number","_toPropertyKey","_defineProperty","Object","defineProperty","value","enumerable","configurable","writable","ownKeys","keys","getOwnPropertySymbols","o","filter","getOwnPropertyDescriptor","push","apply","_objectSpread2","arguments","length","forEach","getOwnPropertyDescriptors","defineProperties","_classCallCheck","a","n","_defineProperties","key","_createClass","prototype","_getPrototypeOf","setPrototypeOf","getPrototypeOf","bind","__proto__","_isNativeReflectConstruct","Boolean","valueOf","Reflect","construct","_assertThisInitialized","ReferenceError","_possibleConstructorReturn","_callSuper","constructor","_setPrototypeOf","_inherits","create","_arrayLikeToArray","Array","_arrayWithoutHoles","isArray","_iterableToArray","iterator","from","_unsupportedIterableToArray","toString","slice","name","test","_nonIterableSpread","_toConsumableArray","getCurvePoint","p0","p1","p2","x","Math","pow","y","getCurveLength","steps","lastPoint","point","sqrt","createDrawCurvedEdgeLabel","_ref","curvatureAttribute","defaultCurvature","_ref$keepLabelUpright","keepLabelUpright","context","edgeData","sourceData","targetData","settings","size","edgeLabelSize","curvature","font","edgeLabelFont","weight","edgeLabelWeight","color","edgeLabelColor","attribute","label","fillStyle","concat","ltr","sourceX","sourceY","targetX","targetY","centerX","centerY","diffX","diffY","diff","orientation","anchorX","anchorY","offset","sourceOffsetVector","sourceOffsetVectorLength","targetOffsetVector","targetOffsetVectorLength","anchorPoint","sourcePoint","targetPoint","curveLength","textLength","measureText","width","availableTextLength","ellipsis","charactersLengthCache","character","_i","_length","_character","tangentX","tangentY","angle","atan2","save","translate","rotate","fillText","restore","getFragmentShader","arrowHead","hasTargetArrowHead","extremity","hasSourceArrowHead","SHADER","getVertexShader","DEFAULT_EDGE_CURVATURE","DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS","DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS","edgeIndexAttribute","edgeMinIndexAttribute","edgeMaxIndexAttribute","indexParallelEdgesIndex","graph","options","opts","nodeIDsMapping","edgeDirectedIDsMapping","edgeUndirectedIDsMapping","incr","forEachNode","node","forEachEdge","edge","_attrs","source","target","sourceId","targetId","directedId","join","sort","directedIndex","undirectedIndex","undirectedId","edges","directedCount","undirectedCount","setEdgeAttribute","_edge","max","min","_edge2","edgeIndex","_edge3","_WebGLRenderingContex","WebGLRenderingContext","UNSIGNED_BYTE","FLOAT","createEdgeCurveProgram","inputOptions","drawLabel","UNIFORMS","_EdgeProgram","EdgeCurveProgram","_this","_len","args","_key","getDefinition","VERTICES","VERTEX_SHADER_SOURCE","FRAGMENT_SHADER_SOURCE","METHOD","TRIANGLES","ATTRIBUTES","type","normalized","CONSTANT_ATTRIBUTES","CONSTANT_DATA","processVisibleItem","startIndex","data","_data","thickness","x1","y1","x2","y2","array","setUniforms","params","_ref2","gl","uniformLocations","u_matrix","u_pixelRatio","u_feather","u_sizeRatio","u_dimensions","u_minEdgeThickness","uniformMatrix3fv","matrix","uniform1f","pixelRatio","sizeRatio","antiAliasingFeather","uniform2f","height","minEdgeThickness","u_lengthToThicknessRatio","u_widenessToThicknessRatio","lengthToThicknessRatio","widenessToThicknessRatio","EdgeCurvedArrowProgram","EdgeCurvedDoubleArrowProgram","default"],"sources":["/Users/fjodoin/Desktop/Research/AzureRT/azure_resource_graph/training/graphing/sigma-graph/node_modules/@sigma/edge-curve/dist/sigma-edge-curve.esm.js"],"sourcesContent":["import { EdgeProgram, DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS } from 'sigma/rendering';\nimport { floatColor } from 'sigma/utils';\n\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\n\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: !0,\n    configurable: !0,\n    writable: !0\n  }) : e[r] = t, e;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\nfunction _classCallCheck(a, n) {\n  if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\");\n}\n\nfunction _defineProperties(e, r) {\n  for (var t = 0; t < r.length; t++) {\n    var o = r[t];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o);\n  }\n}\nfunction _createClass(e, r, t) {\n  return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", {\n    writable: !1\n  }), e;\n}\n\nfunction _getPrototypeOf(t) {\n  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {\n    return t.__proto__ || Object.getPrototypeOf(t);\n  }, _getPrototypeOf(t);\n}\n\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\n\nfunction _assertThisInitialized(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\n\nfunction _possibleConstructorReturn(t, e) {\n  if (e && (\"object\" == typeof e || \"function\" == typeof e)) return e;\n  if (void 0 !== e) throw new TypeError(\"Derived constructors may only return object or undefined\");\n  return _assertThisInitialized(t);\n}\n\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\n\nfunction _setPrototypeOf(t, e) {\n  return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {\n    return t.__proto__ = e, t;\n  }, _setPrototypeOf(t, e);\n}\n\nfunction _inherits(t, e) {\n  if (\"function\" != typeof e && null !== e) throw new TypeError(\"Super expression must either be null or a function\");\n  t.prototype = Object.create(e && e.prototype, {\n    constructor: {\n      value: t,\n      writable: !0,\n      configurable: !0\n    }\n  }), Object.defineProperty(t, \"prototype\", {\n    writable: !1\n  }), e && _setPrototypeOf(t, e);\n}\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\n\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\n\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\n\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;\n  }\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\n\nfunction getCurvePoint(t, p0, p1, p2) {\n  var x = Math.pow(1 - t, 2) * p0.x + 2 * (1 - t) * t * p1.x + Math.pow(t, 2) * p2.x;\n  var y = Math.pow(1 - t, 2) * p0.y + 2 * (1 - t) * t * p1.y + Math.pow(t, 2) * p2.y;\n  return {\n    x: x,\n    y: y\n  };\n}\nfunction getCurveLength(p0, p1, p2) {\n  var steps = 20;\n  var length = 0;\n  var lastPoint = p0;\n  for (var i = 0; i < steps; i++) {\n    var point = getCurvePoint((i + 1) / steps, p0, p1, p2);\n    length += Math.sqrt(Math.pow(lastPoint.x - point.x, 2) + Math.pow(lastPoint.y - point.y, 2));\n    lastPoint = point;\n  }\n  return length;\n}\nfunction createDrawCurvedEdgeLabel(_ref) {\n  var curvatureAttribute = _ref.curvatureAttribute,\n    defaultCurvature = _ref.defaultCurvature,\n    _ref$keepLabelUpright = _ref.keepLabelUpright,\n    keepLabelUpright = _ref$keepLabelUpright === void 0 ? true : _ref$keepLabelUpright;\n  return function (context, edgeData, sourceData, targetData, settings) {\n    var size = settings.edgeLabelSize,\n      curvature = edgeData[curvatureAttribute] || defaultCurvature,\n      font = settings.edgeLabelFont,\n      weight = settings.edgeLabelWeight,\n      color = settings.edgeLabelColor.attribute ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\" : settings.edgeLabelColor.color;\n    var label = edgeData.label;\n    if (!label) return;\n    context.fillStyle = color;\n    context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n\n    // Computing positions without considering nodes sizes:\n    var ltr = !keepLabelUpright || sourceData.x < targetData.x;\n    var sourceX = ltr ? sourceData.x : targetData.x;\n    var sourceY = ltr ? sourceData.y : targetData.y;\n    var targetX = ltr ? targetData.x : sourceData.x;\n    var targetY = ltr ? targetData.y : sourceData.y;\n    var centerX = (sourceX + targetX) / 2;\n    var centerY = (sourceY + targetY) / 2;\n    var diffX = targetX - sourceX;\n    var diffY = targetY - sourceY;\n    var diff = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));\n    // Anchor point:\n    var orientation = ltr ? 1 : -1;\n    var anchorX = centerX + diffY * curvature * orientation;\n    var anchorY = centerY - diffX * curvature * orientation;\n\n    // Adapt curve points to edge thickness:\n    var offset = edgeData.size * 0.7 + 5;\n    var sourceOffsetVector = {\n      x: anchorY - sourceY,\n      y: -(anchorX - sourceX)\n    };\n    var sourceOffsetVectorLength = Math.sqrt(Math.pow(sourceOffsetVector.x, 2) + Math.pow(sourceOffsetVector.y, 2));\n    var targetOffsetVector = {\n      x: targetY - anchorY,\n      y: -(targetX - anchorX)\n    };\n    var targetOffsetVectorLength = Math.sqrt(Math.pow(targetOffsetVector.x, 2) + Math.pow(targetOffsetVector.y, 2));\n    sourceX += offset * sourceOffsetVector.x / sourceOffsetVectorLength;\n    sourceY += offset * sourceOffsetVector.y / sourceOffsetVectorLength;\n    targetX += offset * targetOffsetVector.x / targetOffsetVectorLength;\n    targetY += offset * targetOffsetVector.y / targetOffsetVectorLength;\n    // For anchor, the vector is simpler, so it is inlined:\n    anchorX += offset * diffY / diff;\n    anchorY -= offset * diffX / diff;\n\n    // Compute curve length:\n    var anchorPoint = {\n      x: anchorX,\n      y: anchorY\n    };\n    var sourcePoint = {\n      x: sourceX,\n      y: sourceY\n    };\n    var targetPoint = {\n      x: targetX,\n      y: targetY\n    };\n    var curveLength = getCurveLength(sourcePoint, anchorPoint, targetPoint);\n    if (curveLength < sourceData.size + targetData.size) return;\n\n    // Handling ellipsis\n    var textLength = context.measureText(label).width;\n    var availableTextLength = curveLength - sourceData.size - targetData.size;\n    if (textLength > availableTextLength) {\n      var ellipsis = \"â€¦\";\n      label = label + ellipsis;\n      textLength = context.measureText(label).width;\n      while (textLength > availableTextLength && label.length > 1) {\n        label = label.slice(0, -2) + ellipsis;\n        textLength = context.measureText(label).width;\n      }\n      if (label.length < 4) return;\n    }\n\n    // Measure each character:\n    var charactersLengthCache = {};\n    for (var i = 0, length = label.length; i < length; i++) {\n      var character = label[i];\n      if (!charactersLengthCache[character]) {\n        charactersLengthCache[character] = context.measureText(character).width * (1 + curvature * 0.35);\n      }\n    }\n\n    // Draw each character:\n    var t = 0.5 - textLength / curveLength / 2;\n    for (var _i = 0, _length = label.length; _i < _length; _i++) {\n      var _character = label[_i];\n      var point = getCurvePoint(t, sourcePoint, anchorPoint, targetPoint);\n      var tangentX = 2 * (1 - t) * (anchorX - sourceX) + 2 * t * (targetX - anchorX);\n      var tangentY = 2 * (1 - t) * (anchorY - sourceY) + 2 * t * (targetY - anchorY);\n      var angle = Math.atan2(tangentY, tangentX);\n      context.save();\n      context.translate(point.x, point.y);\n      context.rotate(angle);\n\n      // Dessiner le caractÃ¨re\n      context.fillText(_character, 0, 0);\n      context.restore();\n      t += charactersLengthCache[_character] / curveLength;\n    }\n  };\n}\n\nfunction getFragmentShader(_ref) {\n  var arrowHead = _ref.arrowHead;\n  var hasTargetArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"target\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n  var hasSourceArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"source\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n\n  // language=GLSL\n  var SHADER = /*glsl*/\"\\nprecision highp float;\\n\\nvarying vec4 v_color;\\nvarying float v_thickness;\\nvarying float v_feather;\\nvarying vec2 v_cpA;\\nvarying vec2 v_cpB;\\nvarying vec2 v_cpC;\\n\".concat(hasTargetArrowHead ? \"\\nvarying float v_targetSize;\\nvarying vec2 v_targetPoint;\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"\\nvarying float v_sourceSize;\\nvarying vec2 v_sourcePoint;\" : \"\", \"\\n\").concat(arrowHead ? \"\\nuniform float u_lengthToThicknessRatio;\\nuniform float u_widenessToThicknessRatio;\" : \"\", \"\\n\\nfloat det(vec2 a, vec2 b) {\\n  return a.x * b.y - b.x * a.y;\\n}\\n\\nvec2 getDistanceVector(vec2 b0, vec2 b1, vec2 b2) {\\n  float a = det(b0, b2), b = 2.0 * det(b1, b0), d = 2.0 * det(b2, b1);\\n  float f = b * d - a * a;\\n  vec2 d21 = b2 - b1, d10 = b1 - b0, d20 = b2 - b0;\\n  vec2 gf = 2.0 * (b * d21 + d * d10 + a * d20);\\n  gf = vec2(gf.y, -gf.x);\\n  vec2 pp = -f * gf / dot(gf, gf);\\n  vec2 d0p = b0 - pp;\\n  float ap = det(d0p, d20), bp = 2.0 * det(d10, d0p);\\n  float t = clamp((ap + bp) / (2.0 * a + b + d), 0.0, 1.0);\\n  return mix(mix(b0, b1, t), mix(b1, b2, t), t);\\n}\\n\\nfloat distToQuadraticBezierCurve(vec2 p, vec2 b0, vec2 b1, vec2 b2) {\\n  return length(getDistanceVector(b0 - p, b1 - p, b2 - p));\\n}\\n\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  float dist = distToQuadraticBezierCurve(gl_FragCoord.xy, v_cpA, v_cpB, v_cpC);\\n  float thickness = v_thickness;\\n\").concat(hasTargetArrowHead ? \"\\n  float distToTarget = length(gl_FragCoord.xy - v_targetPoint);\\n  float targetArrowLength = v_targetSize + thickness * u_lengthToThicknessRatio;\\n  if (distToTarget < targetArrowLength) {\\n    thickness = (distToTarget - v_targetSize) / (targetArrowLength - v_targetSize) * u_widenessToThicknessRatio * thickness;\\n  }\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"\\n  float distToSource = length(gl_FragCoord.xy - v_sourcePoint);\\n  float sourceArrowLength = v_sourceSize + thickness * u_lengthToThicknessRatio;\\n  if (distToSource < sourceArrowLength) {\\n    thickness = (distToSource - v_sourceSize) / (sourceArrowLength - v_sourceSize) * u_widenessToThicknessRatio * thickness;\\n  }\" : \"\", \"\\n\\n  float halfThickness = thickness / 2.0;\\n  if (dist < halfThickness) {\\n    #ifdef PICKING_MODE\\n    gl_FragColor = v_color;\\n    #else\\n    float t = smoothstep(\\n      halfThickness - v_feather,\\n      halfThickness,\\n      dist\\n    );\\n\\n    gl_FragColor = mix(v_color, transparent, t);\\n    #endif\\n  } else {\\n    gl_FragColor = transparent;\\n  }\\n}\\n\");\n  return SHADER;\n}\n\nfunction getVertexShader(_ref) {\n  var arrowHead = _ref.arrowHead;\n  var hasTargetArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"target\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n  var hasSourceArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"source\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n\n  // language=GLSL\n  var SHADER = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute float a_direction;\\nattribute float a_thickness;\\nattribute vec2 a_source;\\nattribute vec2 a_target;\\nattribute float a_current;\\nattribute float a_curvature;\\n\".concat(hasTargetArrowHead ? \"attribute float a_targetSize;\\n\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"attribute float a_sourceSize;\\n\" : \"\", \"\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform vec2 u_dimensions;\\nuniform float u_minEdgeThickness;\\nuniform float u_feather;\\n\\nvarying vec4 v_color;\\nvarying float v_thickness;\\nvarying float v_feather;\\nvarying vec2 v_cpA;\\nvarying vec2 v_cpB;\\nvarying vec2 v_cpC;\\n\").concat(hasTargetArrowHead ? \"\\nvarying float v_targetSize;\\nvarying vec2 v_targetPoint;\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"\\nvarying float v_sourceSize;\\nvarying vec2 v_sourcePoint;\" : \"\", \"\\n\").concat(arrowHead ? \"\\nuniform float u_widenessToThicknessRatio;\" : \"\", \"\\n\\nconst float bias = 255.0 / 254.0;\\nconst float epsilon = 0.7;\\n\\nvec2 clipspaceToViewport(vec2 pos, vec2 dimensions) {\\n  return vec2(\\n    (pos.x + 1.0) * dimensions.x / 2.0,\\n    (pos.y + 1.0) * dimensions.y / 2.0\\n  );\\n}\\n\\nvec2 viewportToClipspace(vec2 pos, vec2 dimensions) {\\n  return vec2(\\n    pos.x / dimensions.x * 2.0 - 1.0,\\n    pos.y / dimensions.y * 2.0 - 1.0\\n  );\\n}\\n\\nvoid main() {\\n  float minThickness = u_minEdgeThickness;\\n\\n  // Selecting the correct position\\n  // Branchless \\\"position = a_source if a_current == 1.0 else a_target\\\"\\n  vec2 position = a_source * max(0.0, a_current) + a_target * max(0.0, 1.0 - a_current);\\n  position = (u_matrix * vec3(position, 1)).xy;\\n\\n  vec2 source = (u_matrix * vec3(a_source, 1)).xy;\\n  vec2 target = (u_matrix * vec3(a_target, 1)).xy;\\n\\n  vec2 viewportPosition = clipspaceToViewport(position, u_dimensions);\\n  vec2 viewportSource = clipspaceToViewport(source, u_dimensions);\\n  vec2 viewportTarget = clipspaceToViewport(target, u_dimensions);\\n\\n  vec2 delta = viewportTarget.xy - viewportSource.xy;\\n  float len = length(delta);\\n  vec2 normal = vec2(-delta.y, delta.x) * a_direction;\\n  vec2 unitNormal = normal / len;\\n  float boundingBoxThickness = len * a_curvature;\\n\\n  float curveThickness = max(minThickness, a_thickness / u_sizeRatio);\\n  v_thickness = curveThickness * u_pixelRatio;\\n  v_feather = u_feather;\\n\\n  v_cpA = viewportSource;\\n  v_cpB = 0.5 * (viewportSource + viewportTarget) + unitNormal * a_direction * boundingBoxThickness;\\n  v_cpC = viewportTarget;\\n\\n  vec2 viewportOffsetPosition = (\\n    viewportPosition +\\n    unitNormal * (boundingBoxThickness / 2.0 + sign(boundingBoxThickness) * (\").concat(arrowHead ? \"curveThickness * u_widenessToThicknessRatio\" : \"curveThickness\", \" + epsilon)) *\\n    max(0.0, a_direction) // NOTE: cutting the bounding box in half to avoid overdraw\\n  );\\n\\n  position = viewportToClipspace(viewportOffsetPosition, u_dimensions);\\n  gl_Position = vec4(position, 0, 1);\\n    \\n\").concat(hasTargetArrowHead ? \"\\n  v_targetSize = a_targetSize * u_pixelRatio / u_sizeRatio;\\n  v_targetPoint = viewportTarget;\\n\" : \"\", \"\\n\").concat(hasSourceArrowHead ? \"\\n  v_sourceSize = a_sourceSize * u_pixelRatio / u_sizeRatio;\\n  v_sourcePoint = viewportSource;\\n\" : \"\", \"\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\");\n  return SHADER;\n}\n\nvar DEFAULT_EDGE_CURVATURE = 0.25;\nvar DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS = {\n  arrowHead: null,\n  curvatureAttribute: \"curvature\",\n  defaultCurvature: DEFAULT_EDGE_CURVATURE\n};\n\n/**\n * This function helps to identify parallel edges, to adjust their curvatures.\n */\nvar DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS = {\n  edgeIndexAttribute: \"parallelIndex\",\n  edgeMinIndexAttribute: \"parallelMinIndex\",\n  edgeMaxIndexAttribute: \"parallelMaxIndex\"\n};\nfunction indexParallelEdgesIndex(graph, options) {\n  var opts = _objectSpread2(_objectSpread2({}, DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS), options || {});\n  var nodeIDsMapping = {};\n  var edgeDirectedIDsMapping = {};\n  var edgeUndirectedIDsMapping = {};\n\n  // Normalize IDs:\n  var incr = 0;\n  graph.forEachNode(function (node) {\n    nodeIDsMapping[node] = ++incr + \"\";\n  });\n  graph.forEachEdge(function (edge, _attrs, source, target) {\n    var sourceId = nodeIDsMapping[source];\n    var targetId = nodeIDsMapping[target];\n    var directedId = [sourceId, targetId].join(\"-\");\n    edgeDirectedIDsMapping[edge] = directedId;\n    edgeUndirectedIDsMapping[directedId] = [sourceId, targetId].sort().join(\"-\");\n  });\n\n  // Index edge unique IDs, only based on their extremities:\n  var directedIndex = {};\n  var undirectedIndex = {};\n  graph.forEachEdge(function (edge) {\n    var directedId = edgeDirectedIDsMapping[edge];\n    var undirectedId = edgeUndirectedIDsMapping[directedId];\n    directedIndex[directedId] = directedIndex[directedId] || [];\n    directedIndex[directedId].push(edge);\n    undirectedIndex[undirectedId] = undirectedIndex[undirectedId] || [];\n    undirectedIndex[undirectedId].push(edge);\n  });\n\n  // Store index attributes:\n  for (var directedId in directedIndex) {\n    var edges = directedIndex[directedId];\n    var directedCount = edges.length;\n    var undirectedCount = undirectedIndex[edgeUndirectedIDsMapping[directedId]].length;\n\n    // If the edge is alone, in both side:\n    if (directedCount === 1 && undirectedCount === 1) {\n      var edge = edges[0];\n      graph.setEdgeAttribute(edge, opts.edgeIndexAttribute, null);\n      graph.setEdgeAttribute(edge, opts.edgeMaxIndexAttribute, null);\n    }\n\n    // If the edge is alone, but there is at least one edge in the opposite direction:\n    else if (directedCount === 1) {\n      var _edge = edges[0];\n      graph.setEdgeAttribute(_edge, opts.edgeIndexAttribute, 1);\n      graph.setEdgeAttribute(_edge, opts.edgeMaxIndexAttribute, 1);\n    }\n\n    // If the edge is not alone, and all edges are in the same direction:\n    else if (directedCount === undirectedCount) {\n      var max = (directedCount - 1) / 2;\n      var min = -max;\n      for (var i = 0; i < directedCount; i++) {\n        var _edge2 = edges[i];\n        var edgeIndex = -(directedCount - 1) / 2 + i;\n        graph.setEdgeAttribute(_edge2, opts.edgeIndexAttribute, edgeIndex);\n        graph.setEdgeAttribute(_edge2, opts.edgeMinIndexAttribute, min);\n        graph.setEdgeAttribute(_edge2, opts.edgeMaxIndexAttribute, max);\n      }\n    }\n\n    // If the edge is not alone, and there are edges in both directions:\n    else {\n      for (var _i = 0; _i < directedCount; _i++) {\n        var _edge3 = edges[_i];\n        graph.setEdgeAttribute(_edge3, opts.edgeIndexAttribute, _i + 1);\n        graph.setEdgeAttribute(_edge3, opts.edgeMaxIndexAttribute, directedCount);\n      }\n    }\n  }\n}\n\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nfunction createEdgeCurveProgram(inputOptions) {\n  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS), inputOptions || {});\n  var _ref = options,\n    arrowHead = _ref.arrowHead,\n    curvatureAttribute = _ref.curvatureAttribute,\n    drawLabel = _ref.drawLabel;\n  var hasTargetArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"target\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n  var hasSourceArrowHead = (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"source\" || (arrowHead === null || arrowHead === void 0 ? void 0 : arrowHead.extremity) === \"both\";\n  var UNIFORMS = [\"u_matrix\", \"u_sizeRatio\", \"u_dimensions\", \"u_pixelRatio\", \"u_feather\", \"u_minEdgeThickness\"].concat(_toConsumableArray(arrowHead ? [\"u_lengthToThicknessRatio\", \"u_widenessToThicknessRatio\"] : []));\n  return /*#__PURE__*/function (_EdgeProgram) {\n    _inherits(EdgeCurveProgram, _EdgeProgram);\n    function EdgeCurveProgram() {\n      var _this;\n      _classCallCheck(this, EdgeCurveProgram);\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      _this = _callSuper(this, EdgeCurveProgram, [].concat(args));\n      _defineProperty(_assertThisInitialized(_this), \"drawLabel\", drawLabel || createDrawCurvedEdgeLabel(options));\n      return _this;\n    }\n    _createClass(EdgeCurveProgram, [{\n      key: \"getDefinition\",\n      value: function getDefinition() {\n        return {\n          VERTICES: 6,\n          VERTEX_SHADER_SOURCE: getVertexShader(options),\n          FRAGMENT_SHADER_SOURCE: getFragmentShader(options),\n          METHOD: WebGLRenderingContext.TRIANGLES,\n          UNIFORMS: UNIFORMS,\n          ATTRIBUTES: [{\n            name: \"a_source\",\n            size: 2,\n            type: FLOAT\n          }, {\n            name: \"a_target\",\n            size: 2,\n            type: FLOAT\n          }].concat(_toConsumableArray(hasTargetArrowHead ? [{\n            name: \"a_targetSize\",\n            size: 1,\n            type: FLOAT\n          }] : []), _toConsumableArray(hasSourceArrowHead ? [{\n            name: \"a_sourceSize\",\n            size: 1,\n            type: FLOAT\n          }] : []), [{\n            name: \"a_thickness\",\n            size: 1,\n            type: FLOAT\n          }, {\n            name: \"a_curvature\",\n            size: 1,\n            type: FLOAT\n          }, {\n            name: \"a_color\",\n            size: 4,\n            type: UNSIGNED_BYTE,\n            normalized: true\n          }, {\n            name: \"a_id\",\n            size: 4,\n            type: UNSIGNED_BYTE,\n            normalized: true\n          }]),\n          CONSTANT_ATTRIBUTES: [{\n            name: \"a_current\",\n            size: 1,\n            type: FLOAT\n          },\n          // TODO: could optimize to bool\n          {\n            name: \"a_direction\",\n            size: 1,\n            type: FLOAT\n          } // TODO: could optimize to byte\n          ],\n          CONSTANT_DATA: [[0, 1], [0, -1], [1, 1], [0, -1], [1, 1], [1, -1]]\n        };\n      }\n    }, {\n      key: \"processVisibleItem\",\n      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n        var _data;\n        var thickness = data.size || 1;\n        var x1 = sourceData.x;\n        var y1 = sourceData.y;\n        var x2 = targetData.x;\n        var y2 = targetData.y;\n        var color = floatColor(data.color);\n        var curvature = (_data = data[curvatureAttribute]) !== null && _data !== void 0 ? _data : DEFAULT_EDGE_CURVATURE;\n        var array = this.array;\n\n        // First point\n        array[startIndex++] = x1;\n        array[startIndex++] = y1;\n        array[startIndex++] = x2;\n        array[startIndex++] = y2;\n        if (hasTargetArrowHead) array[startIndex++] = targetData.size;\n        if (hasSourceArrowHead) array[startIndex++] = sourceData.size;\n        array[startIndex++] = thickness;\n        array[startIndex++] = curvature;\n        array[startIndex++] = color;\n        array[startIndex++] = edgeIndex;\n      }\n    }, {\n      key: \"setUniforms\",\n      value: function setUniforms(params, _ref2) {\n        var gl = _ref2.gl,\n          uniformLocations = _ref2.uniformLocations;\n        var u_matrix = uniformLocations.u_matrix,\n          u_pixelRatio = uniformLocations.u_pixelRatio,\n          u_feather = uniformLocations.u_feather,\n          u_sizeRatio = uniformLocations.u_sizeRatio,\n          u_dimensions = uniformLocations.u_dimensions,\n          u_minEdgeThickness = uniformLocations.u_minEdgeThickness;\n        gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n        gl.uniform1f(u_pixelRatio, params.pixelRatio);\n        gl.uniform1f(u_sizeRatio, params.sizeRatio);\n        gl.uniform1f(u_feather, params.antiAliasingFeather);\n        gl.uniform2f(u_dimensions, params.width * params.pixelRatio, params.height * params.pixelRatio);\n        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n        if (arrowHead) {\n          var u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio,\n            u_widenessToThicknessRatio = uniformLocations.u_widenessToThicknessRatio;\n          gl.uniform1f(u_lengthToThicknessRatio, arrowHead.lengthToThicknessRatio);\n          gl.uniform1f(u_widenessToThicknessRatio, arrowHead.widenessToThicknessRatio);\n        }\n      }\n    }]);\n    return EdgeCurveProgram;\n  }(EdgeProgram);\n}\n\nvar EdgeCurveProgram = createEdgeCurveProgram();\nvar EdgeCurvedArrowProgram = createEdgeCurveProgram({\n  arrowHead: DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS\n});\nvar EdgeCurvedDoubleArrowProgram = createEdgeCurveProgram({\n  arrowHead: _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS), {}, {\n    extremity: \"both\"\n  })\n});\n\nexport { DEFAULT_EDGE_CURVATURE, DEFAULT_EDGE_CURVE_PROGRAM_OPTIONS, DEFAULT_INDEX_PARALLEL_EDGES_OPTIONS, EdgeCurvedArrowProgram, EdgeCurvedDoubleArrowProgram, createDrawCurvedEdgeLabel, createEdgeCurveProgram, EdgeCurveProgram as default, indexParallelEdgesIndex };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
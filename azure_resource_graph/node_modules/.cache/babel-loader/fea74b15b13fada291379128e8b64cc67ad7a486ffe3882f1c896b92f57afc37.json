{"ast":null,"code":"import { f as NodeProgram, D as DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS, _ as _objectSpread2, F as FRAGMENT_SHADER_SOURCE$3, g as EdgeProgram, h as createEdgeCompoundProgram, i as createEdgeArrowHeadProgram } from '../../dist/index-236c62ad.esm.js';\nexport { k as AbstractEdgeProgram, A as AbstractNodeProgram, l as AbstractProgram, D as DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS, p as DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS, m as EdgeArrowHeadProgram, E as EdgeArrowProgram, n as EdgeClampedProgram, g as EdgeProgram, e as EdgeRectangleProgram, N as NodeCircleProgram, f as NodeProgram, P as Program, i as createEdgeArrowHeadProgram, q as createEdgeArrowProgram, o as createEdgeClampedProgram, h as createEdgeCompoundProgram, j as createNodeCompoundProgram, c as drawDiscNodeHover, b as drawDiscNodeLabel, d as drawStraightEdgeLabel, r as getAttributeItemsCount, s as getAttributesItemsCount, w as killProgram, u as loadFragmentShader, v as loadProgram, t as loadVertexShader, x as numberToGLSLFloat } from '../../dist/index-236c62ad.esm.js';\nimport { _ as _inherits, a as _createClass, b as _classCallCheck, c as _callSuper } from '../../dist/inherits-d1a1e29b.esm.js';\nimport { f as floatColor } from '../../dist/colors-beb06eb2.esm.js';\n\n// language=GLSL\nvar SHADER_SOURCE$6 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float radius = 0.5;\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\\n  float dist = radius - length(m);\\n\\n  // No antialiasing for picking mode:\\n  #ifdef PICKING_MODE\\n  if (dist > v_border)\\n    gl_FragColor = v_color;\\n  else\\n    gl_FragColor = transparent;\\n\\n  #else\\n  float t = 0.0;\\n  if (dist > v_border)\\n    t = 1.0;\\n  else if (dist > 0.0)\\n    t = dist / v_border;\\n\\n  gl_FragColor = mix(transparent, v_color, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$6;\n\n// language=GLSL\nvar SHADER_SOURCE$5 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\nattribute float a_size;\\n\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  // Multiply the point size twice:\\n  //  - x SCALING_RATIO to correct the canvas scaling\\n  //  - x 2 to correct the formulae\\n  gl_PointSize = a_size / u_sizeRatio * u_pixelRatio * 2.0;\\n\\n  v_border = (0.5 / a_size) * u_sizeRatio;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$3 = SHADER_SOURCE$5;\nvar _WebGLRenderingContex$3 = WebGLRenderingContext,\n  UNSIGNED_BYTE$3 = _WebGLRenderingContex$3.UNSIGNED_BYTE,\n  FLOAT$3 = _WebGLRenderingContex$3.FLOAT;\nvar UNIFORMS$3 = [\"u_sizeRatio\", \"u_pixelRatio\", \"u_matrix\"];\nvar NodePointProgram = /*#__PURE__*/function (_NodeProgram) {\n  function NodePointProgram() {\n    _classCallCheck(this, NodePointProgram);\n    return _callSuper(this, NodePointProgram, arguments);\n  }\n  _inherits(NodePointProgram, _NodeProgram);\n  return _createClass(NodePointProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 1,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$3,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,\n        METHOD: WebGLRenderingContext.POINTS,\n        UNIFORMS: UNIFORMS$3,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$3\n        }, {\n          name: \"a_size\",\n          size: 1,\n          type: FLOAT$3\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(nodeIndex, startIndex, data) {\n      var array = this.array;\n      array[startIndex++] = data.x;\n      array[startIndex++] = data.y;\n      array[startIndex++] = data.size;\n      array[startIndex++] = floatColor(data.color);\n      array[startIndex++] = nodeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(_ref, _ref2) {\n      var sizeRatio = _ref.sizeRatio,\n        pixelRatio = _ref.pixelRatio,\n        matrix = _ref.matrix;\n      var gl = _ref2.gl,\n        uniformLocations = _ref2.uniformLocations;\n      var u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_pixelRatio = uniformLocations.u_pixelRatio,\n        u_matrix = uniformLocations.u_matrix;\n      gl.uniform1f(u_pixelRatio, pixelRatio);\n      gl.uniform1f(u_sizeRatio, sizeRatio);\n      gl.uniformMatrix3fv(u_matrix, false, matrix);\n    }\n  }]);\n}(NodeProgram);\n\n// language=GLSL\nvar SHADER_SOURCE$4 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\nattribute float a_sourceRadius;\\nattribute float a_targetRadius;\\nattribute float a_sourceRadiusCoef;\\nattribute float a_targetRadiusCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_zoomRatio;\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform float u_correctionRatio;\\nuniform float u_minEdgeThickness;\\nuniform float u_lengthToThicknessRatio;\\nuniform float u_feather;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\nvarying float v_feather;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float minThickness = u_minEdgeThickness;\\n\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl. Please read it to\\n  // get better comments on what's happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here, we move the point to leave space for the arrow heads:\\n  // Source arrow head\\n  float sourceRadius = a_sourceRadius * a_sourceRadiusCoef;\\n  float sourceDirection = sign(sourceRadius);\\n  float webGLSourceRadius = sourceDirection * sourceRadius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLSourceArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\\n  vec2 sourceCompensationVector =\\n    vec2(-sourceDirection * unitNormal.y, sourceDirection * unitNormal.x)\\n    * (webGLSourceRadius + webGLSourceArrowHeadLength);\\n    \\n  // Target arrow head\\n  float targetRadius = a_targetRadius * a_targetRadiusCoef;\\n  float targetDirection = sign(targetRadius);\\n  float webGLTargetRadius = targetDirection * targetRadius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLTargetArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\\n  vec2 targetCompensationVector =\\n  vec2(-targetDirection * unitNormal.y, targetDirection * unitNormal.x)\\n    * (webGLTargetRadius + webGLTargetArrowHeadLength);\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + sourceCompensationVector + targetCompensationVector, 1)).xy, 0, 1);\\n\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$4;\nvar _WebGLRenderingContex$2 = WebGLRenderingContext,\n  UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE,\n  FLOAT$2 = _WebGLRenderingContex$2.FLOAT;\nvar UNIFORMS$2 = [\"u_matrix\", \"u_zoomRatio\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_pixelRatio\", \"u_feather\", \"u_minEdgeThickness\", \"u_lengthToThicknessRatio\"];\nvar DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS = {\n  lengthToThicknessRatio: DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS.lengthToThicknessRatio\n};\nfunction createEdgeDoubleClampedProgram(inputOptions) {\n  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS), inputOptions || {});\n  return /*#__PURE__*/function (_EdgeProgram) {\n    function EdgeDoubleClampedProgram() {\n      _classCallCheck(this, EdgeDoubleClampedProgram);\n      return _callSuper(this, EdgeDoubleClampedProgram, arguments);\n    }\n    _inherits(EdgeDoubleClampedProgram, _EdgeProgram);\n    return _createClass(EdgeDoubleClampedProgram, [{\n      key: \"getDefinition\",\n      value: function getDefinition() {\n        return {\n          VERTICES: 6,\n          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,\n          FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$3,\n          METHOD: WebGLRenderingContext.TRIANGLES,\n          UNIFORMS: UNIFORMS$2,\n          ATTRIBUTES: [{\n            name: \"a_positionStart\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_positionEnd\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_normal\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_color\",\n            size: 4,\n            type: UNSIGNED_BYTE$2,\n            normalized: true\n          }, {\n            name: \"a_id\",\n            size: 4,\n            type: UNSIGNED_BYTE$2,\n            normalized: true\n          }, {\n            name: \"a_sourceRadius\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_targetRadius\",\n            size: 1,\n            type: FLOAT$2\n          }],\n          CONSTANT_ATTRIBUTES: [\n          // If 0, then position will be a_positionStart\n          // If 1, then position will be a_positionEnd\n          {\n            name: \"a_positionCoef\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_normalCoef\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_sourceRadiusCoef\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_targetRadiusCoef\",\n            size: 1,\n            type: FLOAT$2\n          }],\n          CONSTANT_DATA: [[0, 1, -1, 0], [0, -1, 1, 0], [1, 1, 0, 1], [1, 1, 0, 1], [0, -1, 1, 0], [1, -1, 0, -1]]\n        };\n      }\n    }, {\n      key: \"processVisibleItem\",\n      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n        var thickness = data.size || 1;\n        var x1 = sourceData.x;\n        var y1 = sourceData.y;\n        var x2 = targetData.x;\n        var y2 = targetData.y;\n        var color = floatColor(data.color);\n\n        // Computing normals\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        var sourceRadius = sourceData.size || 1;\n        var targetRadius = targetData.size || 1;\n        var len = dx * dx + dy * dy;\n        var n1 = 0;\n        var n2 = 0;\n        if (len) {\n          len = 1 / Math.sqrt(len);\n          n1 = -dy * len * thickness;\n          n2 = dx * len * thickness;\n        }\n        var array = this.array;\n        array[startIndex++] = x1;\n        array[startIndex++] = y1;\n        array[startIndex++] = x2;\n        array[startIndex++] = y2;\n        array[startIndex++] = n1;\n        array[startIndex++] = n2;\n        array[startIndex++] = color;\n        array[startIndex++] = edgeIndex;\n        array[startIndex++] = sourceRadius;\n        array[startIndex++] = targetRadius;\n      }\n    }, {\n      key: \"setUniforms\",\n      value: function setUniforms(params, _ref) {\n        var gl = _ref.gl,\n          uniformLocations = _ref.uniformLocations;\n        var u_matrix = uniformLocations.u_matrix,\n          u_zoomRatio = uniformLocations.u_zoomRatio,\n          u_feather = uniformLocations.u_feather,\n          u_pixelRatio = uniformLocations.u_pixelRatio,\n          u_correctionRatio = uniformLocations.u_correctionRatio,\n          u_sizeRatio = uniformLocations.u_sizeRatio,\n          u_minEdgeThickness = uniformLocations.u_minEdgeThickness,\n          u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio;\n        gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n        gl.uniform1f(u_zoomRatio, params.zoomRatio);\n        gl.uniform1f(u_sizeRatio, params.sizeRatio);\n        gl.uniform1f(u_correctionRatio, params.correctionRatio);\n        gl.uniform1f(u_pixelRatio, params.pixelRatio);\n        gl.uniform1f(u_feather, params.antiAliasingFeather);\n        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n        gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);\n      }\n    }]);\n  }(EdgeProgram);\n}\nvar EdgeDoubleClampedProgram = createEdgeDoubleClampedProgram();\nvar EdgeDoubleClampedProgram$1 = EdgeDoubleClampedProgram;\nfunction createEdgeDoubleArrowProgram(inputOptions) {\n  return createEdgeCompoundProgram([createEdgeDoubleClampedProgram(inputOptions), createEdgeArrowHeadProgram(inputOptions), createEdgeArrowHeadProgram(_objectSpread2(_objectSpread2({}, inputOptions), {}, {\n    extremity: \"source\"\n  }))]);\n}\nvar EdgeDoubleArrowProgram = createEdgeDoubleArrowProgram();\nvar EdgeDoubleArrowProgram$1 = EdgeDoubleArrowProgram;\n\n// language=GLSL\nvar SHADER_SOURCE$3 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$3;\n\n// language=GLSL\nvar SHADER_SOURCE$2 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\n\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  // Scale from [[-1 1] [-1 1]] to the container:\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$2;\nvar _WebGLRenderingContex$1 = WebGLRenderingContext,\n  UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE,\n  FLOAT$1 = _WebGLRenderingContex$1.FLOAT;\nvar UNIFORMS$1 = [\"u_matrix\"];\nvar EdgeLineProgram = /*#__PURE__*/function (_EdgeProgram) {\n  function EdgeLineProgram() {\n    _classCallCheck(this, EdgeLineProgram);\n    return _callSuper(this, EdgeLineProgram, arguments);\n  }\n  _inherits(EdgeLineProgram, _EdgeProgram);\n  return _createClass(EdgeLineProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 2,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,\n        METHOD: WebGLRenderingContext.LINES,\n        UNIFORMS: UNIFORMS$1,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var array = this.array;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // First point\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n\n      // Second point\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    }\n  }]);\n}(EdgeProgram);\n\n// language=GLSL\nvar SHADER_SOURCE$1 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$1;\n\n// language=GLSL\nvar SHADER_SOURCE = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  // The only different here with edge.vert.glsl is that we need to handle null\\n  // input normal vector. Apart from that, you can read edge.vert.glsl more info\\n  // on how it works:\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n  if (normalLength <= 0.0) unitNormal = normal;\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE = SHADER_SOURCE;\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nvar UNIFORMS = [\"u_matrix\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_minEdgeThickness\"];\nvar EdgeTriangleProgram = /*#__PURE__*/function (_EdgeProgram) {\n  function EdgeTriangleProgram() {\n    _classCallCheck(this, EdgeTriangleProgram);\n    return _callSuper(this, EdgeTriangleProgram, arguments);\n  }\n  _inherits(EdgeTriangleProgram, _EdgeProgram);\n  return _createClass(EdgeTriangleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS,\n        ATTRIBUTES: [{\n          name: \"a_positionStart\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_positionEnd\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 1, then position will be a_positionEnd\n        {\n          name: \"a_positionCoef\",\n          size: 1,\n          type: FLOAT\n        }, {\n          name: \"a_normalCoef\",\n          size: 1,\n          type: FLOAT\n        }],\n        CONSTANT_DATA: [[0, 1], [0, -1], [1, 0]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n\n      // First point\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix,\n        u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_minEdgeThickness = uniformLocations.u_minEdgeThickness;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n    }\n  }]);\n}(EdgeProgram);\nexport { DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS, EdgeDoubleArrowProgram$1 as EdgeDoubleArrowProgram, EdgeDoubleClampedProgram$1 as EdgeDoubleClampedProgram, EdgeLineProgram, EdgeTriangleProgram, NodePointProgram, createEdgeDoubleArrowProgram, createEdgeDoubleClampedProgram };","map":{"version":3,"names":["f","NodeProgram","D","DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS","_","_objectSpread2","F","FRAGMENT_SHADER_SOURCE$3","g","EdgeProgram","h","createEdgeCompoundProgram","i","createEdgeArrowHeadProgram","k","AbstractEdgeProgram","A","AbstractNodeProgram","l","AbstractProgram","p","DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS","m","EdgeArrowHeadProgram","E","EdgeArrowProgram","n","EdgeClampedProgram","e","EdgeRectangleProgram","N","NodeCircleProgram","P","Program","q","createEdgeArrowProgram","o","createEdgeClampedProgram","j","createNodeCompoundProgram","c","drawDiscNodeHover","b","drawDiscNodeLabel","d","drawStraightEdgeLabel","r","getAttributeItemsCount","s","getAttributesItemsCount","w","killProgram","u","loadFragmentShader","v","loadProgram","t","loadVertexShader","x","numberToGLSLFloat","_inherits","a","_createClass","_classCallCheck","_callSuper","floatColor","SHADER_SOURCE$6","FRAGMENT_SHADER_SOURCE$2","SHADER_SOURCE$5","VERTEX_SHADER_SOURCE$3","_WebGLRenderingContex$3","WebGLRenderingContext","UNSIGNED_BYTE$3","UNSIGNED_BYTE","FLOAT$3","FLOAT","UNIFORMS$3","NodePointProgram","_NodeProgram","arguments","key","value","getDefinition","VERTICES","VERTEX_SHADER_SOURCE","FRAGMENT_SHADER_SOURCE","METHOD","POINTS","UNIFORMS","ATTRIBUTES","name","size","type","normalized","processVisibleItem","nodeIndex","startIndex","data","array","y","color","setUniforms","_ref","_ref2","sizeRatio","pixelRatio","matrix","gl","uniformLocations","u_sizeRatio","u_pixelRatio","u_matrix","uniform1f","uniformMatrix3fv","SHADER_SOURCE$4","VERTEX_SHADER_SOURCE$2","_WebGLRenderingContex$2","UNSIGNED_BYTE$2","FLOAT$2","UNIFORMS$2","DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS","lengthToThicknessRatio","createEdgeDoubleClampedProgram","inputOptions","options","_EdgeProgram","EdgeDoubleClampedProgram","TRIANGLES","CONSTANT_ATTRIBUTES","CONSTANT_DATA","edgeIndex","sourceData","targetData","thickness","x1","y1","x2","y2","dx","dy","sourceRadius","targetRadius","len","n1","n2","Math","sqrt","params","u_zoomRatio","u_feather","u_correctionRatio","u_minEdgeThickness","u_lengthToThicknessRatio","zoomRatio","correctionRatio","antiAliasingFeather","minEdgeThickness","EdgeDoubleClampedProgram$1","createEdgeDoubleArrowProgram","extremity","EdgeDoubleArrowProgram","EdgeDoubleArrowProgram$1","SHADER_SOURCE$3","FRAGMENT_SHADER_SOURCE$1","SHADER_SOURCE$2","VERTEX_SHADER_SOURCE$1","_WebGLRenderingContex$1","UNSIGNED_BYTE$1","FLOAT$1","UNIFORMS$1","EdgeLineProgram","LINES","SHADER_SOURCE$1","SHADER_SOURCE","_WebGLRenderingContex","EdgeTriangleProgram"],"sources":["/Users/fjodoin/Desktop/Research/AzureRT/azure_resource_graph/training/graphing/sigma-graph/node_modules/sigma/rendering/dist/sigma-rendering.esm.js"],"sourcesContent":["import { f as NodeProgram, D as DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS, _ as _objectSpread2, F as FRAGMENT_SHADER_SOURCE$3, g as EdgeProgram, h as createEdgeCompoundProgram, i as createEdgeArrowHeadProgram } from '../../dist/index-236c62ad.esm.js';\nexport { k as AbstractEdgeProgram, A as AbstractNodeProgram, l as AbstractProgram, D as DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS, p as DEFAULT_EDGE_CLAMPED_PROGRAM_OPTIONS, m as EdgeArrowHeadProgram, E as EdgeArrowProgram, n as EdgeClampedProgram, g as EdgeProgram, e as EdgeRectangleProgram, N as NodeCircleProgram, f as NodeProgram, P as Program, i as createEdgeArrowHeadProgram, q as createEdgeArrowProgram, o as createEdgeClampedProgram, h as createEdgeCompoundProgram, j as createNodeCompoundProgram, c as drawDiscNodeHover, b as drawDiscNodeLabel, d as drawStraightEdgeLabel, r as getAttributeItemsCount, s as getAttributesItemsCount, w as killProgram, u as loadFragmentShader, v as loadProgram, t as loadVertexShader, x as numberToGLSLFloat } from '../../dist/index-236c62ad.esm.js';\nimport { _ as _inherits, a as _createClass, b as _classCallCheck, c as _callSuper } from '../../dist/inherits-d1a1e29b.esm.js';\nimport { f as floatColor } from '../../dist/colors-beb06eb2.esm.js';\n\n// language=GLSL\nvar SHADER_SOURCE$6 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float radius = 0.5;\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\\n  float dist = radius - length(m);\\n\\n  // No antialiasing for picking mode:\\n  #ifdef PICKING_MODE\\n  if (dist > v_border)\\n    gl_FragColor = v_color;\\n  else\\n    gl_FragColor = transparent;\\n\\n  #else\\n  float t = 0.0;\\n  if (dist > v_border)\\n    t = 1.0;\\n  else if (dist > 0.0)\\n    t = dist / v_border;\\n\\n  gl_FragColor = mix(transparent, v_color, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$6;\n\n// language=GLSL\nvar SHADER_SOURCE$5 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\nattribute float a_size;\\n\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  // Multiply the point size twice:\\n  //  - x SCALING_RATIO to correct the canvas scaling\\n  //  - x 2 to correct the formulae\\n  gl_PointSize = a_size / u_sizeRatio * u_pixelRatio * 2.0;\\n\\n  v_border = (0.5 / a_size) * u_sizeRatio;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$3 = SHADER_SOURCE$5;\n\nvar _WebGLRenderingContex$3 = WebGLRenderingContext,\n  UNSIGNED_BYTE$3 = _WebGLRenderingContex$3.UNSIGNED_BYTE,\n  FLOAT$3 = _WebGLRenderingContex$3.FLOAT;\nvar UNIFORMS$3 = [\"u_sizeRatio\", \"u_pixelRatio\", \"u_matrix\"];\nvar NodePointProgram = /*#__PURE__*/function (_NodeProgram) {\n  function NodePointProgram() {\n    _classCallCheck(this, NodePointProgram);\n    return _callSuper(this, NodePointProgram, arguments);\n  }\n  _inherits(NodePointProgram, _NodeProgram);\n  return _createClass(NodePointProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 1,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$3,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,\n        METHOD: WebGLRenderingContext.POINTS,\n        UNIFORMS: UNIFORMS$3,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$3\n        }, {\n          name: \"a_size\",\n          size: 1,\n          type: FLOAT$3\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(nodeIndex, startIndex, data) {\n      var array = this.array;\n      array[startIndex++] = data.x;\n      array[startIndex++] = data.y;\n      array[startIndex++] = data.size;\n      array[startIndex++] = floatColor(data.color);\n      array[startIndex++] = nodeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(_ref, _ref2) {\n      var sizeRatio = _ref.sizeRatio,\n        pixelRatio = _ref.pixelRatio,\n        matrix = _ref.matrix;\n      var gl = _ref2.gl,\n        uniformLocations = _ref2.uniformLocations;\n      var u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_pixelRatio = uniformLocations.u_pixelRatio,\n        u_matrix = uniformLocations.u_matrix;\n      gl.uniform1f(u_pixelRatio, pixelRatio);\n      gl.uniform1f(u_sizeRatio, sizeRatio);\n      gl.uniformMatrix3fv(u_matrix, false, matrix);\n    }\n  }]);\n}(NodeProgram);\n\n// language=GLSL\nvar SHADER_SOURCE$4 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\nattribute float a_sourceRadius;\\nattribute float a_targetRadius;\\nattribute float a_sourceRadiusCoef;\\nattribute float a_targetRadiusCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_zoomRatio;\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform float u_correctionRatio;\\nuniform float u_minEdgeThickness;\\nuniform float u_lengthToThicknessRatio;\\nuniform float u_feather;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\nvarying float v_feather;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float minThickness = u_minEdgeThickness;\\n\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl. Please read it to\\n  // get better comments on what's happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here, we move the point to leave space for the arrow heads:\\n  // Source arrow head\\n  float sourceRadius = a_sourceRadius * a_sourceRadiusCoef;\\n  float sourceDirection = sign(sourceRadius);\\n  float webGLSourceRadius = sourceDirection * sourceRadius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLSourceArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\\n  vec2 sourceCompensationVector =\\n    vec2(-sourceDirection * unitNormal.y, sourceDirection * unitNormal.x)\\n    * (webGLSourceRadius + webGLSourceArrowHeadLength);\\n    \\n  // Target arrow head\\n  float targetRadius = a_targetRadius * a_targetRadiusCoef;\\n  float targetDirection = sign(targetRadius);\\n  float webGLTargetRadius = targetDirection * targetRadius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLTargetArrowHeadLength = webGLThickness * u_lengthToThicknessRatio * 2.0;\\n  vec2 targetCompensationVector =\\n  vec2(-targetDirection * unitNormal.y, targetDirection * unitNormal.x)\\n    * (webGLTargetRadius + webGLTargetArrowHeadLength);\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + sourceCompensationVector + targetCompensationVector, 1)).xy, 0, 1);\\n\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  v_feather = u_feather * u_correctionRatio / u_zoomRatio / u_pixelRatio * 2.0;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$4;\n\nvar _WebGLRenderingContex$2 = WebGLRenderingContext,\n  UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE,\n  FLOAT$2 = _WebGLRenderingContex$2.FLOAT;\nvar UNIFORMS$2 = [\"u_matrix\", \"u_zoomRatio\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_pixelRatio\", \"u_feather\", \"u_minEdgeThickness\", \"u_lengthToThicknessRatio\"];\nvar DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS = {\n  lengthToThicknessRatio: DEFAULT_EDGE_ARROW_HEAD_PROGRAM_OPTIONS.lengthToThicknessRatio\n};\nfunction createEdgeDoubleClampedProgram(inputOptions) {\n  var options = _objectSpread2(_objectSpread2({}, DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS), inputOptions || {});\n  return /*#__PURE__*/function (_EdgeProgram) {\n    function EdgeDoubleClampedProgram() {\n      _classCallCheck(this, EdgeDoubleClampedProgram);\n      return _callSuper(this, EdgeDoubleClampedProgram, arguments);\n    }\n    _inherits(EdgeDoubleClampedProgram, _EdgeProgram);\n    return _createClass(EdgeDoubleClampedProgram, [{\n      key: \"getDefinition\",\n      value: function getDefinition() {\n        return {\n          VERTICES: 6,\n          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,\n          FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$3,\n          METHOD: WebGLRenderingContext.TRIANGLES,\n          UNIFORMS: UNIFORMS$2,\n          ATTRIBUTES: [{\n            name: \"a_positionStart\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_positionEnd\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_normal\",\n            size: 2,\n            type: FLOAT$2\n          }, {\n            name: \"a_color\",\n            size: 4,\n            type: UNSIGNED_BYTE$2,\n            normalized: true\n          }, {\n            name: \"a_id\",\n            size: 4,\n            type: UNSIGNED_BYTE$2,\n            normalized: true\n          }, {\n            name: \"a_sourceRadius\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_targetRadius\",\n            size: 1,\n            type: FLOAT$2\n          }],\n          CONSTANT_ATTRIBUTES: [\n          // If 0, then position will be a_positionStart\n          // If 1, then position will be a_positionEnd\n          {\n            name: \"a_positionCoef\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_normalCoef\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_sourceRadiusCoef\",\n            size: 1,\n            type: FLOAT$2\n          }, {\n            name: \"a_targetRadiusCoef\",\n            size: 1,\n            type: FLOAT$2\n          }],\n          CONSTANT_DATA: [[0, 1, -1, 0], [0, -1, 1, 0], [1, 1, 0, 1], [1, 1, 0, 1], [0, -1, 1, 0], [1, -1, 0, -1]]\n        };\n      }\n    }, {\n      key: \"processVisibleItem\",\n      value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n        var thickness = data.size || 1;\n        var x1 = sourceData.x;\n        var y1 = sourceData.y;\n        var x2 = targetData.x;\n        var y2 = targetData.y;\n        var color = floatColor(data.color);\n\n        // Computing normals\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        var sourceRadius = sourceData.size || 1;\n        var targetRadius = targetData.size || 1;\n        var len = dx * dx + dy * dy;\n        var n1 = 0;\n        var n2 = 0;\n        if (len) {\n          len = 1 / Math.sqrt(len);\n          n1 = -dy * len * thickness;\n          n2 = dx * len * thickness;\n        }\n        var array = this.array;\n        array[startIndex++] = x1;\n        array[startIndex++] = y1;\n        array[startIndex++] = x2;\n        array[startIndex++] = y2;\n        array[startIndex++] = n1;\n        array[startIndex++] = n2;\n        array[startIndex++] = color;\n        array[startIndex++] = edgeIndex;\n        array[startIndex++] = sourceRadius;\n        array[startIndex++] = targetRadius;\n      }\n    }, {\n      key: \"setUniforms\",\n      value: function setUniforms(params, _ref) {\n        var gl = _ref.gl,\n          uniformLocations = _ref.uniformLocations;\n        var u_matrix = uniformLocations.u_matrix,\n          u_zoomRatio = uniformLocations.u_zoomRatio,\n          u_feather = uniformLocations.u_feather,\n          u_pixelRatio = uniformLocations.u_pixelRatio,\n          u_correctionRatio = uniformLocations.u_correctionRatio,\n          u_sizeRatio = uniformLocations.u_sizeRatio,\n          u_minEdgeThickness = uniformLocations.u_minEdgeThickness,\n          u_lengthToThicknessRatio = uniformLocations.u_lengthToThicknessRatio;\n        gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n        gl.uniform1f(u_zoomRatio, params.zoomRatio);\n        gl.uniform1f(u_sizeRatio, params.sizeRatio);\n        gl.uniform1f(u_correctionRatio, params.correctionRatio);\n        gl.uniform1f(u_pixelRatio, params.pixelRatio);\n        gl.uniform1f(u_feather, params.antiAliasingFeather);\n        gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n        gl.uniform1f(u_lengthToThicknessRatio, options.lengthToThicknessRatio);\n      }\n    }]);\n  }(EdgeProgram);\n}\nvar EdgeDoubleClampedProgram = createEdgeDoubleClampedProgram();\nvar EdgeDoubleClampedProgram$1 = EdgeDoubleClampedProgram;\n\nfunction createEdgeDoubleArrowProgram(inputOptions) {\n  return createEdgeCompoundProgram([createEdgeDoubleClampedProgram(inputOptions), createEdgeArrowHeadProgram(inputOptions), createEdgeArrowHeadProgram(_objectSpread2(_objectSpread2({}, inputOptions), {}, {\n    extremity: \"source\"\n  }))]);\n}\nvar EdgeDoubleArrowProgram = createEdgeDoubleArrowProgram();\nvar EdgeDoubleArrowProgram$1 = EdgeDoubleArrowProgram;\n\n// language=GLSL\nvar SHADER_SOURCE$3 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$3;\n\n// language=GLSL\nvar SHADER_SOURCE$2 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\n\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  // Scale from [[-1 1] [-1 1]] to the container:\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$2;\n\nvar _WebGLRenderingContex$1 = WebGLRenderingContext,\n  UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE,\n  FLOAT$1 = _WebGLRenderingContex$1.FLOAT;\nvar UNIFORMS$1 = [\"u_matrix\"];\nvar EdgeLineProgram = /*#__PURE__*/function (_EdgeProgram) {\n  function EdgeLineProgram() {\n    _classCallCheck(this, EdgeLineProgram);\n    return _callSuper(this, EdgeLineProgram, arguments);\n  }\n  _inherits(EdgeLineProgram, _EdgeProgram);\n  return _createClass(EdgeLineProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 2,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,\n        METHOD: WebGLRenderingContext.LINES,\n        UNIFORMS: UNIFORMS$1,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var array = this.array;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // First point\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n\n      // Second point\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    }\n  }]);\n}(EdgeProgram);\n\n// language=GLSL\nvar SHADER_SOURCE$1 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$1;\n\n// language=GLSL\nvar SHADER_SOURCE = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  // The only different here with edge.vert.glsl is that we need to handle null\\n  // input normal vector. Apart from that, you can read edge.vert.glsl more info\\n  // on how it works:\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n  if (normalLength <= 0.0) unitNormal = normal;\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE = SHADER_SOURCE;\n\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nvar UNIFORMS = [\"u_matrix\", \"u_sizeRatio\", \"u_correctionRatio\", \"u_minEdgeThickness\"];\nvar EdgeTriangleProgram = /*#__PURE__*/function (_EdgeProgram) {\n  function EdgeTriangleProgram() {\n    _classCallCheck(this, EdgeTriangleProgram);\n    return _callSuper(this, EdgeTriangleProgram, arguments);\n  }\n  _inherits(EdgeTriangleProgram, _EdgeProgram);\n  return _createClass(EdgeTriangleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS,\n        ATTRIBUTES: [{\n          name: \"a_positionStart\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_positionEnd\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 1, then position will be a_positionEnd\n        {\n          name: \"a_positionCoef\",\n          size: 1,\n          type: FLOAT\n        }, {\n          name: \"a_normalCoef\",\n          size: 1,\n          type: FLOAT\n        }],\n        CONSTANT_DATA: [[0, 1], [0, -1], [1, 0]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = floatColor(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n\n      // First point\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix,\n        u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_minEdgeThickness = uniformLocations.u_minEdgeThickness;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n      gl.uniform1f(u_minEdgeThickness, params.minEdgeThickness);\n    }\n  }]);\n}(EdgeProgram);\n\nexport { DEFAULT_EDGE_DOUBLE_CLAMPED_PROGRAM_OPTIONS, EdgeDoubleArrowProgram$1 as EdgeDoubleArrowProgram, EdgeDoubleClampedProgram$1 as EdgeDoubleClampedProgram, EdgeLineProgram, EdgeTriangleProgram, NodePointProgram, createEdgeDoubleArrowProgram, createEdgeDoubleClampedProgram };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}